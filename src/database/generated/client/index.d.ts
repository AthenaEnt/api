
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Verification
 * 
 */
export type Verification = {
  id: string
  type: string
  otpCode: string
  email: string | null
  tel: string | null
  context: string
  pwdRecoverKey: string | null
  hasBeenVerified: boolean
  expireAt: Date
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: string
  title: string
  slug: string
  description: string | null
  createdAt: Date
  updatedAt: Date
  parentId: string | null
  iconImageId: string | null
  bannerImageId: string | null
}

/**
 * Model Marque
 * 
 */
export type Marque = {
  id: string
  imageId: string | null
  name: string
  categoryId: string
}

/**
 * Model Discount
 * 
 */
export type Discount = {
  id: string
  name: string
  bannerImageId: string | null
  discountType: string
  discountNature: string
  discountCode: string
  discount: number
  startAt: Date
  endAt: Date
  inCartProductMin: number | null
  inCartProductMax: number | null
  commandAmountMin: number | null
  commandAmountMax: number | null
  description: string | null
}

/**
 * Model PriceRule
 * 
 */
export type PriceRule = {
  id: string
  minPrice: number
  maxPrice: number | null
  amountPercent: number
}

/**
 * Model Pub
 * 
 */
export type Pub = {
  id: string
  name: string
  bannerImageId: string | null
  link: string | null
  description: string | null
  startAt: Date
  endAt: Date
  forDiscountId: string | null
}

/**
 * Model ShippingZone
 * 
 */
export type ShippingZone = {
  id: string
  townName: string
  townCode: string
  baseShippingPrice: number
}

/**
 * Model ShippingRule
 * 
 */
export type ShippingRule = {
  id: string
  ruleName: string
  rule: Prisma.JsonValue
  description: string
}

/**
 * Model GeneralMeta
 * 
 */
export type GeneralMeta = {
  id: string
  name: string
  key: string
  value: Prisma.JsonValue
}

/**
 * Model ProductAttributeMeta
 * 
 */
export type ProductAttributeMeta = {
  id: string
  attributeId: string
  name: string
  value: Prisma.JsonValue
}

/**
 * Model ProductAttribute
 * 
 */
export type ProductAttribute = {
  id: string
  name: string
  type: string
  description: string | null
  global: boolean
  categoryId: string | null
  onlyForProductId: string | null
}

/**
 * Model Tag
 * 
 */
export type Tag = {
  id: string
  name: string
  slug: string
}

/**
 * Model CommandUnit
 * 
 */
export type CommandUnit = {
  id: string
  title: string
  shortCode: string
}

/**
 * Model CommandUnitProduct
 * 
 */
export type CommandUnitProduct = {
  id: string
  commandUnitId: string
  productId: string
  isDefault: boolean
  unitPrice: number
  priceRuleId: string
}

/**
 * Model Media
 * 
 */
export type Media = {
  id: string
  filename: string
  fileType: string
  path: string
  fileDuration: number | null
  source: string
  userId: string | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: string
  name: string
  slug: string
  description: string | null
  shortDescription: string | null
  type: string
  productWeight: number | null
  isPublished: boolean
  createdAt: Date
  updatedAt: Date
  sku: string | null
  marqueId: string | null
  variantParentId: string | null
  showProduct: boolean
  hasUserDeleted: boolean
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  id: string
  content: string
  title: string
  createdAt: Date
  context: string
  priority: number
  canLockScreen: boolean
  theme: string
  commandId: string | null
  hasUserRead: boolean
  userId: string | null
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  firstName: string
  lastName: string
  passwordHash: string
  email: string
  phone: string
  accoundActivated: boolean
  role: string
  currentRole: string
}

/**
 * Model UserShippingAdress
 * 
 */
export type UserShippingAdress = {
  id: string
  shippingZoneId: string
  fullName: string
  phone: string
  alternatePhone: string
  adressType: string
  quatier: string
  hasUserDeleted: boolean
  additionalDetails: string | null
  audioFileId: string | null
  forUserId: string
}

/**
 * Model Command
 * 
 */
export type Command = {
  id: string
  createdAt: Date
  updatedAt: Date
  totalPrice: number
  orderId: number
  archived: boolean | null
  delivered: boolean
  status: string
  orderedById: string
  hasUserCanceled: boolean
  hasUserDeleted: boolean
  shippingAdressId: string | null
  receiptId: string
  appliedDiscountId: string | null
}

/**
 * Model CommandProduct
 * 
 */
export type CommandProduct = {
  id: string
  productId: string
  hasUserDeleted: boolean
  commandUnitProductId: string
  quantite: number
  commandId: string
  hasCustomerConfirmShipping: boolean
  hasAgentConfirmShipping: boolean
}

/**
 * Model Receipt
 * 
 */
export type Receipt = {
  id: string
  amount: number
  createdAt: Date
  hasUserDeleted: boolean
  paidAt: Date | null
  isPaid: boolean
  outPaymentId: string | null
  outPaymentDetails: Prisma.JsonValue | null
  receiptMetas: Prisma.JsonValue
  receiptMediaId: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Verifications
 * const verifications = await prisma.verification.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Verifications
   * const verifications = await prisma.verification.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.marque`: Exposes CRUD operations for the **Marque** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marques
    * const marques = await prisma.marque.findMany()
    * ```
    */
  get marque(): Prisma.MarqueDelegate<GlobalReject>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<GlobalReject>;

  /**
   * `prisma.priceRule`: Exposes CRUD operations for the **PriceRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceRules
    * const priceRules = await prisma.priceRule.findMany()
    * ```
    */
  get priceRule(): Prisma.PriceRuleDelegate<GlobalReject>;

  /**
   * `prisma.pub`: Exposes CRUD operations for the **Pub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pubs
    * const pubs = await prisma.pub.findMany()
    * ```
    */
  get pub(): Prisma.PubDelegate<GlobalReject>;

  /**
   * `prisma.shippingZone`: Exposes CRUD operations for the **ShippingZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingZones
    * const shippingZones = await prisma.shippingZone.findMany()
    * ```
    */
  get shippingZone(): Prisma.ShippingZoneDelegate<GlobalReject>;

  /**
   * `prisma.shippingRule`: Exposes CRUD operations for the **ShippingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingRules
    * const shippingRules = await prisma.shippingRule.findMany()
    * ```
    */
  get shippingRule(): Prisma.ShippingRuleDelegate<GlobalReject>;

  /**
   * `prisma.generalMeta`: Exposes CRUD operations for the **GeneralMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneralMetas
    * const generalMetas = await prisma.generalMeta.findMany()
    * ```
    */
  get generalMeta(): Prisma.GeneralMetaDelegate<GlobalReject>;

  /**
   * `prisma.productAttributeMeta`: Exposes CRUD operations for the **ProductAttributeMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAttributeMetas
    * const productAttributeMetas = await prisma.productAttributeMeta.findMany()
    * ```
    */
  get productAttributeMeta(): Prisma.ProductAttributeMetaDelegate<GlobalReject>;

  /**
   * `prisma.productAttribute`: Exposes CRUD operations for the **ProductAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAttributes
    * const productAttributes = await prisma.productAttribute.findMany()
    * ```
    */
  get productAttribute(): Prisma.ProductAttributeDelegate<GlobalReject>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<GlobalReject>;

  /**
   * `prisma.commandUnit`: Exposes CRUD operations for the **CommandUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandUnits
    * const commandUnits = await prisma.commandUnit.findMany()
    * ```
    */
  get commandUnit(): Prisma.CommandUnitDelegate<GlobalReject>;

  /**
   * `prisma.commandUnitProduct`: Exposes CRUD operations for the **CommandUnitProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandUnitProducts
    * const commandUnitProducts = await prisma.commandUnitProduct.findMany()
    * ```
    */
  get commandUnitProduct(): Prisma.CommandUnitProductDelegate<GlobalReject>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userShippingAdress`: Exposes CRUD operations for the **UserShippingAdress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserShippingAdresses
    * const userShippingAdresses = await prisma.userShippingAdress.findMany()
    * ```
    */
  get userShippingAdress(): Prisma.UserShippingAdressDelegate<GlobalReject>;

  /**
   * `prisma.command`: Exposes CRUD operations for the **Command** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commands
    * const commands = await prisma.command.findMany()
    * ```
    */
  get command(): Prisma.CommandDelegate<GlobalReject>;

  /**
   * `prisma.commandProduct`: Exposes CRUD operations for the **CommandProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandProducts
    * const commandProducts = await prisma.commandProduct.findMany()
    * ```
    */
  get commandProduct(): Prisma.CommandProductDelegate<GlobalReject>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.8.1
   * Query Engine version: 34df67547cf5598f5a6cd3eb45f14ee70c3fb86f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Verification: 'Verification',
    Category: 'Category',
    Marque: 'Marque',
    Discount: 'Discount',
    PriceRule: 'PriceRule',
    Pub: 'Pub',
    ShippingZone: 'ShippingZone',
    ShippingRule: 'ShippingRule',
    GeneralMeta: 'GeneralMeta',
    ProductAttributeMeta: 'ProductAttributeMeta',
    ProductAttribute: 'ProductAttribute',
    Tag: 'Tag',
    CommandUnit: 'CommandUnit',
    CommandUnitProduct: 'CommandUnitProduct',
    Media: 'Media',
    Product: 'Product',
    Notification: 'Notification',
    User: 'User',
    UserShippingAdress: 'UserShippingAdress',
    Command: 'Command',
    CommandProduct: 'CommandProduct',
    Receipt: 'Receipt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    marques: number
    products: number
    children: number
    attributes: number
  }

  export type CategoryCountOutputTypeSelect = {
    marques?: boolean
    products?: boolean
    children?: boolean
    attributes?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryCountOutputTypeArgs
    ?'include' extends U
    ? CategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CategoryCountOutputType ?CategoryCountOutputType [P]
  : 
     never
  } 
    : CategoryCountOutputType
  : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type MarqueCountOutputType
   */


  export type MarqueCountOutputType = {
    category: number
    products: number
  }

  export type MarqueCountOutputTypeSelect = {
    category?: boolean
    products?: boolean
  }

  export type MarqueCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MarqueCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MarqueCountOutputType
    : S extends undefined
    ? never
    : S extends MarqueCountOutputTypeArgs
    ?'include' extends U
    ? MarqueCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MarqueCountOutputType ?MarqueCountOutputType [P]
  : 
     never
  } 
    : MarqueCountOutputType
  : MarqueCountOutputType




  // Custom InputTypes

  /**
   * MarqueCountOutputType without action
   */
  export type MarqueCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarqueCountOutputType
     * 
    **/
    select?: MarqueCountOutputTypeSelect | null
  }



  /**
   * Count Type DiscountCountOutputType
   */


  export type DiscountCountOutputType = {
    command: number
    pubs: number
    product: number
  }

  export type DiscountCountOutputTypeSelect = {
    command?: boolean
    pubs?: boolean
    product?: boolean
  }

  export type DiscountCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DiscountCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DiscountCountOutputType
    : S extends undefined
    ? never
    : S extends DiscountCountOutputTypeArgs
    ?'include' extends U
    ? DiscountCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof DiscountCountOutputType ?DiscountCountOutputType [P]
  : 
     never
  } 
    : DiscountCountOutputType
  : DiscountCountOutputType




  // Custom InputTypes

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     * 
    **/
    select?: DiscountCountOutputTypeSelect | null
  }



  /**
   * Count Type PriceRuleCountOutputType
   */


  export type PriceRuleCountOutputType = {
    commandUnitProducts: number
  }

  export type PriceRuleCountOutputTypeSelect = {
    commandUnitProducts?: boolean
  }

  export type PriceRuleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PriceRuleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PriceRuleCountOutputType
    : S extends undefined
    ? never
    : S extends PriceRuleCountOutputTypeArgs
    ?'include' extends U
    ? PriceRuleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PriceRuleCountOutputType ?PriceRuleCountOutputType [P]
  : 
     never
  } 
    : PriceRuleCountOutputType
  : PriceRuleCountOutputType




  // Custom InputTypes

  /**
   * PriceRuleCountOutputType without action
   */
  export type PriceRuleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PriceRuleCountOutputType
     * 
    **/
    select?: PriceRuleCountOutputTypeSelect | null
  }



  /**
   * Count Type ShippingZoneCountOutputType
   */


  export type ShippingZoneCountOutputType = {
    userShippingAdress: number
    products: number
  }

  export type ShippingZoneCountOutputTypeSelect = {
    userShippingAdress?: boolean
    products?: boolean
  }

  export type ShippingZoneCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShippingZoneCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShippingZoneCountOutputType
    : S extends undefined
    ? never
    : S extends ShippingZoneCountOutputTypeArgs
    ?'include' extends U
    ? ShippingZoneCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ShippingZoneCountOutputType ?ShippingZoneCountOutputType [P]
  : 
     never
  } 
    : ShippingZoneCountOutputType
  : ShippingZoneCountOutputType




  // Custom InputTypes

  /**
   * ShippingZoneCountOutputType without action
   */
  export type ShippingZoneCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShippingZoneCountOutputType
     * 
    **/
    select?: ShippingZoneCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductAttributeMetaCountOutputType
   */


  export type ProductAttributeMetaCountOutputType = {
    products: number
  }

  export type ProductAttributeMetaCountOutputTypeSelect = {
    products?: boolean
  }

  export type ProductAttributeMetaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductAttributeMetaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductAttributeMetaCountOutputType
    : S extends undefined
    ? never
    : S extends ProductAttributeMetaCountOutputTypeArgs
    ?'include' extends U
    ? ProductAttributeMetaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttributeMetaCountOutputType ?ProductAttributeMetaCountOutputType [P]
  : 
     never
  } 
    : ProductAttributeMetaCountOutputType
  : ProductAttributeMetaCountOutputType




  // Custom InputTypes

  /**
   * ProductAttributeMetaCountOutputType without action
   */
  export type ProductAttributeMetaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMetaCountOutputType
     * 
    **/
    select?: ProductAttributeMetaCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductAttributeCountOutputType
   */


  export type ProductAttributeCountOutputType = {
    metas: number
  }

  export type ProductAttributeCountOutputTypeSelect = {
    metas?: boolean
  }

  export type ProductAttributeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductAttributeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductAttributeCountOutputType
    : S extends undefined
    ? never
    : S extends ProductAttributeCountOutputTypeArgs
    ?'include' extends U
    ? ProductAttributeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttributeCountOutputType ?ProductAttributeCountOutputType [P]
  : 
     never
  } 
    : ProductAttributeCountOutputType
  : ProductAttributeCountOutputType




  // Custom InputTypes

  /**
   * ProductAttributeCountOutputType without action
   */
  export type ProductAttributeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeCountOutputType
     * 
    **/
    select?: ProductAttributeCountOutputTypeSelect | null
  }



  /**
   * Count Type TagCountOutputType
   */


  export type TagCountOutputType = {
    products: number
  }

  export type TagCountOutputTypeSelect = {
    products?: boolean
  }

  export type TagCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TagCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TagCountOutputType
    : S extends undefined
    ? never
    : S extends TagCountOutputTypeArgs
    ?'include' extends U
    ? TagCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TagCountOutputType ?TagCountOutputType [P]
  : 
     never
  } 
    : TagCountOutputType
  : TagCountOutputType




  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     * 
    **/
    select?: TagCountOutputTypeSelect | null
  }



  /**
   * Count Type CommandUnitCountOutputType
   */


  export type CommandUnitCountOutputType = {
    commandUnitProducts: number
  }

  export type CommandUnitCountOutputTypeSelect = {
    commandUnitProducts?: boolean
  }

  export type CommandUnitCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CommandUnitCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CommandUnitCountOutputType
    : S extends undefined
    ? never
    : S extends CommandUnitCountOutputTypeArgs
    ?'include' extends U
    ? CommandUnitCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandUnitCountOutputType ?CommandUnitCountOutputType [P]
  : 
     never
  } 
    : CommandUnitCountOutputType
  : CommandUnitCountOutputType




  // Custom InputTypes

  /**
   * CommandUnitCountOutputType without action
   */
  export type CommandUnitCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitCountOutputType
     * 
    **/
    select?: CommandUnitCountOutputTypeSelect | null
  }



  /**
   * Count Type CommandUnitProductCountOutputType
   */


  export type CommandUnitProductCountOutputType = {
    commandProducts: number
  }

  export type CommandUnitProductCountOutputTypeSelect = {
    commandProducts?: boolean
  }

  export type CommandUnitProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CommandUnitProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CommandUnitProductCountOutputType
    : S extends undefined
    ? never
    : S extends CommandUnitProductCountOutputTypeArgs
    ?'include' extends U
    ? CommandUnitProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandUnitProductCountOutputType ?CommandUnitProductCountOutputType [P]
  : 
     never
  } 
    : CommandUnitProductCountOutputType
  : CommandUnitProductCountOutputType




  // Custom InputTypes

  /**
   * CommandUnitProductCountOutputType without action
   */
  export type CommandUnitProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProductCountOutputType
     * 
    **/
    select?: CommandUnitProductCountOutputTypeSelect | null
  }



  /**
   * Count Type MediaCountOutputType
   */


  export type MediaCountOutputType = {
    products: number
    iconImagesCategories: number
    bannerImagesCategories: number
    marque: number
    pubs: number
    userShippingAdresses: number
    discounts: number
    receiptMedias: number
  }

  export type MediaCountOutputTypeSelect = {
    products?: boolean
    iconImagesCategories?: boolean
    bannerImagesCategories?: boolean
    marque?: boolean
    pubs?: boolean
    userShippingAdresses?: boolean
    discounts?: boolean
    receiptMedias?: boolean
  }

  export type MediaCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MediaCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MediaCountOutputType
    : S extends undefined
    ? never
    : S extends MediaCountOutputTypeArgs
    ?'include' extends U
    ? MediaCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MediaCountOutputType ?MediaCountOutputType [P]
  : 
     never
  } 
    : MediaCountOutputType
  : MediaCountOutputType




  // Custom InputTypes

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     * 
    **/
    select?: MediaCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    productAttributes: number
    variationMetas: number
    variations: number
    categories: number
    shippingZones: number
    tags: number
    medias: number
    commandUnitProducts: number
    commandProducts: number
    discounts: number
  }

  export type ProductCountOutputTypeSelect = {
    productAttributes?: boolean
    variationMetas?: boolean
    variations?: boolean
    categories?: boolean
    shippingZones?: boolean
    tags?: boolean
    medias?: boolean
    commandUnitProducts?: boolean
    commandProducts?: boolean
    discounts?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCountOutputType ?ProductCountOutputType [P]
  : 
     never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    commands: number
    shippingAdress: number
    notifications: number
  }

  export type UserCountOutputTypeSelect = {
    commands?: boolean
    shippingAdress?: boolean
    notifications?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type UserShippingAdressCountOutputType
   */


  export type UserShippingAdressCountOutputType = {
    commands: number
  }

  export type UserShippingAdressCountOutputTypeSelect = {
    commands?: boolean
  }

  export type UserShippingAdressCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserShippingAdressCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserShippingAdressCountOutputType
    : S extends undefined
    ? never
    : S extends UserShippingAdressCountOutputTypeArgs
    ?'include' extends U
    ? UserShippingAdressCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserShippingAdressCountOutputType ?UserShippingAdressCountOutputType [P]
  : 
     never
  } 
    : UserShippingAdressCountOutputType
  : UserShippingAdressCountOutputType




  // Custom InputTypes

  /**
   * UserShippingAdressCountOutputType without action
   */
  export type UserShippingAdressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdressCountOutputType
     * 
    **/
    select?: UserShippingAdressCountOutputTypeSelect | null
  }



  /**
   * Count Type CommandCountOutputType
   */


  export type CommandCountOutputType = {
    commandProducts: number
    notifications: number
  }

  export type CommandCountOutputTypeSelect = {
    commandProducts?: boolean
    notifications?: boolean
  }

  export type CommandCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CommandCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CommandCountOutputType
    : S extends undefined
    ? never
    : S extends CommandCountOutputTypeArgs
    ?'include' extends U
    ? CommandCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandCountOutputType ?CommandCountOutputType [P]
  : 
     never
  } 
    : CommandCountOutputType
  : CommandCountOutputType




  // Custom InputTypes

  /**
   * CommandCountOutputType without action
   */
  export type CommandCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommandCountOutputType
     * 
    **/
    select?: CommandCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Verification
   */


  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    otpCode: string | null
    email: string | null
    tel: string | null
    context: string | null
    pwdRecoverKey: string | null
    hasBeenVerified: boolean | null
    expireAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    otpCode: string | null
    email: string | null
    tel: string | null
    context: string | null
    pwdRecoverKey: string | null
    hasBeenVerified: boolean | null
    expireAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    type: number
    otpCode: number
    email: number
    tel: number
    context: number
    pwdRecoverKey: number
    hasBeenVerified: number
    expireAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    type?: true
    otpCode?: true
    email?: true
    tel?: true
    context?: true
    pwdRecoverKey?: true
    hasBeenVerified?: true
    expireAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    type?: true
    otpCode?: true
    email?: true
    tel?: true
    context?: true
    pwdRecoverKey?: true
    hasBeenVerified?: true
    expireAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    type?: true
    otpCode?: true
    email?: true
    tel?: true
    context?: true
    pwdRecoverKey?: true
    hasBeenVerified?: true
    expireAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs = {
    /**
     * Filter which Verification to aggregate.
     * 
    **/
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs = {
    where?: VerificationWhereInput
    orderBy?: Enumerable<VerificationOrderByWithAggregationInput>
    by: Array<VerificationScalarFieldEnum>
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }


  export type VerificationGroupByOutputType = {
    id: string
    type: string
    otpCode: string
    email: string | null
    tel: string | null
    context: string
    pwdRecoverKey: string | null
    hasBeenVerified: boolean
    expireAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Promise<
    Array<
      PickArray<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect = {
    id?: boolean
    type?: boolean
    otpCode?: boolean
    email?: boolean
    tel?: boolean
    context?: boolean
    pwdRecoverKey?: boolean
    hasBeenVerified?: boolean
    expireAt?: boolean
  }

  export type VerificationGetPayload<
    S extends boolean | null | undefined | VerificationArgs,
    U = keyof S
      > = S extends true
        ? Verification
    : S extends undefined
    ? never
    : S extends VerificationArgs | VerificationFindManyArgs
    ?'include' extends U
    ? Verification 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Verification ?Verification [P]
  : 
     never
  } 
    : Verification
  : Verification


  type VerificationCountArgs = Merge<
    Omit<VerificationFindManyArgs, 'select' | 'include'> & {
      select?: VerificationCountAggregateInputType | true
    }
  >

  export interface VerificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VerificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Verification'> extends True ? CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>> : CheckSelect<T, Prisma__VerificationClient<Verification | null >, Prisma__VerificationClient<VerificationGetPayload<T> | null >>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VerificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Verification'> extends True ? CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>> : CheckSelect<T, Prisma__VerificationClient<Verification | null >, Prisma__VerificationClient<VerificationGetPayload<T> | null >>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VerificationFindManyArgs>(
      args?: SelectSubset<T, VerificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Verification>>, PrismaPromise<Array<VerificationGetPayload<T>>>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
    **/
    create<T extends VerificationCreateArgs>(
      args: SelectSubset<T, VerificationCreateArgs>
    ): CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>>

    /**
     * Create many Verifications.
     *     @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     *     @example
     *     // Create many Verifications
     *     const verification = await prisma.verification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationCreateManyArgs>(
      args?: SelectSubset<T, VerificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
    **/
    delete<T extends VerificationDeleteArgs>(
      args: SelectSubset<T, VerificationDeleteArgs>
    ): CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationUpdateArgs>(
      args: SelectSubset<T, VerificationUpdateArgs>
    ): CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationDeleteManyArgs>(
      args?: SelectSubset<T, VerificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationUpdateManyArgs>(
      args: SelectSubset<T, VerificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationUpsertArgs>(
      args: SelectSubset<T, VerificationUpsertArgs>
    ): CheckSelect<T, Prisma__VerificationClient<Verification>, Prisma__VerificationClient<VerificationGetPayload<T>>>

    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VerificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * Throw an Error if a Verification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Verification to fetch.
     * 
    **/
    where: VerificationWhereUniqueInput
  }


  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * Throw an Error if a Verification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Verification to fetch.
     * 
    **/
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     * 
    **/
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     * 
    **/
    distinct?: Enumerable<VerificationScalarFieldEnum>
  }


  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * Filter, which Verifications to fetch.
     * 
    **/
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     * 
    **/
    orderBy?: Enumerable<VerificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     * 
    **/
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VerificationScalarFieldEnum>
  }


  /**
   * Verification create
   */
  export type VerificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * The data needed to create a Verification.
     * 
    **/
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }


  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs = {
    data: Enumerable<VerificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Verification update
   */
  export type VerificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * The data needed to update a Verification.
     * 
    **/
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     * 
    **/
    where: VerificationWhereUniqueInput
  }


  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs = {
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    where?: VerificationWhereInput
  }


  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * The filter to search for the Verification to update in case it exists.
     * 
    **/
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     * 
    **/
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }


  /**
   * Verification delete
   */
  export type VerificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
    /**
     * Filter which Verification to delete.
     * 
    **/
    where: VerificationWhereUniqueInput
  }


  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs = {
    where?: VerificationWhereInput
  }


  /**
   * Verification without action
   */
  export type VerificationArgs = {
    /**
     * Select specific fields to fetch from the Verification
     * 
    **/
    select?: VerificationSelect | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    iconImageId: string | null
    bannerImageId: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    iconImageId: string | null
    bannerImageId: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    parentId: number
    iconImageId: number
    bannerImageId: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    iconImageId?: true
    bannerImageId?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    iconImageId?: true
    bannerImageId?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    iconImageId?: true
    bannerImageId?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    iconImageId: string | null
    bannerImageId: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Promise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    parent?: boolean | CategoryArgs
    iconImageId?: boolean
    bannerImageId?: boolean
    iconImage?: boolean | MediaArgs
    bannerImage?: boolean | MediaArgs
    marques?: boolean | MarqueFindManyArgs
    products?: boolean | ProductFindManyArgs
    children?: boolean | CategoryFindManyArgs
    attributes?: boolean | ProductAttributeFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryInclude = {
    parent?: boolean | CategoryArgs
    iconImage?: boolean | MediaArgs
    bannerImage?: boolean | MediaArgs
    marques?: boolean | MarqueFindManyArgs
    products?: boolean | ProductFindManyArgs
    children?: boolean | CategoryFindManyArgs
    attributes?: boolean | ProductAttributeFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'parent'
        ? CategoryGetPayload<S['include'][P]> | null :
        P extends 'iconImage'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'bannerImage'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'marques'
        ? Array < MarqueGetPayload<S['include'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'children'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'attributes'
        ? Array < ProductAttributeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CategoryCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Category ?Category [P]
  : 
          P extends 'parent'
        ? CategoryGetPayload<S['select'][P]> | null :
        P extends 'iconImage'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'bannerImage'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'marques'
        ? Array < MarqueGetPayload<S['select'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'children'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'attributes'
        ? Array < ProductAttributeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CategoryCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parent<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    iconImage<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    bannerImage<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    marques<T extends MarqueFindManyArgs = {}>(args?: Subset<T, MarqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Marque>>, PrismaPromise<Array<MarqueGetPayload<T>>>>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    children<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    attributes<T extends ProductAttributeFindManyArgs = {}>(args?: Subset<T, ProductAttributeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttribute>>, PrismaPromise<Array<ProductAttributeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Marque
   */


  export type AggregateMarque = {
    _count: MarqueCountAggregateOutputType | null
    _min: MarqueMinAggregateOutputType | null
    _max: MarqueMaxAggregateOutputType | null
  }

  export type MarqueMinAggregateOutputType = {
    id: string | null
    imageId: string | null
    name: string | null
    categoryId: string | null
  }

  export type MarqueMaxAggregateOutputType = {
    id: string | null
    imageId: string | null
    name: string | null
    categoryId: string | null
  }

  export type MarqueCountAggregateOutputType = {
    id: number
    imageId: number
    name: number
    categoryId: number
    _all: number
  }


  export type MarqueMinAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
    categoryId?: true
  }

  export type MarqueMaxAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
    categoryId?: true
  }

  export type MarqueCountAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
    categoryId?: true
    _all?: true
  }

  export type MarqueAggregateArgs = {
    /**
     * Filter which Marque to aggregate.
     * 
    **/
    where?: MarqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marques to fetch.
     * 
    **/
    orderBy?: Enumerable<MarqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MarqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marques
    **/
    _count?: true | MarqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarqueMaxAggregateInputType
  }

  export type GetMarqueAggregateType<T extends MarqueAggregateArgs> = {
        [P in keyof T & keyof AggregateMarque]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarque[P]>
      : GetScalarType<T[P], AggregateMarque[P]>
  }




  export type MarqueGroupByArgs = {
    where?: MarqueWhereInput
    orderBy?: Enumerable<MarqueOrderByWithAggregationInput>
    by: Array<MarqueScalarFieldEnum>
    having?: MarqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarqueCountAggregateInputType | true
    _min?: MarqueMinAggregateInputType
    _max?: MarqueMaxAggregateInputType
  }


  export type MarqueGroupByOutputType = {
    id: string
    imageId: string | null
    name: string
    categoryId: string
    _count: MarqueCountAggregateOutputType | null
    _min: MarqueMinAggregateOutputType | null
    _max: MarqueMaxAggregateOutputType | null
  }

  type GetMarqueGroupByPayload<T extends MarqueGroupByArgs> = Promise<
    Array<
      PickArray<MarqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarqueGroupByOutputType[P]>
            : GetScalarType<T[P], MarqueGroupByOutputType[P]>
        }
      >
    >


  export type MarqueSelect = {
    id?: boolean
    imageId?: boolean
    image?: boolean | MediaArgs
    name?: boolean
    categoryId?: boolean
    category?: boolean | CategoryFindManyArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | MarqueCountOutputTypeArgs
  }

  export type MarqueInclude = {
    image?: boolean | MediaArgs
    category?: boolean | CategoryFindManyArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | MarqueCountOutputTypeArgs
  }

  export type MarqueGetPayload<
    S extends boolean | null | undefined | MarqueArgs,
    U = keyof S
      > = S extends true
        ? Marque
    : S extends undefined
    ? never
    : S extends MarqueArgs | MarqueFindManyArgs
    ?'include' extends U
    ? Marque  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'image'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'category'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? MarqueCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Marque ?Marque [P]
  : 
          P extends 'image'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'category'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? MarqueCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Marque
  : Marque


  type MarqueCountArgs = Merge<
    Omit<MarqueFindManyArgs, 'select' | 'include'> & {
      select?: MarqueCountAggregateInputType | true
    }
  >

  export interface MarqueDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Marque that matches the filter.
     * @param {MarqueFindUniqueArgs} args - Arguments to find a Marque
     * @example
     * // Get one Marque
     * const marque = await prisma.marque.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarqueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarqueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Marque'> extends True ? CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>> : CheckSelect<T, Prisma__MarqueClient<Marque | null >, Prisma__MarqueClient<MarqueGetPayload<T> | null >>

    /**
     * Find the first Marque that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueFindFirstArgs} args - Arguments to find a Marque
     * @example
     * // Get one Marque
     * const marque = await prisma.marque.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarqueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarqueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Marque'> extends True ? CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>> : CheckSelect<T, Prisma__MarqueClient<Marque | null >, Prisma__MarqueClient<MarqueGetPayload<T> | null >>

    /**
     * Find zero or more Marques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marques
     * const marques = await prisma.marque.findMany()
     * 
     * // Get first 10 Marques
     * const marques = await prisma.marque.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marqueWithIdOnly = await prisma.marque.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarqueFindManyArgs>(
      args?: SelectSubset<T, MarqueFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Marque>>, PrismaPromise<Array<MarqueGetPayload<T>>>>

    /**
     * Create a Marque.
     * @param {MarqueCreateArgs} args - Arguments to create a Marque.
     * @example
     * // Create one Marque
     * const Marque = await prisma.marque.create({
     *   data: {
     *     // ... data to create a Marque
     *   }
     * })
     * 
    **/
    create<T extends MarqueCreateArgs>(
      args: SelectSubset<T, MarqueCreateArgs>
    ): CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>>

    /**
     * Create many Marques.
     *     @param {MarqueCreateManyArgs} args - Arguments to create many Marques.
     *     @example
     *     // Create many Marques
     *     const marque = await prisma.marque.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarqueCreateManyArgs>(
      args?: SelectSubset<T, MarqueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Marque.
     * @param {MarqueDeleteArgs} args - Arguments to delete one Marque.
     * @example
     * // Delete one Marque
     * const Marque = await prisma.marque.delete({
     *   where: {
     *     // ... filter to delete one Marque
     *   }
     * })
     * 
    **/
    delete<T extends MarqueDeleteArgs>(
      args: SelectSubset<T, MarqueDeleteArgs>
    ): CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>>

    /**
     * Update one Marque.
     * @param {MarqueUpdateArgs} args - Arguments to update one Marque.
     * @example
     * // Update one Marque
     * const marque = await prisma.marque.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarqueUpdateArgs>(
      args: SelectSubset<T, MarqueUpdateArgs>
    ): CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>>

    /**
     * Delete zero or more Marques.
     * @param {MarqueDeleteManyArgs} args - Arguments to filter Marques to delete.
     * @example
     * // Delete a few Marques
     * const { count } = await prisma.marque.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarqueDeleteManyArgs>(
      args?: SelectSubset<T, MarqueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marques
     * const marque = await prisma.marque.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarqueUpdateManyArgs>(
      args: SelectSubset<T, MarqueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Marque.
     * @param {MarqueUpsertArgs} args - Arguments to update or create a Marque.
     * @example
     * // Update or create a Marque
     * const marque = await prisma.marque.upsert({
     *   create: {
     *     // ... data to create a Marque
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marque we want to update
     *   }
     * })
    **/
    upsert<T extends MarqueUpsertArgs>(
      args: SelectSubset<T, MarqueUpsertArgs>
    ): CheckSelect<T, Prisma__MarqueClient<Marque>, Prisma__MarqueClient<MarqueGetPayload<T>>>

    /**
     * Count the number of Marques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueCountArgs} args - Arguments to filter Marques to count.
     * @example
     * // Count the number of Marques
     * const count = await prisma.marque.count({
     *   where: {
     *     // ... the filter for the Marques we want to count
     *   }
     * })
    **/
    count<T extends MarqueCountArgs>(
      args?: Subset<T, MarqueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarqueAggregateArgs>(args: Subset<T, MarqueAggregateArgs>): PrismaPromise<GetMarqueAggregateType<T>>

    /**
     * Group by Marque.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarqueGroupByArgs['orderBy'] }
        : { orderBy?: MarqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarqueGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marque.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarqueClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    image<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    category<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Marque findUnique
   */
  export type MarqueFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * Throw an Error if a Marque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Marque to fetch.
     * 
    **/
    where: MarqueWhereUniqueInput
  }


  /**
   * Marque findFirst
   */
  export type MarqueFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * Throw an Error if a Marque can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Marque to fetch.
     * 
    **/
    where?: MarqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marques to fetch.
     * 
    **/
    orderBy?: Enumerable<MarqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marques.
     * 
    **/
    cursor?: MarqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marques.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marques.
     * 
    **/
    distinct?: Enumerable<MarqueScalarFieldEnum>
  }


  /**
   * Marque findMany
   */
  export type MarqueFindManyArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * Filter, which Marques to fetch.
     * 
    **/
    where?: MarqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marques to fetch.
     * 
    **/
    orderBy?: Enumerable<MarqueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marques.
     * 
    **/
    cursor?: MarqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marques from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marques.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MarqueScalarFieldEnum>
  }


  /**
   * Marque create
   */
  export type MarqueCreateArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * The data needed to create a Marque.
     * 
    **/
    data: XOR<MarqueCreateInput, MarqueUncheckedCreateInput>
  }


  /**
   * Marque createMany
   */
  export type MarqueCreateManyArgs = {
    data: Enumerable<MarqueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Marque update
   */
  export type MarqueUpdateArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * The data needed to update a Marque.
     * 
    **/
    data: XOR<MarqueUpdateInput, MarqueUncheckedUpdateInput>
    /**
     * Choose, which Marque to update.
     * 
    **/
    where: MarqueWhereUniqueInput
  }


  /**
   * Marque updateMany
   */
  export type MarqueUpdateManyArgs = {
    data: XOR<MarqueUpdateManyMutationInput, MarqueUncheckedUpdateManyInput>
    where?: MarqueWhereInput
  }


  /**
   * Marque upsert
   */
  export type MarqueUpsertArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * The filter to search for the Marque to update in case it exists.
     * 
    **/
    where: MarqueWhereUniqueInput
    /**
     * In case the Marque found by the `where` argument doesn't exist, create a new Marque with this data.
     * 
    **/
    create: XOR<MarqueCreateInput, MarqueUncheckedCreateInput>
    /**
     * In case the Marque was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MarqueUpdateInput, MarqueUncheckedUpdateInput>
  }


  /**
   * Marque delete
   */
  export type MarqueDeleteArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
    /**
     * Filter which Marque to delete.
     * 
    **/
    where: MarqueWhereUniqueInput
  }


  /**
   * Marque deleteMany
   */
  export type MarqueDeleteManyArgs = {
    where?: MarqueWhereInput
  }


  /**
   * Marque without action
   */
  export type MarqueArgs = {
    /**
     * Select specific fields to fetch from the Marque
     * 
    **/
    select?: MarqueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MarqueInclude | null
  }



  /**
   * Model Discount
   */


  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    discount: number | null
    inCartProductMin: number | null
    inCartProductMax: number | null
    commandAmountMin: number | null
    commandAmountMax: number | null
  }

  export type DiscountSumAggregateOutputType = {
    discount: number | null
    inCartProductMin: number | null
    inCartProductMax: number | null
    commandAmountMin: number | null
    commandAmountMax: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    name: string | null
    bannerImageId: string | null
    discountType: string | null
    discountNature: string | null
    discountCode: string | null
    discount: number | null
    startAt: Date | null
    endAt: Date | null
    inCartProductMin: number | null
    inCartProductMax: number | null
    commandAmountMin: number | null
    commandAmountMax: number | null
    description: string | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bannerImageId: string | null
    discountType: string | null
    discountNature: string | null
    discountCode: string | null
    discount: number | null
    startAt: Date | null
    endAt: Date | null
    inCartProductMin: number | null
    inCartProductMax: number | null
    commandAmountMin: number | null
    commandAmountMax: number | null
    description: string | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    name: number
    bannerImageId: number
    discountType: number
    discountNature: number
    discountCode: number
    discount: number
    startAt: number
    endAt: number
    inCartProductMin: number
    inCartProductMax: number
    commandAmountMin: number
    commandAmountMax: number
    description: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    discount?: true
    inCartProductMin?: true
    inCartProductMax?: true
    commandAmountMin?: true
    commandAmountMax?: true
  }

  export type DiscountSumAggregateInputType = {
    discount?: true
    inCartProductMin?: true
    inCartProductMax?: true
    commandAmountMin?: true
    commandAmountMax?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    discountType?: true
    discountNature?: true
    discountCode?: true
    discount?: true
    startAt?: true
    endAt?: true
    inCartProductMin?: true
    inCartProductMax?: true
    commandAmountMin?: true
    commandAmountMax?: true
    description?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    discountType?: true
    discountNature?: true
    discountCode?: true
    discount?: true
    startAt?: true
    endAt?: true
    inCartProductMin?: true
    inCartProductMax?: true
    commandAmountMin?: true
    commandAmountMax?: true
    description?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    discountType?: true
    discountNature?: true
    discountCode?: true
    discount?: true
    startAt?: true
    endAt?: true
    inCartProductMin?: true
    inCartProductMax?: true
    commandAmountMin?: true
    commandAmountMax?: true
    description?: true
    _all?: true
  }

  export type DiscountAggregateArgs = {
    /**
     * Filter which Discount to aggregate.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs = {
    where?: DiscountWhereInput
    orderBy?: Enumerable<DiscountOrderByWithAggregationInput>
    by: Array<DiscountScalarFieldEnum>
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }


  export type DiscountGroupByOutputType = {
    id: string
    name: string
    bannerImageId: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date
    endAt: Date
    inCartProductMin: number | null
    inCartProductMax: number | null
    commandAmountMin: number | null
    commandAmountMax: number | null
    description: string | null
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Promise<
    Array<
      PickArray<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect = {
    id?: boolean
    name?: boolean
    bannerImageId?: boolean
    bannerImage?: boolean | MediaArgs
    discountType?: boolean
    discountNature?: boolean
    discountCode?: boolean
    discount?: boolean
    startAt?: boolean
    endAt?: boolean
    inCartProductMin?: boolean
    inCartProductMax?: boolean
    commandAmountMin?: boolean
    commandAmountMax?: boolean
    description?: boolean
    command?: boolean | CommandFindManyArgs
    pubs?: boolean | PubFindManyArgs
    product?: boolean | ProductFindManyArgs
    _count?: boolean | DiscountCountOutputTypeArgs
  }

  export type DiscountInclude = {
    bannerImage?: boolean | MediaArgs
    command?: boolean | CommandFindManyArgs
    pubs?: boolean | PubFindManyArgs
    product?: boolean | ProductFindManyArgs
    _count?: boolean | DiscountCountOutputTypeArgs
  }

  export type DiscountGetPayload<
    S extends boolean | null | undefined | DiscountArgs,
    U = keyof S
      > = S extends true
        ? Discount
    : S extends undefined
    ? never
    : S extends DiscountArgs | DiscountFindManyArgs
    ?'include' extends U
    ? Discount  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bannerImage'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'command'
        ? Array < CommandGetPayload<S['include'][P]>>  :
        P extends 'pubs'
        ? Array < PubGetPayload<S['include'][P]>>  :
        P extends 'product'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? DiscountCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Discount ?Discount [P]
  : 
          P extends 'bannerImage'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'command'
        ? Array < CommandGetPayload<S['select'][P]>>  :
        P extends 'pubs'
        ? Array < PubGetPayload<S['select'][P]>>  :
        P extends 'product'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? DiscountCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Discount
  : Discount


  type DiscountCountArgs = Merge<
    Omit<DiscountFindManyArgs, 'select' | 'include'> & {
      select?: DiscountCountAggregateInputType | true
    }
  >

  export interface DiscountDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Discount'> extends True ? CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>> : CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Discount'> extends True ? CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>> : CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscountFindManyArgs>(
      args?: SelectSubset<T, DiscountFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Discount>>, PrismaPromise<Array<DiscountGetPayload<T>>>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
    **/
    create<T extends DiscountCreateArgs>(
      args: SelectSubset<T, DiscountCreateArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Create many Discounts.
     *     @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     *     @example
     *     // Create many Discounts
     *     const discount = await prisma.discount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscountCreateManyArgs>(
      args?: SelectSubset<T, DiscountCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
    **/
    delete<T extends DiscountDeleteArgs>(
      args: SelectSubset<T, DiscountDeleteArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscountUpdateArgs>(
      args: SelectSubset<T, DiscountUpdateArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscountDeleteManyArgs>(
      args?: SelectSubset<T, DiscountDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscountUpdateManyArgs>(
      args: SelectSubset<T, DiscountUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
    **/
    upsert<T extends DiscountUpsertArgs>(
      args: SelectSubset<T, DiscountUpsertArgs>
    ): CheckSelect<T, Prisma__DiscountClient<Discount>, Prisma__DiscountClient<DiscountGetPayload<T>>>

    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscountClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bannerImage<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    command<T extends CommandFindManyArgs = {}>(args?: Subset<T, CommandFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Command>>, PrismaPromise<Array<CommandGetPayload<T>>>>;

    pubs<T extends PubFindManyArgs = {}>(args?: Subset<T, PubFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pub>>, PrismaPromise<Array<PubGetPayload<T>>>>;

    product<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Throw an Error if a Discount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discount to fetch.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Throw an Error if a Discount can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discount to fetch.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     * 
    **/
    distinct?: Enumerable<DiscountScalarFieldEnum>
  }


  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Filter, which Discounts to fetch.
     * 
    **/
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     * 
    **/
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscountScalarFieldEnum>
  }


  /**
   * Discount create
   */
  export type DiscountCreateArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The data needed to create a Discount.
     * 
    **/
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }


  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs = {
    data: Enumerable<DiscountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Discount update
   */
  export type DiscountUpdateArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The data needed to update a Discount.
     * 
    **/
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs = {
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    where?: DiscountWhereInput
  }


  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * The filter to search for the Discount to update in case it exists.
     * 
    **/
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     * 
    **/
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }


  /**
   * Discount delete
   */
  export type DiscountDeleteArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
    /**
     * Filter which Discount to delete.
     * 
    **/
    where: DiscountWhereUniqueInput
  }


  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs = {
    where?: DiscountWhereInput
  }


  /**
   * Discount without action
   */
  export type DiscountArgs = {
    /**
     * Select specific fields to fetch from the Discount
     * 
    **/
    select?: DiscountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DiscountInclude | null
  }



  /**
   * Model PriceRule
   */


  export type AggregatePriceRule = {
    _count: PriceRuleCountAggregateOutputType | null
    _avg: PriceRuleAvgAggregateOutputType | null
    _sum: PriceRuleSumAggregateOutputType | null
    _min: PriceRuleMinAggregateOutputType | null
    _max: PriceRuleMaxAggregateOutputType | null
  }

  export type PriceRuleAvgAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    amountPercent: number | null
  }

  export type PriceRuleSumAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    amountPercent: number | null
  }

  export type PriceRuleMinAggregateOutputType = {
    id: string | null
    minPrice: number | null
    maxPrice: number | null
    amountPercent: number | null
  }

  export type PriceRuleMaxAggregateOutputType = {
    id: string | null
    minPrice: number | null
    maxPrice: number | null
    amountPercent: number | null
  }

  export type PriceRuleCountAggregateOutputType = {
    id: number
    minPrice: number
    maxPrice: number
    amountPercent: number
    _all: number
  }


  export type PriceRuleAvgAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    amountPercent?: true
  }

  export type PriceRuleSumAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    amountPercent?: true
  }

  export type PriceRuleMinAggregateInputType = {
    id?: true
    minPrice?: true
    maxPrice?: true
    amountPercent?: true
  }

  export type PriceRuleMaxAggregateInputType = {
    id?: true
    minPrice?: true
    maxPrice?: true
    amountPercent?: true
  }

  export type PriceRuleCountAggregateInputType = {
    id?: true
    minPrice?: true
    maxPrice?: true
    amountPercent?: true
    _all?: true
  }

  export type PriceRuleAggregateArgs = {
    /**
     * Filter which PriceRule to aggregate.
     * 
    **/
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceRules
    **/
    _count?: true | PriceRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceRuleMaxAggregateInputType
  }

  export type GetPriceRuleAggregateType<T extends PriceRuleAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceRule[P]>
      : GetScalarType<T[P], AggregatePriceRule[P]>
  }




  export type PriceRuleGroupByArgs = {
    where?: PriceRuleWhereInput
    orderBy?: Enumerable<PriceRuleOrderByWithAggregationInput>
    by: Array<PriceRuleScalarFieldEnum>
    having?: PriceRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceRuleCountAggregateInputType | true
    _avg?: PriceRuleAvgAggregateInputType
    _sum?: PriceRuleSumAggregateInputType
    _min?: PriceRuleMinAggregateInputType
    _max?: PriceRuleMaxAggregateInputType
  }


  export type PriceRuleGroupByOutputType = {
    id: string
    minPrice: number
    maxPrice: number | null
    amountPercent: number
    _count: PriceRuleCountAggregateOutputType | null
    _avg: PriceRuleAvgAggregateOutputType | null
    _sum: PriceRuleSumAggregateOutputType | null
    _min: PriceRuleMinAggregateOutputType | null
    _max: PriceRuleMaxAggregateOutputType | null
  }

  type GetPriceRuleGroupByPayload<T extends PriceRuleGroupByArgs> = Promise<
    Array<
      PickArray<PriceRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceRuleGroupByOutputType[P]>
            : GetScalarType<T[P], PriceRuleGroupByOutputType[P]>
        }
      >
    >


  export type PriceRuleSelect = {
    id?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    amountPercent?: boolean
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    _count?: boolean | PriceRuleCountOutputTypeArgs
  }

  export type PriceRuleInclude = {
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    _count?: boolean | PriceRuleCountOutputTypeArgs
  }

  export type PriceRuleGetPayload<
    S extends boolean | null | undefined | PriceRuleArgs,
    U = keyof S
      > = S extends true
        ? PriceRule
    : S extends undefined
    ? never
    : S extends PriceRuleArgs | PriceRuleFindManyArgs
    ?'include' extends U
    ? PriceRule  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PriceRuleCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PriceRule ?PriceRule [P]
  : 
          P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PriceRuleCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : PriceRule
  : PriceRule


  type PriceRuleCountArgs = Merge<
    Omit<PriceRuleFindManyArgs, 'select' | 'include'> & {
      select?: PriceRuleCountAggregateInputType | true
    }
  >

  export interface PriceRuleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PriceRule that matches the filter.
     * @param {PriceRuleFindUniqueArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceRuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceRuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PriceRule'> extends True ? CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>> : CheckSelect<T, Prisma__PriceRuleClient<PriceRule | null >, Prisma__PriceRuleClient<PriceRuleGetPayload<T> | null >>

    /**
     * Find the first PriceRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleFindFirstArgs} args - Arguments to find a PriceRule
     * @example
     * // Get one PriceRule
     * const priceRule = await prisma.priceRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceRuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceRuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PriceRule'> extends True ? CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>> : CheckSelect<T, Prisma__PriceRuleClient<PriceRule | null >, Prisma__PriceRuleClient<PriceRuleGetPayload<T> | null >>

    /**
     * Find zero or more PriceRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceRules
     * const priceRules = await prisma.priceRule.findMany()
     * 
     * // Get first 10 PriceRules
     * const priceRules = await prisma.priceRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceRuleWithIdOnly = await prisma.priceRule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceRuleFindManyArgs>(
      args?: SelectSubset<T, PriceRuleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PriceRule>>, PrismaPromise<Array<PriceRuleGetPayload<T>>>>

    /**
     * Create a PriceRule.
     * @param {PriceRuleCreateArgs} args - Arguments to create a PriceRule.
     * @example
     * // Create one PriceRule
     * const PriceRule = await prisma.priceRule.create({
     *   data: {
     *     // ... data to create a PriceRule
     *   }
     * })
     * 
    **/
    create<T extends PriceRuleCreateArgs>(
      args: SelectSubset<T, PriceRuleCreateArgs>
    ): CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>>

    /**
     * Create many PriceRules.
     *     @param {PriceRuleCreateManyArgs} args - Arguments to create many PriceRules.
     *     @example
     *     // Create many PriceRules
     *     const priceRule = await prisma.priceRule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceRuleCreateManyArgs>(
      args?: SelectSubset<T, PriceRuleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PriceRule.
     * @param {PriceRuleDeleteArgs} args - Arguments to delete one PriceRule.
     * @example
     * // Delete one PriceRule
     * const PriceRule = await prisma.priceRule.delete({
     *   where: {
     *     // ... filter to delete one PriceRule
     *   }
     * })
     * 
    **/
    delete<T extends PriceRuleDeleteArgs>(
      args: SelectSubset<T, PriceRuleDeleteArgs>
    ): CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>>

    /**
     * Update one PriceRule.
     * @param {PriceRuleUpdateArgs} args - Arguments to update one PriceRule.
     * @example
     * // Update one PriceRule
     * const priceRule = await prisma.priceRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceRuleUpdateArgs>(
      args: SelectSubset<T, PriceRuleUpdateArgs>
    ): CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>>

    /**
     * Delete zero or more PriceRules.
     * @param {PriceRuleDeleteManyArgs} args - Arguments to filter PriceRules to delete.
     * @example
     * // Delete a few PriceRules
     * const { count } = await prisma.priceRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceRuleDeleteManyArgs>(
      args?: SelectSubset<T, PriceRuleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceRules
     * const priceRule = await prisma.priceRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceRuleUpdateManyArgs>(
      args: SelectSubset<T, PriceRuleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceRule.
     * @param {PriceRuleUpsertArgs} args - Arguments to update or create a PriceRule.
     * @example
     * // Update or create a PriceRule
     * const priceRule = await prisma.priceRule.upsert({
     *   create: {
     *     // ... data to create a PriceRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceRule we want to update
     *   }
     * })
    **/
    upsert<T extends PriceRuleUpsertArgs>(
      args: SelectSubset<T, PriceRuleUpsertArgs>
    ): CheckSelect<T, Prisma__PriceRuleClient<PriceRule>, Prisma__PriceRuleClient<PriceRuleGetPayload<T>>>

    /**
     * Count the number of PriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleCountArgs} args - Arguments to filter PriceRules to count.
     * @example
     * // Count the number of PriceRules
     * const count = await prisma.priceRule.count({
     *   where: {
     *     // ... the filter for the PriceRules we want to count
     *   }
     * })
    **/
    count<T extends PriceRuleCountArgs>(
      args?: Subset<T, PriceRuleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceRuleAggregateArgs>(args: Subset<T, PriceRuleAggregateArgs>): PrismaPromise<GetPriceRuleAggregateType<T>>

    /**
     * Group by PriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceRuleGroupByArgs['orderBy'] }
        : { orderBy?: PriceRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceRuleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceRuleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    commandUnitProducts<T extends CommandUnitProductFindManyArgs = {}>(args?: Subset<T, CommandUnitProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandUnitProduct>>, PrismaPromise<Array<CommandUnitProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PriceRule findUnique
   */
  export type PriceRuleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * Throw an Error if a PriceRule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PriceRule to fetch.
     * 
    **/
    where: PriceRuleWhereUniqueInput
  }


  /**
   * PriceRule findFirst
   */
  export type PriceRuleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * Throw an Error if a PriceRule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PriceRule to fetch.
     * 
    **/
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceRules.
     * 
    **/
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceRules.
     * 
    **/
    distinct?: Enumerable<PriceRuleScalarFieldEnum>
  }


  /**
   * PriceRule findMany
   */
  export type PriceRuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * Filter, which PriceRules to fetch.
     * 
    **/
    where?: PriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceRules to fetch.
     * 
    **/
    orderBy?: Enumerable<PriceRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceRules.
     * 
    **/
    cursor?: PriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceRules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PriceRuleScalarFieldEnum>
  }


  /**
   * PriceRule create
   */
  export type PriceRuleCreateArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * The data needed to create a PriceRule.
     * 
    **/
    data: XOR<PriceRuleCreateInput, PriceRuleUncheckedCreateInput>
  }


  /**
   * PriceRule createMany
   */
  export type PriceRuleCreateManyArgs = {
    data: Enumerable<PriceRuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PriceRule update
   */
  export type PriceRuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * The data needed to update a PriceRule.
     * 
    **/
    data: XOR<PriceRuleUpdateInput, PriceRuleUncheckedUpdateInput>
    /**
     * Choose, which PriceRule to update.
     * 
    **/
    where: PriceRuleWhereUniqueInput
  }


  /**
   * PriceRule updateMany
   */
  export type PriceRuleUpdateManyArgs = {
    data: XOR<PriceRuleUpdateManyMutationInput, PriceRuleUncheckedUpdateManyInput>
    where?: PriceRuleWhereInput
  }


  /**
   * PriceRule upsert
   */
  export type PriceRuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * The filter to search for the PriceRule to update in case it exists.
     * 
    **/
    where: PriceRuleWhereUniqueInput
    /**
     * In case the PriceRule found by the `where` argument doesn't exist, create a new PriceRule with this data.
     * 
    **/
    create: XOR<PriceRuleCreateInput, PriceRuleUncheckedCreateInput>
    /**
     * In case the PriceRule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PriceRuleUpdateInput, PriceRuleUncheckedUpdateInput>
  }


  /**
   * PriceRule delete
   */
  export type PriceRuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
    /**
     * Filter which PriceRule to delete.
     * 
    **/
    where: PriceRuleWhereUniqueInput
  }


  /**
   * PriceRule deleteMany
   */
  export type PriceRuleDeleteManyArgs = {
    where?: PriceRuleWhereInput
  }


  /**
   * PriceRule without action
   */
  export type PriceRuleArgs = {
    /**
     * Select specific fields to fetch from the PriceRule
     * 
    **/
    select?: PriceRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PriceRuleInclude | null
  }



  /**
   * Model Pub
   */


  export type AggregatePub = {
    _count: PubCountAggregateOutputType | null
    _min: PubMinAggregateOutputType | null
    _max: PubMaxAggregateOutputType | null
  }

  export type PubMinAggregateOutputType = {
    id: string | null
    name: string | null
    bannerImageId: string | null
    link: string | null
    description: string | null
    startAt: Date | null
    endAt: Date | null
    forDiscountId: string | null
  }

  export type PubMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bannerImageId: string | null
    link: string | null
    description: string | null
    startAt: Date | null
    endAt: Date | null
    forDiscountId: string | null
  }

  export type PubCountAggregateOutputType = {
    id: number
    name: number
    bannerImageId: number
    link: number
    description: number
    startAt: number
    endAt: number
    forDiscountId: number
    _all: number
  }


  export type PubMinAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    link?: true
    description?: true
    startAt?: true
    endAt?: true
    forDiscountId?: true
  }

  export type PubMaxAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    link?: true
    description?: true
    startAt?: true
    endAt?: true
    forDiscountId?: true
  }

  export type PubCountAggregateInputType = {
    id?: true
    name?: true
    bannerImageId?: true
    link?: true
    description?: true
    startAt?: true
    endAt?: true
    forDiscountId?: true
    _all?: true
  }

  export type PubAggregateArgs = {
    /**
     * Filter which Pub to aggregate.
     * 
    **/
    where?: PubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pubs
    **/
    _count?: true | PubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PubMaxAggregateInputType
  }

  export type GetPubAggregateType<T extends PubAggregateArgs> = {
        [P in keyof T & keyof AggregatePub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePub[P]>
      : GetScalarType<T[P], AggregatePub[P]>
  }




  export type PubGroupByArgs = {
    where?: PubWhereInput
    orderBy?: Enumerable<PubOrderByWithAggregationInput>
    by: Array<PubScalarFieldEnum>
    having?: PubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PubCountAggregateInputType | true
    _min?: PubMinAggregateInputType
    _max?: PubMaxAggregateInputType
  }


  export type PubGroupByOutputType = {
    id: string
    name: string
    bannerImageId: string | null
    link: string | null
    description: string | null
    startAt: Date
    endAt: Date
    forDiscountId: string | null
    _count: PubCountAggregateOutputType | null
    _min: PubMinAggregateOutputType | null
    _max: PubMaxAggregateOutputType | null
  }

  type GetPubGroupByPayload<T extends PubGroupByArgs> = Promise<
    Array<
      PickArray<PubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PubGroupByOutputType[P]>
            : GetScalarType<T[P], PubGroupByOutputType[P]>
        }
      >
    >


  export type PubSelect = {
    id?: boolean
    name?: boolean
    bannerImageId?: boolean
    bannerImage?: boolean | MediaArgs
    link?: boolean
    description?: boolean
    startAt?: boolean
    endAt?: boolean
    forDiscountId?: boolean
    forDiscount?: boolean | DiscountArgs
  }

  export type PubInclude = {
    bannerImage?: boolean | MediaArgs
    forDiscount?: boolean | DiscountArgs
  }

  export type PubGetPayload<
    S extends boolean | null | undefined | PubArgs,
    U = keyof S
      > = S extends true
        ? Pub
    : S extends undefined
    ? never
    : S extends PubArgs | PubFindManyArgs
    ?'include' extends U
    ? Pub  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bannerImage'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'forDiscount'
        ? DiscountGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Pub ?Pub [P]
  : 
          P extends 'bannerImage'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'forDiscount'
        ? DiscountGetPayload<S['select'][P]> | null : never
  } 
    : Pub
  : Pub


  type PubCountArgs = Merge<
    Omit<PubFindManyArgs, 'select' | 'include'> & {
      select?: PubCountAggregateInputType | true
    }
  >

  export interface PubDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Pub that matches the filter.
     * @param {PubFindUniqueArgs} args - Arguments to find a Pub
     * @example
     * // Get one Pub
     * const pub = await prisma.pub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PubFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PubFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pub'> extends True ? CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>> : CheckSelect<T, Prisma__PubClient<Pub | null >, Prisma__PubClient<PubGetPayload<T> | null >>

    /**
     * Find the first Pub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubFindFirstArgs} args - Arguments to find a Pub
     * @example
     * // Get one Pub
     * const pub = await prisma.pub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PubFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PubFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pub'> extends True ? CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>> : CheckSelect<T, Prisma__PubClient<Pub | null >, Prisma__PubClient<PubGetPayload<T> | null >>

    /**
     * Find zero or more Pubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pubs
     * const pubs = await prisma.pub.findMany()
     * 
     * // Get first 10 Pubs
     * const pubs = await prisma.pub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pubWithIdOnly = await prisma.pub.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PubFindManyArgs>(
      args?: SelectSubset<T, PubFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pub>>, PrismaPromise<Array<PubGetPayload<T>>>>

    /**
     * Create a Pub.
     * @param {PubCreateArgs} args - Arguments to create a Pub.
     * @example
     * // Create one Pub
     * const Pub = await prisma.pub.create({
     *   data: {
     *     // ... data to create a Pub
     *   }
     * })
     * 
    **/
    create<T extends PubCreateArgs>(
      args: SelectSubset<T, PubCreateArgs>
    ): CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>>

    /**
     * Create many Pubs.
     *     @param {PubCreateManyArgs} args - Arguments to create many Pubs.
     *     @example
     *     // Create many Pubs
     *     const pub = await prisma.pub.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PubCreateManyArgs>(
      args?: SelectSubset<T, PubCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pub.
     * @param {PubDeleteArgs} args - Arguments to delete one Pub.
     * @example
     * // Delete one Pub
     * const Pub = await prisma.pub.delete({
     *   where: {
     *     // ... filter to delete one Pub
     *   }
     * })
     * 
    **/
    delete<T extends PubDeleteArgs>(
      args: SelectSubset<T, PubDeleteArgs>
    ): CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>>

    /**
     * Update one Pub.
     * @param {PubUpdateArgs} args - Arguments to update one Pub.
     * @example
     * // Update one Pub
     * const pub = await prisma.pub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PubUpdateArgs>(
      args: SelectSubset<T, PubUpdateArgs>
    ): CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>>

    /**
     * Delete zero or more Pubs.
     * @param {PubDeleteManyArgs} args - Arguments to filter Pubs to delete.
     * @example
     * // Delete a few Pubs
     * const { count } = await prisma.pub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PubDeleteManyArgs>(
      args?: SelectSubset<T, PubDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pubs
     * const pub = await prisma.pub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PubUpdateManyArgs>(
      args: SelectSubset<T, PubUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pub.
     * @param {PubUpsertArgs} args - Arguments to update or create a Pub.
     * @example
     * // Update or create a Pub
     * const pub = await prisma.pub.upsert({
     *   create: {
     *     // ... data to create a Pub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pub we want to update
     *   }
     * })
    **/
    upsert<T extends PubUpsertArgs>(
      args: SelectSubset<T, PubUpsertArgs>
    ): CheckSelect<T, Prisma__PubClient<Pub>, Prisma__PubClient<PubGetPayload<T>>>

    /**
     * Count the number of Pubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubCountArgs} args - Arguments to filter Pubs to count.
     * @example
     * // Count the number of Pubs
     * const count = await prisma.pub.count({
     *   where: {
     *     // ... the filter for the Pubs we want to count
     *   }
     * })
    **/
    count<T extends PubCountArgs>(
      args?: Subset<T, PubCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PubAggregateArgs>(args: Subset<T, PubAggregateArgs>): PrismaPromise<GetPubAggregateType<T>>

    /**
     * Group by Pub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PubGroupByArgs['orderBy'] }
        : { orderBy?: PubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPubGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PubClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bannerImage<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    forDiscount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Pub findUnique
   */
  export type PubFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * Throw an Error if a Pub can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Pub to fetch.
     * 
    **/
    where: PubWhereUniqueInput
  }


  /**
   * Pub findFirst
   */
  export type PubFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * Throw an Error if a Pub can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Pub to fetch.
     * 
    **/
    where?: PubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pubs.
     * 
    **/
    cursor?: PubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pubs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pubs.
     * 
    **/
    distinct?: Enumerable<PubScalarFieldEnum>
  }


  /**
   * Pub findMany
   */
  export type PubFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * Filter, which Pubs to fetch.
     * 
    **/
    where?: PubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pubs to fetch.
     * 
    **/
    orderBy?: Enumerable<PubOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pubs.
     * 
    **/
    cursor?: PubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pubs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pubs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PubScalarFieldEnum>
  }


  /**
   * Pub create
   */
  export type PubCreateArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * The data needed to create a Pub.
     * 
    **/
    data: XOR<PubCreateInput, PubUncheckedCreateInput>
  }


  /**
   * Pub createMany
   */
  export type PubCreateManyArgs = {
    data: Enumerable<PubCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pub update
   */
  export type PubUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * The data needed to update a Pub.
     * 
    **/
    data: XOR<PubUpdateInput, PubUncheckedUpdateInput>
    /**
     * Choose, which Pub to update.
     * 
    **/
    where: PubWhereUniqueInput
  }


  /**
   * Pub updateMany
   */
  export type PubUpdateManyArgs = {
    data: XOR<PubUpdateManyMutationInput, PubUncheckedUpdateManyInput>
    where?: PubWhereInput
  }


  /**
   * Pub upsert
   */
  export type PubUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * The filter to search for the Pub to update in case it exists.
     * 
    **/
    where: PubWhereUniqueInput
    /**
     * In case the Pub found by the `where` argument doesn't exist, create a new Pub with this data.
     * 
    **/
    create: XOR<PubCreateInput, PubUncheckedCreateInput>
    /**
     * In case the Pub was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PubUpdateInput, PubUncheckedUpdateInput>
  }


  /**
   * Pub delete
   */
  export type PubDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
    /**
     * Filter which Pub to delete.
     * 
    **/
    where: PubWhereUniqueInput
  }


  /**
   * Pub deleteMany
   */
  export type PubDeleteManyArgs = {
    where?: PubWhereInput
  }


  /**
   * Pub without action
   */
  export type PubArgs = {
    /**
     * Select specific fields to fetch from the Pub
     * 
    **/
    select?: PubSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PubInclude | null
  }



  /**
   * Model ShippingZone
   */


  export type AggregateShippingZone = {
    _count: ShippingZoneCountAggregateOutputType | null
    _avg: ShippingZoneAvgAggregateOutputType | null
    _sum: ShippingZoneSumAggregateOutputType | null
    _min: ShippingZoneMinAggregateOutputType | null
    _max: ShippingZoneMaxAggregateOutputType | null
  }

  export type ShippingZoneAvgAggregateOutputType = {
    baseShippingPrice: number | null
  }

  export type ShippingZoneSumAggregateOutputType = {
    baseShippingPrice: number | null
  }

  export type ShippingZoneMinAggregateOutputType = {
    id: string | null
    townName: string | null
    townCode: string | null
    baseShippingPrice: number | null
  }

  export type ShippingZoneMaxAggregateOutputType = {
    id: string | null
    townName: string | null
    townCode: string | null
    baseShippingPrice: number | null
  }

  export type ShippingZoneCountAggregateOutputType = {
    id: number
    townName: number
    townCode: number
    baseShippingPrice: number
    _all: number
  }


  export type ShippingZoneAvgAggregateInputType = {
    baseShippingPrice?: true
  }

  export type ShippingZoneSumAggregateInputType = {
    baseShippingPrice?: true
  }

  export type ShippingZoneMinAggregateInputType = {
    id?: true
    townName?: true
    townCode?: true
    baseShippingPrice?: true
  }

  export type ShippingZoneMaxAggregateInputType = {
    id?: true
    townName?: true
    townCode?: true
    baseShippingPrice?: true
  }

  export type ShippingZoneCountAggregateInputType = {
    id?: true
    townName?: true
    townCode?: true
    baseShippingPrice?: true
    _all?: true
  }

  export type ShippingZoneAggregateArgs = {
    /**
     * Filter which ShippingZone to aggregate.
     * 
    **/
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingZoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingZones
    **/
    _count?: true | ShippingZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingZoneMaxAggregateInputType
  }

  export type GetShippingZoneAggregateType<T extends ShippingZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingZone[P]>
      : GetScalarType<T[P], AggregateShippingZone[P]>
  }




  export type ShippingZoneGroupByArgs = {
    where?: ShippingZoneWhereInput
    orderBy?: Enumerable<ShippingZoneOrderByWithAggregationInput>
    by: Array<ShippingZoneScalarFieldEnum>
    having?: ShippingZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingZoneCountAggregateInputType | true
    _avg?: ShippingZoneAvgAggregateInputType
    _sum?: ShippingZoneSumAggregateInputType
    _min?: ShippingZoneMinAggregateInputType
    _max?: ShippingZoneMaxAggregateInputType
  }


  export type ShippingZoneGroupByOutputType = {
    id: string
    townName: string
    townCode: string
    baseShippingPrice: number
    _count: ShippingZoneCountAggregateOutputType | null
    _avg: ShippingZoneAvgAggregateOutputType | null
    _sum: ShippingZoneSumAggregateOutputType | null
    _min: ShippingZoneMinAggregateOutputType | null
    _max: ShippingZoneMaxAggregateOutputType | null
  }

  type GetShippingZoneGroupByPayload<T extends ShippingZoneGroupByArgs> = Promise<
    Array<
      PickArray<ShippingZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingZoneGroupByOutputType[P]>
        }
      >
    >


  export type ShippingZoneSelect = {
    id?: boolean
    townName?: boolean
    townCode?: boolean
    baseShippingPrice?: boolean
    userShippingAdress?: boolean | UserShippingAdressFindManyArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ShippingZoneCountOutputTypeArgs
  }

  export type ShippingZoneInclude = {
    userShippingAdress?: boolean | UserShippingAdressFindManyArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ShippingZoneCountOutputTypeArgs
  }

  export type ShippingZoneGetPayload<
    S extends boolean | null | undefined | ShippingZoneArgs,
    U = keyof S
      > = S extends true
        ? ShippingZone
    : S extends undefined
    ? never
    : S extends ShippingZoneArgs | ShippingZoneFindManyArgs
    ?'include' extends U
    ? ShippingZone  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'userShippingAdress'
        ? Array < UserShippingAdressGetPayload<S['include'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ShippingZoneCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ShippingZone ?ShippingZone [P]
  : 
          P extends 'userShippingAdress'
        ? Array < UserShippingAdressGetPayload<S['select'][P]>>  :
        P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ShippingZoneCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ShippingZone
  : ShippingZone


  type ShippingZoneCountArgs = Merge<
    Omit<ShippingZoneFindManyArgs, 'select' | 'include'> & {
      select?: ShippingZoneCountAggregateInputType | true
    }
  >

  export interface ShippingZoneDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShippingZone that matches the filter.
     * @param {ShippingZoneFindUniqueArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingZoneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShippingZoneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShippingZone'> extends True ? CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>> : CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone | null >, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T> | null >>

    /**
     * Find the first ShippingZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneFindFirstArgs} args - Arguments to find a ShippingZone
     * @example
     * // Get one ShippingZone
     * const shippingZone = await prisma.shippingZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingZoneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShippingZoneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShippingZone'> extends True ? CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>> : CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone | null >, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T> | null >>

    /**
     * Find zero or more ShippingZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingZones
     * const shippingZones = await prisma.shippingZone.findMany()
     * 
     * // Get first 10 ShippingZones
     * const shippingZones = await prisma.shippingZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingZoneWithIdOnly = await prisma.shippingZone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingZoneFindManyArgs>(
      args?: SelectSubset<T, ShippingZoneFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShippingZone>>, PrismaPromise<Array<ShippingZoneGetPayload<T>>>>

    /**
     * Create a ShippingZone.
     * @param {ShippingZoneCreateArgs} args - Arguments to create a ShippingZone.
     * @example
     * // Create one ShippingZone
     * const ShippingZone = await prisma.shippingZone.create({
     *   data: {
     *     // ... data to create a ShippingZone
     *   }
     * })
     * 
    **/
    create<T extends ShippingZoneCreateArgs>(
      args: SelectSubset<T, ShippingZoneCreateArgs>
    ): CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>>

    /**
     * Create many ShippingZones.
     *     @param {ShippingZoneCreateManyArgs} args - Arguments to create many ShippingZones.
     *     @example
     *     // Create many ShippingZones
     *     const shippingZone = await prisma.shippingZone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShippingZoneCreateManyArgs>(
      args?: SelectSubset<T, ShippingZoneCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShippingZone.
     * @param {ShippingZoneDeleteArgs} args - Arguments to delete one ShippingZone.
     * @example
     * // Delete one ShippingZone
     * const ShippingZone = await prisma.shippingZone.delete({
     *   where: {
     *     // ... filter to delete one ShippingZone
     *   }
     * })
     * 
    **/
    delete<T extends ShippingZoneDeleteArgs>(
      args: SelectSubset<T, ShippingZoneDeleteArgs>
    ): CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>>

    /**
     * Update one ShippingZone.
     * @param {ShippingZoneUpdateArgs} args - Arguments to update one ShippingZone.
     * @example
     * // Update one ShippingZone
     * const shippingZone = await prisma.shippingZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingZoneUpdateArgs>(
      args: SelectSubset<T, ShippingZoneUpdateArgs>
    ): CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>>

    /**
     * Delete zero or more ShippingZones.
     * @param {ShippingZoneDeleteManyArgs} args - Arguments to filter ShippingZones to delete.
     * @example
     * // Delete a few ShippingZones
     * const { count } = await prisma.shippingZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingZoneDeleteManyArgs>(
      args?: SelectSubset<T, ShippingZoneDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingZones
     * const shippingZone = await prisma.shippingZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingZoneUpdateManyArgs>(
      args: SelectSubset<T, ShippingZoneUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingZone.
     * @param {ShippingZoneUpsertArgs} args - Arguments to update or create a ShippingZone.
     * @example
     * // Update or create a ShippingZone
     * const shippingZone = await prisma.shippingZone.upsert({
     *   create: {
     *     // ... data to create a ShippingZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingZone we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingZoneUpsertArgs>(
      args: SelectSubset<T, ShippingZoneUpsertArgs>
    ): CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone>, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T>>>

    /**
     * Count the number of ShippingZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneCountArgs} args - Arguments to filter ShippingZones to count.
     * @example
     * // Count the number of ShippingZones
     * const count = await prisma.shippingZone.count({
     *   where: {
     *     // ... the filter for the ShippingZones we want to count
     *   }
     * })
    **/
    count<T extends ShippingZoneCountArgs>(
      args?: Subset<T, ShippingZoneCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingZoneAggregateArgs>(args: Subset<T, ShippingZoneAggregateArgs>): PrismaPromise<GetShippingZoneAggregateType<T>>

    /**
     * Group by ShippingZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingZoneGroupByArgs['orderBy'] }
        : { orderBy?: ShippingZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingZoneGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShippingZoneClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    userShippingAdress<T extends UserShippingAdressFindManyArgs = {}>(args?: Subset<T, UserShippingAdressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserShippingAdress>>, PrismaPromise<Array<UserShippingAdressGetPayload<T>>>>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShippingZone findUnique
   */
  export type ShippingZoneFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * Throw an Error if a ShippingZone can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShippingZone to fetch.
     * 
    **/
    where: ShippingZoneWhereUniqueInput
  }


  /**
   * ShippingZone findFirst
   */
  export type ShippingZoneFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * Throw an Error if a ShippingZone can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShippingZone to fetch.
     * 
    **/
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingZoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingZones.
     * 
    **/
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingZones.
     * 
    **/
    distinct?: Enumerable<ShippingZoneScalarFieldEnum>
  }


  /**
   * ShippingZone findMany
   */
  export type ShippingZoneFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * Filter, which ShippingZones to fetch.
     * 
    **/
    where?: ShippingZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingZones to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingZoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingZones.
     * 
    **/
    cursor?: ShippingZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingZones from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingZones.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShippingZoneScalarFieldEnum>
  }


  /**
   * ShippingZone create
   */
  export type ShippingZoneCreateArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * The data needed to create a ShippingZone.
     * 
    **/
    data: XOR<ShippingZoneCreateInput, ShippingZoneUncheckedCreateInput>
  }


  /**
   * ShippingZone createMany
   */
  export type ShippingZoneCreateManyArgs = {
    data: Enumerable<ShippingZoneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShippingZone update
   */
  export type ShippingZoneUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * The data needed to update a ShippingZone.
     * 
    **/
    data: XOR<ShippingZoneUpdateInput, ShippingZoneUncheckedUpdateInput>
    /**
     * Choose, which ShippingZone to update.
     * 
    **/
    where: ShippingZoneWhereUniqueInput
  }


  /**
   * ShippingZone updateMany
   */
  export type ShippingZoneUpdateManyArgs = {
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyInput>
    where?: ShippingZoneWhereInput
  }


  /**
   * ShippingZone upsert
   */
  export type ShippingZoneUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * The filter to search for the ShippingZone to update in case it exists.
     * 
    **/
    where: ShippingZoneWhereUniqueInput
    /**
     * In case the ShippingZone found by the `where` argument doesn't exist, create a new ShippingZone with this data.
     * 
    **/
    create: XOR<ShippingZoneCreateInput, ShippingZoneUncheckedCreateInput>
    /**
     * In case the ShippingZone was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShippingZoneUpdateInput, ShippingZoneUncheckedUpdateInput>
  }


  /**
   * ShippingZone delete
   */
  export type ShippingZoneDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
    /**
     * Filter which ShippingZone to delete.
     * 
    **/
    where: ShippingZoneWhereUniqueInput
  }


  /**
   * ShippingZone deleteMany
   */
  export type ShippingZoneDeleteManyArgs = {
    where?: ShippingZoneWhereInput
  }


  /**
   * ShippingZone without action
   */
  export type ShippingZoneArgs = {
    /**
     * Select specific fields to fetch from the ShippingZone
     * 
    **/
    select?: ShippingZoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShippingZoneInclude | null
  }



  /**
   * Model ShippingRule
   */


  export type AggregateShippingRule = {
    _count: ShippingRuleCountAggregateOutputType | null
    _min: ShippingRuleMinAggregateOutputType | null
    _max: ShippingRuleMaxAggregateOutputType | null
  }

  export type ShippingRuleMinAggregateOutputType = {
    id: string | null
    ruleName: string | null
    description: string | null
  }

  export type ShippingRuleMaxAggregateOutputType = {
    id: string | null
    ruleName: string | null
    description: string | null
  }

  export type ShippingRuleCountAggregateOutputType = {
    id: number
    ruleName: number
    rule: number
    description: number
    _all: number
  }


  export type ShippingRuleMinAggregateInputType = {
    id?: true
    ruleName?: true
    description?: true
  }

  export type ShippingRuleMaxAggregateInputType = {
    id?: true
    ruleName?: true
    description?: true
  }

  export type ShippingRuleCountAggregateInputType = {
    id?: true
    ruleName?: true
    rule?: true
    description?: true
    _all?: true
  }

  export type ShippingRuleAggregateArgs = {
    /**
     * Filter which ShippingRule to aggregate.
     * 
    **/
    where?: ShippingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingRules to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShippingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingRules
    **/
    _count?: true | ShippingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingRuleMaxAggregateInputType
  }

  export type GetShippingRuleAggregateType<T extends ShippingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingRule[P]>
      : GetScalarType<T[P], AggregateShippingRule[P]>
  }




  export type ShippingRuleGroupByArgs = {
    where?: ShippingRuleWhereInput
    orderBy?: Enumerable<ShippingRuleOrderByWithAggregationInput>
    by: Array<ShippingRuleScalarFieldEnum>
    having?: ShippingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingRuleCountAggregateInputType | true
    _min?: ShippingRuleMinAggregateInputType
    _max?: ShippingRuleMaxAggregateInputType
  }


  export type ShippingRuleGroupByOutputType = {
    id: string
    ruleName: string
    rule: JsonValue
    description: string
    _count: ShippingRuleCountAggregateOutputType | null
    _min: ShippingRuleMinAggregateOutputType | null
    _max: ShippingRuleMaxAggregateOutputType | null
  }

  type GetShippingRuleGroupByPayload<T extends ShippingRuleGroupByArgs> = Promise<
    Array<
      PickArray<ShippingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingRuleGroupByOutputType[P]>
        }
      >
    >


  export type ShippingRuleSelect = {
    id?: boolean
    ruleName?: boolean
    rule?: boolean
    description?: boolean
  }

  export type ShippingRuleGetPayload<
    S extends boolean | null | undefined | ShippingRuleArgs,
    U = keyof S
      > = S extends true
        ? ShippingRule
    : S extends undefined
    ? never
    : S extends ShippingRuleArgs | ShippingRuleFindManyArgs
    ?'include' extends U
    ? ShippingRule 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ShippingRule ?ShippingRule [P]
  : 
     never
  } 
    : ShippingRule
  : ShippingRule


  type ShippingRuleCountArgs = Merge<
    Omit<ShippingRuleFindManyArgs, 'select' | 'include'> & {
      select?: ShippingRuleCountAggregateInputType | true
    }
  >

  export interface ShippingRuleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShippingRule that matches the filter.
     * @param {ShippingRuleFindUniqueArgs} args - Arguments to find a ShippingRule
     * @example
     * // Get one ShippingRule
     * const shippingRule = await prisma.shippingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShippingRuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShippingRuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShippingRule'> extends True ? CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>> : CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule | null >, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T> | null >>

    /**
     * Find the first ShippingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleFindFirstArgs} args - Arguments to find a ShippingRule
     * @example
     * // Get one ShippingRule
     * const shippingRule = await prisma.shippingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShippingRuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShippingRuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShippingRule'> extends True ? CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>> : CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule | null >, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T> | null >>

    /**
     * Find zero or more ShippingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingRules
     * const shippingRules = await prisma.shippingRule.findMany()
     * 
     * // Get first 10 ShippingRules
     * const shippingRules = await prisma.shippingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingRuleWithIdOnly = await prisma.shippingRule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShippingRuleFindManyArgs>(
      args?: SelectSubset<T, ShippingRuleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShippingRule>>, PrismaPromise<Array<ShippingRuleGetPayload<T>>>>

    /**
     * Create a ShippingRule.
     * @param {ShippingRuleCreateArgs} args - Arguments to create a ShippingRule.
     * @example
     * // Create one ShippingRule
     * const ShippingRule = await prisma.shippingRule.create({
     *   data: {
     *     // ... data to create a ShippingRule
     *   }
     * })
     * 
    **/
    create<T extends ShippingRuleCreateArgs>(
      args: SelectSubset<T, ShippingRuleCreateArgs>
    ): CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>>

    /**
     * Create many ShippingRules.
     *     @param {ShippingRuleCreateManyArgs} args - Arguments to create many ShippingRules.
     *     @example
     *     // Create many ShippingRules
     *     const shippingRule = await prisma.shippingRule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShippingRuleCreateManyArgs>(
      args?: SelectSubset<T, ShippingRuleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShippingRule.
     * @param {ShippingRuleDeleteArgs} args - Arguments to delete one ShippingRule.
     * @example
     * // Delete one ShippingRule
     * const ShippingRule = await prisma.shippingRule.delete({
     *   where: {
     *     // ... filter to delete one ShippingRule
     *   }
     * })
     * 
    **/
    delete<T extends ShippingRuleDeleteArgs>(
      args: SelectSubset<T, ShippingRuleDeleteArgs>
    ): CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>>

    /**
     * Update one ShippingRule.
     * @param {ShippingRuleUpdateArgs} args - Arguments to update one ShippingRule.
     * @example
     * // Update one ShippingRule
     * const shippingRule = await prisma.shippingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShippingRuleUpdateArgs>(
      args: SelectSubset<T, ShippingRuleUpdateArgs>
    ): CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>>

    /**
     * Delete zero or more ShippingRules.
     * @param {ShippingRuleDeleteManyArgs} args - Arguments to filter ShippingRules to delete.
     * @example
     * // Delete a few ShippingRules
     * const { count } = await prisma.shippingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShippingRuleDeleteManyArgs>(
      args?: SelectSubset<T, ShippingRuleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingRules
     * const shippingRule = await prisma.shippingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShippingRuleUpdateManyArgs>(
      args: SelectSubset<T, ShippingRuleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingRule.
     * @param {ShippingRuleUpsertArgs} args - Arguments to update or create a ShippingRule.
     * @example
     * // Update or create a ShippingRule
     * const shippingRule = await prisma.shippingRule.upsert({
     *   create: {
     *     // ... data to create a ShippingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingRule we want to update
     *   }
     * })
    **/
    upsert<T extends ShippingRuleUpsertArgs>(
      args: SelectSubset<T, ShippingRuleUpsertArgs>
    ): CheckSelect<T, Prisma__ShippingRuleClient<ShippingRule>, Prisma__ShippingRuleClient<ShippingRuleGetPayload<T>>>

    /**
     * Count the number of ShippingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleCountArgs} args - Arguments to filter ShippingRules to count.
     * @example
     * // Count the number of ShippingRules
     * const count = await prisma.shippingRule.count({
     *   where: {
     *     // ... the filter for the ShippingRules we want to count
     *   }
     * })
    **/
    count<T extends ShippingRuleCountArgs>(
      args?: Subset<T, ShippingRuleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingRuleAggregateArgs>(args: Subset<T, ShippingRuleAggregateArgs>): PrismaPromise<GetShippingRuleAggregateType<T>>

    /**
     * Group by ShippingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingRuleGroupByArgs['orderBy'] }
        : { orderBy?: ShippingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingRuleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShippingRuleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShippingRule findUnique
   */
  export type ShippingRuleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * Throw an Error if a ShippingRule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShippingRule to fetch.
     * 
    **/
    where: ShippingRuleWhereUniqueInput
  }


  /**
   * ShippingRule findFirst
   */
  export type ShippingRuleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * Throw an Error if a ShippingRule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShippingRule to fetch.
     * 
    **/
    where?: ShippingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingRules to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingRules.
     * 
    **/
    cursor?: ShippingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingRules.
     * 
    **/
    distinct?: Enumerable<ShippingRuleScalarFieldEnum>
  }


  /**
   * ShippingRule findMany
   */
  export type ShippingRuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * Filter, which ShippingRules to fetch.
     * 
    **/
    where?: ShippingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingRules to fetch.
     * 
    **/
    orderBy?: Enumerable<ShippingRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingRules.
     * 
    **/
    cursor?: ShippingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingRules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShippingRuleScalarFieldEnum>
  }


  /**
   * ShippingRule create
   */
  export type ShippingRuleCreateArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * The data needed to create a ShippingRule.
     * 
    **/
    data: XOR<ShippingRuleCreateInput, ShippingRuleUncheckedCreateInput>
  }


  /**
   * ShippingRule createMany
   */
  export type ShippingRuleCreateManyArgs = {
    data: Enumerable<ShippingRuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShippingRule update
   */
  export type ShippingRuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * The data needed to update a ShippingRule.
     * 
    **/
    data: XOR<ShippingRuleUpdateInput, ShippingRuleUncheckedUpdateInput>
    /**
     * Choose, which ShippingRule to update.
     * 
    **/
    where: ShippingRuleWhereUniqueInput
  }


  /**
   * ShippingRule updateMany
   */
  export type ShippingRuleUpdateManyArgs = {
    data: XOR<ShippingRuleUpdateManyMutationInput, ShippingRuleUncheckedUpdateManyInput>
    where?: ShippingRuleWhereInput
  }


  /**
   * ShippingRule upsert
   */
  export type ShippingRuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * The filter to search for the ShippingRule to update in case it exists.
     * 
    **/
    where: ShippingRuleWhereUniqueInput
    /**
     * In case the ShippingRule found by the `where` argument doesn't exist, create a new ShippingRule with this data.
     * 
    **/
    create: XOR<ShippingRuleCreateInput, ShippingRuleUncheckedCreateInput>
    /**
     * In case the ShippingRule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShippingRuleUpdateInput, ShippingRuleUncheckedUpdateInput>
  }


  /**
   * ShippingRule delete
   */
  export type ShippingRuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
    /**
     * Filter which ShippingRule to delete.
     * 
    **/
    where: ShippingRuleWhereUniqueInput
  }


  /**
   * ShippingRule deleteMany
   */
  export type ShippingRuleDeleteManyArgs = {
    where?: ShippingRuleWhereInput
  }


  /**
   * ShippingRule without action
   */
  export type ShippingRuleArgs = {
    /**
     * Select specific fields to fetch from the ShippingRule
     * 
    **/
    select?: ShippingRuleSelect | null
  }



  /**
   * Model GeneralMeta
   */


  export type AggregateGeneralMeta = {
    _count: GeneralMetaCountAggregateOutputType | null
    _min: GeneralMetaMinAggregateOutputType | null
    _max: GeneralMetaMaxAggregateOutputType | null
  }

  export type GeneralMetaMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
  }

  export type GeneralMetaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
  }

  export type GeneralMetaCountAggregateOutputType = {
    id: number
    name: number
    key: number
    value: number
    _all: number
  }


  export type GeneralMetaMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
  }

  export type GeneralMetaMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
  }

  export type GeneralMetaCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    value?: true
    _all?: true
  }

  export type GeneralMetaAggregateArgs = {
    /**
     * Filter which GeneralMeta to aggregate.
     * 
    **/
    where?: GeneralMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<GeneralMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GeneralMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneralMetas
    **/
    _count?: true | GeneralMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneralMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneralMetaMaxAggregateInputType
  }

  export type GetGeneralMetaAggregateType<T extends GeneralMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneralMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneralMeta[P]>
      : GetScalarType<T[P], AggregateGeneralMeta[P]>
  }




  export type GeneralMetaGroupByArgs = {
    where?: GeneralMetaWhereInput
    orderBy?: Enumerable<GeneralMetaOrderByWithAggregationInput>
    by: Array<GeneralMetaScalarFieldEnum>
    having?: GeneralMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneralMetaCountAggregateInputType | true
    _min?: GeneralMetaMinAggregateInputType
    _max?: GeneralMetaMaxAggregateInputType
  }


  export type GeneralMetaGroupByOutputType = {
    id: string
    name: string
    key: string
    value: JsonValue
    _count: GeneralMetaCountAggregateOutputType | null
    _min: GeneralMetaMinAggregateOutputType | null
    _max: GeneralMetaMaxAggregateOutputType | null
  }

  type GetGeneralMetaGroupByPayload<T extends GeneralMetaGroupByArgs> = Promise<
    Array<
      PickArray<GeneralMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneralMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneralMetaGroupByOutputType[P]>
            : GetScalarType<T[P], GeneralMetaGroupByOutputType[P]>
        }
      >
    >


  export type GeneralMetaSelect = {
    id?: boolean
    name?: boolean
    key?: boolean
    value?: boolean
  }

  export type GeneralMetaGetPayload<
    S extends boolean | null | undefined | GeneralMetaArgs,
    U = keyof S
      > = S extends true
        ? GeneralMeta
    : S extends undefined
    ? never
    : S extends GeneralMetaArgs | GeneralMetaFindManyArgs
    ?'include' extends U
    ? GeneralMeta 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GeneralMeta ?GeneralMeta [P]
  : 
     never
  } 
    : GeneralMeta
  : GeneralMeta


  type GeneralMetaCountArgs = Merge<
    Omit<GeneralMetaFindManyArgs, 'select' | 'include'> & {
      select?: GeneralMetaCountAggregateInputType | true
    }
  >

  export interface GeneralMetaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GeneralMeta that matches the filter.
     * @param {GeneralMetaFindUniqueArgs} args - Arguments to find a GeneralMeta
     * @example
     * // Get one GeneralMeta
     * const generalMeta = await prisma.generalMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GeneralMetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GeneralMetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GeneralMeta'> extends True ? CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>> : CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta | null >, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T> | null >>

    /**
     * Find the first GeneralMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaFindFirstArgs} args - Arguments to find a GeneralMeta
     * @example
     * // Get one GeneralMeta
     * const generalMeta = await prisma.generalMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GeneralMetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GeneralMetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GeneralMeta'> extends True ? CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>> : CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta | null >, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T> | null >>

    /**
     * Find zero or more GeneralMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneralMetas
     * const generalMetas = await prisma.generalMeta.findMany()
     * 
     * // Get first 10 GeneralMetas
     * const generalMetas = await prisma.generalMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generalMetaWithIdOnly = await prisma.generalMeta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GeneralMetaFindManyArgs>(
      args?: SelectSubset<T, GeneralMetaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GeneralMeta>>, PrismaPromise<Array<GeneralMetaGetPayload<T>>>>

    /**
     * Create a GeneralMeta.
     * @param {GeneralMetaCreateArgs} args - Arguments to create a GeneralMeta.
     * @example
     * // Create one GeneralMeta
     * const GeneralMeta = await prisma.generalMeta.create({
     *   data: {
     *     // ... data to create a GeneralMeta
     *   }
     * })
     * 
    **/
    create<T extends GeneralMetaCreateArgs>(
      args: SelectSubset<T, GeneralMetaCreateArgs>
    ): CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>>

    /**
     * Create many GeneralMetas.
     *     @param {GeneralMetaCreateManyArgs} args - Arguments to create many GeneralMetas.
     *     @example
     *     // Create many GeneralMetas
     *     const generalMeta = await prisma.generalMeta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GeneralMetaCreateManyArgs>(
      args?: SelectSubset<T, GeneralMetaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GeneralMeta.
     * @param {GeneralMetaDeleteArgs} args - Arguments to delete one GeneralMeta.
     * @example
     * // Delete one GeneralMeta
     * const GeneralMeta = await prisma.generalMeta.delete({
     *   where: {
     *     // ... filter to delete one GeneralMeta
     *   }
     * })
     * 
    **/
    delete<T extends GeneralMetaDeleteArgs>(
      args: SelectSubset<T, GeneralMetaDeleteArgs>
    ): CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>>

    /**
     * Update one GeneralMeta.
     * @param {GeneralMetaUpdateArgs} args - Arguments to update one GeneralMeta.
     * @example
     * // Update one GeneralMeta
     * const generalMeta = await prisma.generalMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GeneralMetaUpdateArgs>(
      args: SelectSubset<T, GeneralMetaUpdateArgs>
    ): CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>>

    /**
     * Delete zero or more GeneralMetas.
     * @param {GeneralMetaDeleteManyArgs} args - Arguments to filter GeneralMetas to delete.
     * @example
     * // Delete a few GeneralMetas
     * const { count } = await prisma.generalMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GeneralMetaDeleteManyArgs>(
      args?: SelectSubset<T, GeneralMetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneralMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneralMetas
     * const generalMeta = await prisma.generalMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GeneralMetaUpdateManyArgs>(
      args: SelectSubset<T, GeneralMetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GeneralMeta.
     * @param {GeneralMetaUpsertArgs} args - Arguments to update or create a GeneralMeta.
     * @example
     * // Update or create a GeneralMeta
     * const generalMeta = await prisma.generalMeta.upsert({
     *   create: {
     *     // ... data to create a GeneralMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneralMeta we want to update
     *   }
     * })
    **/
    upsert<T extends GeneralMetaUpsertArgs>(
      args: SelectSubset<T, GeneralMetaUpsertArgs>
    ): CheckSelect<T, Prisma__GeneralMetaClient<GeneralMeta>, Prisma__GeneralMetaClient<GeneralMetaGetPayload<T>>>

    /**
     * Count the number of GeneralMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaCountArgs} args - Arguments to filter GeneralMetas to count.
     * @example
     * // Count the number of GeneralMetas
     * const count = await prisma.generalMeta.count({
     *   where: {
     *     // ... the filter for the GeneralMetas we want to count
     *   }
     * })
    **/
    count<T extends GeneralMetaCountArgs>(
      args?: Subset<T, GeneralMetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneralMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneralMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneralMetaAggregateArgs>(args: Subset<T, GeneralMetaAggregateArgs>): PrismaPromise<GetGeneralMetaAggregateType<T>>

    /**
     * Group by GeneralMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneralMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneralMetaGroupByArgs['orderBy'] }
        : { orderBy?: GeneralMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneralMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneralMetaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneralMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GeneralMetaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GeneralMeta findUnique
   */
  export type GeneralMetaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * Throw an Error if a GeneralMeta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GeneralMeta to fetch.
     * 
    **/
    where: GeneralMetaWhereUniqueInput
  }


  /**
   * GeneralMeta findFirst
   */
  export type GeneralMetaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * Throw an Error if a GeneralMeta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GeneralMeta to fetch.
     * 
    **/
    where?: GeneralMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<GeneralMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneralMetas.
     * 
    **/
    cursor?: GeneralMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneralMetas.
     * 
    **/
    distinct?: Enumerable<GeneralMetaScalarFieldEnum>
  }


  /**
   * GeneralMeta findMany
   */
  export type GeneralMetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * Filter, which GeneralMetas to fetch.
     * 
    **/
    where?: GeneralMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<GeneralMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneralMetas.
     * 
    **/
    cursor?: GeneralMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralMetas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GeneralMetaScalarFieldEnum>
  }


  /**
   * GeneralMeta create
   */
  export type GeneralMetaCreateArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * The data needed to create a GeneralMeta.
     * 
    **/
    data: XOR<GeneralMetaCreateInput, GeneralMetaUncheckedCreateInput>
  }


  /**
   * GeneralMeta createMany
   */
  export type GeneralMetaCreateManyArgs = {
    data: Enumerable<GeneralMetaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GeneralMeta update
   */
  export type GeneralMetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * The data needed to update a GeneralMeta.
     * 
    **/
    data: XOR<GeneralMetaUpdateInput, GeneralMetaUncheckedUpdateInput>
    /**
     * Choose, which GeneralMeta to update.
     * 
    **/
    where: GeneralMetaWhereUniqueInput
  }


  /**
   * GeneralMeta updateMany
   */
  export type GeneralMetaUpdateManyArgs = {
    data: XOR<GeneralMetaUpdateManyMutationInput, GeneralMetaUncheckedUpdateManyInput>
    where?: GeneralMetaWhereInput
  }


  /**
   * GeneralMeta upsert
   */
  export type GeneralMetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * The filter to search for the GeneralMeta to update in case it exists.
     * 
    **/
    where: GeneralMetaWhereUniqueInput
    /**
     * In case the GeneralMeta found by the `where` argument doesn't exist, create a new GeneralMeta with this data.
     * 
    **/
    create: XOR<GeneralMetaCreateInput, GeneralMetaUncheckedCreateInput>
    /**
     * In case the GeneralMeta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GeneralMetaUpdateInput, GeneralMetaUncheckedUpdateInput>
  }


  /**
   * GeneralMeta delete
   */
  export type GeneralMetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
    /**
     * Filter which GeneralMeta to delete.
     * 
    **/
    where: GeneralMetaWhereUniqueInput
  }


  /**
   * GeneralMeta deleteMany
   */
  export type GeneralMetaDeleteManyArgs = {
    where?: GeneralMetaWhereInput
  }


  /**
   * GeneralMeta without action
   */
  export type GeneralMetaArgs = {
    /**
     * Select specific fields to fetch from the GeneralMeta
     * 
    **/
    select?: GeneralMetaSelect | null
  }



  /**
   * Model ProductAttributeMeta
   */


  export type AggregateProductAttributeMeta = {
    _count: ProductAttributeMetaCountAggregateOutputType | null
    _min: ProductAttributeMetaMinAggregateOutputType | null
    _max: ProductAttributeMetaMaxAggregateOutputType | null
  }

  export type ProductAttributeMetaMinAggregateOutputType = {
    id: string | null
    attributeId: string | null
    name: string | null
  }

  export type ProductAttributeMetaMaxAggregateOutputType = {
    id: string | null
    attributeId: string | null
    name: string | null
  }

  export type ProductAttributeMetaCountAggregateOutputType = {
    id: number
    attributeId: number
    name: number
    value: number
    _all: number
  }


  export type ProductAttributeMetaMinAggregateInputType = {
    id?: true
    attributeId?: true
    name?: true
  }

  export type ProductAttributeMetaMaxAggregateInputType = {
    id?: true
    attributeId?: true
    name?: true
  }

  export type ProductAttributeMetaCountAggregateInputType = {
    id?: true
    attributeId?: true
    name?: true
    value?: true
    _all?: true
  }

  export type ProductAttributeMetaAggregateArgs = {
    /**
     * Filter which ProductAttributeMeta to aggregate.
     * 
    **/
    where?: ProductAttributeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductAttributeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAttributeMetas
    **/
    _count?: true | ProductAttributeMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAttributeMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAttributeMetaMaxAggregateInputType
  }

  export type GetProductAttributeMetaAggregateType<T extends ProductAttributeMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAttributeMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAttributeMeta[P]>
      : GetScalarType<T[P], AggregateProductAttributeMeta[P]>
  }




  export type ProductAttributeMetaGroupByArgs = {
    where?: ProductAttributeMetaWhereInput
    orderBy?: Enumerable<ProductAttributeMetaOrderByWithAggregationInput>
    by: Array<ProductAttributeMetaScalarFieldEnum>
    having?: ProductAttributeMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAttributeMetaCountAggregateInputType | true
    _min?: ProductAttributeMetaMinAggregateInputType
    _max?: ProductAttributeMetaMaxAggregateInputType
  }


  export type ProductAttributeMetaGroupByOutputType = {
    id: string
    attributeId: string
    name: string
    value: JsonValue
    _count: ProductAttributeMetaCountAggregateOutputType | null
    _min: ProductAttributeMetaMinAggregateOutputType | null
    _max: ProductAttributeMetaMaxAggregateOutputType | null
  }

  type GetProductAttributeMetaGroupByPayload<T extends ProductAttributeMetaGroupByArgs> = Promise<
    Array<
      PickArray<ProductAttributeMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAttributeMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAttributeMetaGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAttributeMetaGroupByOutputType[P]>
        }
      >
    >


  export type ProductAttributeMetaSelect = {
    id?: boolean
    attributeId?: boolean
    attribute?: boolean | ProductAttributeArgs
    name?: boolean
    value?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductAttributeMetaCountOutputTypeArgs
  }

  export type ProductAttributeMetaInclude = {
    attribute?: boolean | ProductAttributeArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductAttributeMetaCountOutputTypeArgs
  }

  export type ProductAttributeMetaGetPayload<
    S extends boolean | null | undefined | ProductAttributeMetaArgs,
    U = keyof S
      > = S extends true
        ? ProductAttributeMeta
    : S extends undefined
    ? never
    : S extends ProductAttributeMetaArgs | ProductAttributeMetaFindManyArgs
    ?'include' extends U
    ? ProductAttributeMeta  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'attribute'
        ? ProductAttributeGetPayload<S['include'][P]> :
        P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductAttributeMetaCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttributeMeta ?ProductAttributeMeta [P]
  : 
          P extends 'attribute'
        ? ProductAttributeGetPayload<S['select'][P]> :
        P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductAttributeMetaCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductAttributeMeta
  : ProductAttributeMeta


  type ProductAttributeMetaCountArgs = Merge<
    Omit<ProductAttributeMetaFindManyArgs, 'select' | 'include'> & {
      select?: ProductAttributeMetaCountAggregateInputType | true
    }
  >

  export interface ProductAttributeMetaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductAttributeMeta that matches the filter.
     * @param {ProductAttributeMetaFindUniqueArgs} args - Arguments to find a ProductAttributeMeta
     * @example
     * // Get one ProductAttributeMeta
     * const productAttributeMeta = await prisma.productAttributeMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAttributeMetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAttributeMetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAttributeMeta'> extends True ? CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta | null >, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T> | null >>

    /**
     * Find the first ProductAttributeMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaFindFirstArgs} args - Arguments to find a ProductAttributeMeta
     * @example
     * // Get one ProductAttributeMeta
     * const productAttributeMeta = await prisma.productAttributeMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAttributeMetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAttributeMetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAttributeMeta'> extends True ? CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta | null >, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T> | null >>

    /**
     * Find zero or more ProductAttributeMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAttributeMetas
     * const productAttributeMetas = await prisma.productAttributeMeta.findMany()
     * 
     * // Get first 10 ProductAttributeMetas
     * const productAttributeMetas = await prisma.productAttributeMeta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAttributeMetaWithIdOnly = await prisma.productAttributeMeta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAttributeMetaFindManyArgs>(
      args?: SelectSubset<T, ProductAttributeMetaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductAttributeMeta>>, PrismaPromise<Array<ProductAttributeMetaGetPayload<T>>>>

    /**
     * Create a ProductAttributeMeta.
     * @param {ProductAttributeMetaCreateArgs} args - Arguments to create a ProductAttributeMeta.
     * @example
     * // Create one ProductAttributeMeta
     * const ProductAttributeMeta = await prisma.productAttributeMeta.create({
     *   data: {
     *     // ... data to create a ProductAttributeMeta
     *   }
     * })
     * 
    **/
    create<T extends ProductAttributeMetaCreateArgs>(
      args: SelectSubset<T, ProductAttributeMetaCreateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>>

    /**
     * Create many ProductAttributeMetas.
     *     @param {ProductAttributeMetaCreateManyArgs} args - Arguments to create many ProductAttributeMetas.
     *     @example
     *     // Create many ProductAttributeMetas
     *     const productAttributeMeta = await prisma.productAttributeMeta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductAttributeMetaCreateManyArgs>(
      args?: SelectSubset<T, ProductAttributeMetaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAttributeMeta.
     * @param {ProductAttributeMetaDeleteArgs} args - Arguments to delete one ProductAttributeMeta.
     * @example
     * // Delete one ProductAttributeMeta
     * const ProductAttributeMeta = await prisma.productAttributeMeta.delete({
     *   where: {
     *     // ... filter to delete one ProductAttributeMeta
     *   }
     * })
     * 
    **/
    delete<T extends ProductAttributeMetaDeleteArgs>(
      args: SelectSubset<T, ProductAttributeMetaDeleteArgs>
    ): CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>>

    /**
     * Update one ProductAttributeMeta.
     * @param {ProductAttributeMetaUpdateArgs} args - Arguments to update one ProductAttributeMeta.
     * @example
     * // Update one ProductAttributeMeta
     * const productAttributeMeta = await prisma.productAttributeMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAttributeMetaUpdateArgs>(
      args: SelectSubset<T, ProductAttributeMetaUpdateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>>

    /**
     * Delete zero or more ProductAttributeMetas.
     * @param {ProductAttributeMetaDeleteManyArgs} args - Arguments to filter ProductAttributeMetas to delete.
     * @example
     * // Delete a few ProductAttributeMetas
     * const { count } = await prisma.productAttributeMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAttributeMetaDeleteManyArgs>(
      args?: SelectSubset<T, ProductAttributeMetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAttributeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAttributeMetas
     * const productAttributeMeta = await prisma.productAttributeMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAttributeMetaUpdateManyArgs>(
      args: SelectSubset<T, ProductAttributeMetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAttributeMeta.
     * @param {ProductAttributeMetaUpsertArgs} args - Arguments to update or create a ProductAttributeMeta.
     * @example
     * // Update or create a ProductAttributeMeta
     * const productAttributeMeta = await prisma.productAttributeMeta.upsert({
     *   create: {
     *     // ... data to create a ProductAttributeMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAttributeMeta we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAttributeMetaUpsertArgs>(
      args: SelectSubset<T, ProductAttributeMetaUpsertArgs>
    ): CheckSelect<T, Prisma__ProductAttributeMetaClient<ProductAttributeMeta>, Prisma__ProductAttributeMetaClient<ProductAttributeMetaGetPayload<T>>>

    /**
     * Count the number of ProductAttributeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaCountArgs} args - Arguments to filter ProductAttributeMetas to count.
     * @example
     * // Count the number of ProductAttributeMetas
     * const count = await prisma.productAttributeMeta.count({
     *   where: {
     *     // ... the filter for the ProductAttributeMetas we want to count
     *   }
     * })
    **/
    count<T extends ProductAttributeMetaCountArgs>(
      args?: Subset<T, ProductAttributeMetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAttributeMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAttributeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAttributeMetaAggregateArgs>(args: Subset<T, ProductAttributeMetaAggregateArgs>): PrismaPromise<GetProductAttributeMetaAggregateType<T>>

    /**
     * Group by ProductAttributeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAttributeMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAttributeMetaGroupByArgs['orderBy'] }
        : { orderBy?: ProductAttributeMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAttributeMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAttributeMetaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAttributeMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAttributeMetaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    attribute<T extends ProductAttributeArgs = {}>(args?: Subset<T, ProductAttributeArgs>): CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute | null >, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T> | null >>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductAttributeMeta findUnique
   */
  export type ProductAttributeMetaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * Throw an Error if a ProductAttributeMeta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeMeta to fetch.
     * 
    **/
    where: ProductAttributeMetaWhereUniqueInput
  }


  /**
   * ProductAttributeMeta findFirst
   */
  export type ProductAttributeMetaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * Throw an Error if a ProductAttributeMeta can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttributeMeta to fetch.
     * 
    **/
    where?: ProductAttributeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAttributeMetas.
     * 
    **/
    cursor?: ProductAttributeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeMetas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAttributeMetas.
     * 
    **/
    distinct?: Enumerable<ProductAttributeMetaScalarFieldEnum>
  }


  /**
   * ProductAttributeMeta findMany
   */
  export type ProductAttributeMetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * Filter, which ProductAttributeMetas to fetch.
     * 
    **/
    where?: ProductAttributeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributeMetas to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAttributeMetas.
     * 
    **/
    cursor?: ProductAttributeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributeMetas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributeMetas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductAttributeMetaScalarFieldEnum>
  }


  /**
   * ProductAttributeMeta create
   */
  export type ProductAttributeMetaCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * The data needed to create a ProductAttributeMeta.
     * 
    **/
    data: XOR<ProductAttributeMetaCreateInput, ProductAttributeMetaUncheckedCreateInput>
  }


  /**
   * ProductAttributeMeta createMany
   */
  export type ProductAttributeMetaCreateManyArgs = {
    data: Enumerable<ProductAttributeMetaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductAttributeMeta update
   */
  export type ProductAttributeMetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * The data needed to update a ProductAttributeMeta.
     * 
    **/
    data: XOR<ProductAttributeMetaUpdateInput, ProductAttributeMetaUncheckedUpdateInput>
    /**
     * Choose, which ProductAttributeMeta to update.
     * 
    **/
    where: ProductAttributeMetaWhereUniqueInput
  }


  /**
   * ProductAttributeMeta updateMany
   */
  export type ProductAttributeMetaUpdateManyArgs = {
    data: XOR<ProductAttributeMetaUpdateManyMutationInput, ProductAttributeMetaUncheckedUpdateManyInput>
    where?: ProductAttributeMetaWhereInput
  }


  /**
   * ProductAttributeMeta upsert
   */
  export type ProductAttributeMetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * The filter to search for the ProductAttributeMeta to update in case it exists.
     * 
    **/
    where: ProductAttributeMetaWhereUniqueInput
    /**
     * In case the ProductAttributeMeta found by the `where` argument doesn't exist, create a new ProductAttributeMeta with this data.
     * 
    **/
    create: XOR<ProductAttributeMetaCreateInput, ProductAttributeMetaUncheckedCreateInput>
    /**
     * In case the ProductAttributeMeta was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductAttributeMetaUpdateInput, ProductAttributeMetaUncheckedUpdateInput>
  }


  /**
   * ProductAttributeMeta delete
   */
  export type ProductAttributeMetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
    /**
     * Filter which ProductAttributeMeta to delete.
     * 
    **/
    where: ProductAttributeMetaWhereUniqueInput
  }


  /**
   * ProductAttributeMeta deleteMany
   */
  export type ProductAttributeMetaDeleteManyArgs = {
    where?: ProductAttributeMetaWhereInput
  }


  /**
   * ProductAttributeMeta without action
   */
  export type ProductAttributeMetaArgs = {
    /**
     * Select specific fields to fetch from the ProductAttributeMeta
     * 
    **/
    select?: ProductAttributeMetaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeMetaInclude | null
  }



  /**
   * Model ProductAttribute
   */


  export type AggregateProductAttribute = {
    _count: ProductAttributeCountAggregateOutputType | null
    _min: ProductAttributeMinAggregateOutputType | null
    _max: ProductAttributeMaxAggregateOutputType | null
  }

  export type ProductAttributeMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    global: boolean | null
    categoryId: string | null
    onlyForProductId: string | null
  }

  export type ProductAttributeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    global: boolean | null
    categoryId: string | null
    onlyForProductId: string | null
  }

  export type ProductAttributeCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    global: number
    categoryId: number
    onlyForProductId: number
    _all: number
  }


  export type ProductAttributeMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    global?: true
    categoryId?: true
    onlyForProductId?: true
  }

  export type ProductAttributeMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    global?: true
    categoryId?: true
    onlyForProductId?: true
  }

  export type ProductAttributeCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    global?: true
    categoryId?: true
    onlyForProductId?: true
    _all?: true
  }

  export type ProductAttributeAggregateArgs = {
    /**
     * Filter which ProductAttribute to aggregate.
     * 
    **/
    where?: ProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAttributes
    **/
    _count?: true | ProductAttributeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAttributeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAttributeMaxAggregateInputType
  }

  export type GetProductAttributeAggregateType<T extends ProductAttributeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAttribute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAttribute[P]>
      : GetScalarType<T[P], AggregateProductAttribute[P]>
  }




  export type ProductAttributeGroupByArgs = {
    where?: ProductAttributeWhereInput
    orderBy?: Enumerable<ProductAttributeOrderByWithAggregationInput>
    by: Array<ProductAttributeScalarFieldEnum>
    having?: ProductAttributeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAttributeCountAggregateInputType | true
    _min?: ProductAttributeMinAggregateInputType
    _max?: ProductAttributeMaxAggregateInputType
  }


  export type ProductAttributeGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string | null
    global: boolean
    categoryId: string | null
    onlyForProductId: string | null
    _count: ProductAttributeCountAggregateOutputType | null
    _min: ProductAttributeMinAggregateOutputType | null
    _max: ProductAttributeMaxAggregateOutputType | null
  }

  type GetProductAttributeGroupByPayload<T extends ProductAttributeGroupByArgs> = Promise<
    Array<
      PickArray<ProductAttributeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAttributeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAttributeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAttributeGroupByOutputType[P]>
        }
      >
    >


  export type ProductAttributeSelect = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    global?: boolean
    metas?: boolean | ProductAttributeMetaFindManyArgs
    categoryId?: boolean
    category?: boolean | CategoryArgs
    onlyForProductId?: boolean
    onlyForProduct?: boolean | ProductArgs
    _count?: boolean | ProductAttributeCountOutputTypeArgs
  }

  export type ProductAttributeInclude = {
    metas?: boolean | ProductAttributeMetaFindManyArgs
    category?: boolean | CategoryArgs
    onlyForProduct?: boolean | ProductArgs
    _count?: boolean | ProductAttributeCountOutputTypeArgs
  }

  export type ProductAttributeGetPayload<
    S extends boolean | null | undefined | ProductAttributeArgs,
    U = keyof S
      > = S extends true
        ? ProductAttribute
    : S extends undefined
    ? never
    : S extends ProductAttributeArgs | ProductAttributeFindManyArgs
    ?'include' extends U
    ? ProductAttribute  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'metas'
        ? Array < ProductAttributeMetaGetPayload<S['include'][P]>>  :
        P extends 'category'
        ? CategoryGetPayload<S['include'][P]> | null :
        P extends 'onlyForProduct'
        ? ProductGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? ProductAttributeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAttribute ?ProductAttribute [P]
  : 
          P extends 'metas'
        ? Array < ProductAttributeMetaGetPayload<S['select'][P]>>  :
        P extends 'category'
        ? CategoryGetPayload<S['select'][P]> | null :
        P extends 'onlyForProduct'
        ? ProductGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? ProductAttributeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductAttribute
  : ProductAttribute


  type ProductAttributeCountArgs = Merge<
    Omit<ProductAttributeFindManyArgs, 'select' | 'include'> & {
      select?: ProductAttributeCountAggregateInputType | true
    }
  >

  export interface ProductAttributeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductAttribute that matches the filter.
     * @param {ProductAttributeFindUniqueArgs} args - Arguments to find a ProductAttribute
     * @example
     * // Get one ProductAttribute
     * const productAttribute = await prisma.productAttribute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAttributeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAttributeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAttribute'> extends True ? CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute | null >, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T> | null >>

    /**
     * Find the first ProductAttribute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeFindFirstArgs} args - Arguments to find a ProductAttribute
     * @example
     * // Get one ProductAttribute
     * const productAttribute = await prisma.productAttribute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAttributeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAttributeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAttribute'> extends True ? CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>> : CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute | null >, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T> | null >>

    /**
     * Find zero or more ProductAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAttributes
     * const productAttributes = await prisma.productAttribute.findMany()
     * 
     * // Get first 10 ProductAttributes
     * const productAttributes = await prisma.productAttribute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAttributeWithIdOnly = await prisma.productAttribute.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAttributeFindManyArgs>(
      args?: SelectSubset<T, ProductAttributeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductAttribute>>, PrismaPromise<Array<ProductAttributeGetPayload<T>>>>

    /**
     * Create a ProductAttribute.
     * @param {ProductAttributeCreateArgs} args - Arguments to create a ProductAttribute.
     * @example
     * // Create one ProductAttribute
     * const ProductAttribute = await prisma.productAttribute.create({
     *   data: {
     *     // ... data to create a ProductAttribute
     *   }
     * })
     * 
    **/
    create<T extends ProductAttributeCreateArgs>(
      args: SelectSubset<T, ProductAttributeCreateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>>

    /**
     * Create many ProductAttributes.
     *     @param {ProductAttributeCreateManyArgs} args - Arguments to create many ProductAttributes.
     *     @example
     *     // Create many ProductAttributes
     *     const productAttribute = await prisma.productAttribute.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductAttributeCreateManyArgs>(
      args?: SelectSubset<T, ProductAttributeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAttribute.
     * @param {ProductAttributeDeleteArgs} args - Arguments to delete one ProductAttribute.
     * @example
     * // Delete one ProductAttribute
     * const ProductAttribute = await prisma.productAttribute.delete({
     *   where: {
     *     // ... filter to delete one ProductAttribute
     *   }
     * })
     * 
    **/
    delete<T extends ProductAttributeDeleteArgs>(
      args: SelectSubset<T, ProductAttributeDeleteArgs>
    ): CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>>

    /**
     * Update one ProductAttribute.
     * @param {ProductAttributeUpdateArgs} args - Arguments to update one ProductAttribute.
     * @example
     * // Update one ProductAttribute
     * const productAttribute = await prisma.productAttribute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAttributeUpdateArgs>(
      args: SelectSubset<T, ProductAttributeUpdateArgs>
    ): CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>>

    /**
     * Delete zero or more ProductAttributes.
     * @param {ProductAttributeDeleteManyArgs} args - Arguments to filter ProductAttributes to delete.
     * @example
     * // Delete a few ProductAttributes
     * const { count } = await prisma.productAttribute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAttributeDeleteManyArgs>(
      args?: SelectSubset<T, ProductAttributeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAttributes
     * const productAttribute = await prisma.productAttribute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAttributeUpdateManyArgs>(
      args: SelectSubset<T, ProductAttributeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAttribute.
     * @param {ProductAttributeUpsertArgs} args - Arguments to update or create a ProductAttribute.
     * @example
     * // Update or create a ProductAttribute
     * const productAttribute = await prisma.productAttribute.upsert({
     *   create: {
     *     // ... data to create a ProductAttribute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAttribute we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAttributeUpsertArgs>(
      args: SelectSubset<T, ProductAttributeUpsertArgs>
    ): CheckSelect<T, Prisma__ProductAttributeClient<ProductAttribute>, Prisma__ProductAttributeClient<ProductAttributeGetPayload<T>>>

    /**
     * Count the number of ProductAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeCountArgs} args - Arguments to filter ProductAttributes to count.
     * @example
     * // Count the number of ProductAttributes
     * const count = await prisma.productAttribute.count({
     *   where: {
     *     // ... the filter for the ProductAttributes we want to count
     *   }
     * })
    **/
    count<T extends ProductAttributeCountArgs>(
      args?: Subset<T, ProductAttributeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAttributeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAttributeAggregateArgs>(args: Subset<T, ProductAttributeAggregateArgs>): PrismaPromise<GetProductAttributeAggregateType<T>>

    /**
     * Group by ProductAttribute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAttributeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAttributeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAttributeGroupByArgs['orderBy'] }
        : { orderBy?: ProductAttributeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAttributeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAttributeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAttribute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAttributeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    metas<T extends ProductAttributeMetaFindManyArgs = {}>(args?: Subset<T, ProductAttributeMetaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeMeta>>, PrismaPromise<Array<ProductAttributeMetaGetPayload<T>>>>;

    category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    onlyForProduct<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductAttribute findUnique
   */
  export type ProductAttributeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * Throw an Error if a ProductAttribute can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttribute to fetch.
     * 
    **/
    where: ProductAttributeWhereUniqueInput
  }


  /**
   * ProductAttribute findFirst
   */
  export type ProductAttributeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * Throw an Error if a ProductAttribute can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAttribute to fetch.
     * 
    **/
    where?: ProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAttributes.
     * 
    **/
    cursor?: ProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAttributes.
     * 
    **/
    distinct?: Enumerable<ProductAttributeScalarFieldEnum>
  }


  /**
   * ProductAttribute findMany
   */
  export type ProductAttributeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * Filter, which ProductAttributes to fetch.
     * 
    **/
    where?: ProductAttributeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAttributes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAttributeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAttributes.
     * 
    **/
    cursor?: ProductAttributeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAttributes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAttributes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductAttributeScalarFieldEnum>
  }


  /**
   * ProductAttribute create
   */
  export type ProductAttributeCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * The data needed to create a ProductAttribute.
     * 
    **/
    data: XOR<ProductAttributeCreateInput, ProductAttributeUncheckedCreateInput>
  }


  /**
   * ProductAttribute createMany
   */
  export type ProductAttributeCreateManyArgs = {
    data: Enumerable<ProductAttributeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductAttribute update
   */
  export type ProductAttributeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * The data needed to update a ProductAttribute.
     * 
    **/
    data: XOR<ProductAttributeUpdateInput, ProductAttributeUncheckedUpdateInput>
    /**
     * Choose, which ProductAttribute to update.
     * 
    **/
    where: ProductAttributeWhereUniqueInput
  }


  /**
   * ProductAttribute updateMany
   */
  export type ProductAttributeUpdateManyArgs = {
    data: XOR<ProductAttributeUpdateManyMutationInput, ProductAttributeUncheckedUpdateManyInput>
    where?: ProductAttributeWhereInput
  }


  /**
   * ProductAttribute upsert
   */
  export type ProductAttributeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * The filter to search for the ProductAttribute to update in case it exists.
     * 
    **/
    where: ProductAttributeWhereUniqueInput
    /**
     * In case the ProductAttribute found by the `where` argument doesn't exist, create a new ProductAttribute with this data.
     * 
    **/
    create: XOR<ProductAttributeCreateInput, ProductAttributeUncheckedCreateInput>
    /**
     * In case the ProductAttribute was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductAttributeUpdateInput, ProductAttributeUncheckedUpdateInput>
  }


  /**
   * ProductAttribute delete
   */
  export type ProductAttributeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
    /**
     * Filter which ProductAttribute to delete.
     * 
    **/
    where: ProductAttributeWhereUniqueInput
  }


  /**
   * ProductAttribute deleteMany
   */
  export type ProductAttributeDeleteManyArgs = {
    where?: ProductAttributeWhereInput
  }


  /**
   * ProductAttribute without action
   */
  export type ProductAttributeArgs = {
    /**
     * Select specific fields to fetch from the ProductAttribute
     * 
    **/
    select?: ProductAttributeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAttributeInclude | null
  }



  /**
   * Model Tag
   */


  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type TagAggregateArgs = {
    /**
     * Filter which Tag to aggregate.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs = {
    where?: TagWhereInput
    orderBy?: Enumerable<TagOrderByWithAggregationInput>
    by: Array<TagScalarFieldEnum>
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }


  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Promise<
    Array<
      PickArray<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | TagCountOutputTypeArgs
  }

  export type TagGetPayload<
    S extends boolean | null | undefined | TagArgs,
    U = keyof S
      > = S extends true
        ? Tag
    : S extends undefined
    ? never
    : S extends TagArgs | TagFindManyArgs
    ?'include' extends U
    ? Tag  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? TagCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Tag ?Tag [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? TagCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Tag
  : Tag


  type TagCountArgs = Merge<
    Omit<TagFindManyArgs, 'select' | 'include'> & {
      select?: TagCountAggregateInputType | true
    }
  >

  export interface TagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tag'> extends True ? CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>> : CheckSelect<T, Prisma__TagClient<Tag | null >, Prisma__TagClient<TagGetPayload<T> | null >>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs>(
      args?: SelectSubset<T, TagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs>(
      args: SelectSubset<T, TagCreateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs>(
      args?: SelectSubset<T, TagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs>(
      args: SelectSubset<T, TagDeleteArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs>(
      args: SelectSubset<T, TagUpdateArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs>(
      args?: SelectSubset<T, TagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs>(
      args: SelectSubset<T, TagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs>(
      args: SelectSubset<T, TagUpsertArgs>
    ): CheckSelect<T, Prisma__TagClient<Tag>, Prisma__TagClient<TagGetPayload<T>>>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Throw an Error if a Tag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Tag to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     * 
    **/
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter, which Tags to fetch.
     * 
    **/
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     * 
    **/
    orderBy?: Enumerable<TagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     * 
    **/
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TagScalarFieldEnum>
  }


  /**
   * Tag create
   */
  export type TagCreateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to create a Tag.
     * 
    **/
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs = {
    data: Enumerable<TagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The data needed to update a Tag.
     * 
    **/
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs = {
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * The filter to search for the Tag to update in case it exists.
     * 
    **/
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     * 
    **/
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
    /**
     * Filter which Tag to delete.
     * 
    **/
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs = {
    where?: TagWhereInput
  }


  /**
   * Tag without action
   */
  export type TagArgs = {
    /**
     * Select specific fields to fetch from the Tag
     * 
    **/
    select?: TagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TagInclude | null
  }



  /**
   * Model CommandUnit
   */


  export type AggregateCommandUnit = {
    _count: CommandUnitCountAggregateOutputType | null
    _min: CommandUnitMinAggregateOutputType | null
    _max: CommandUnitMaxAggregateOutputType | null
  }

  export type CommandUnitMinAggregateOutputType = {
    id: string | null
    title: string | null
    shortCode: string | null
  }

  export type CommandUnitMaxAggregateOutputType = {
    id: string | null
    title: string | null
    shortCode: string | null
  }

  export type CommandUnitCountAggregateOutputType = {
    id: number
    title: number
    shortCode: number
    _all: number
  }


  export type CommandUnitMinAggregateInputType = {
    id?: true
    title?: true
    shortCode?: true
  }

  export type CommandUnitMaxAggregateInputType = {
    id?: true
    title?: true
    shortCode?: true
  }

  export type CommandUnitCountAggregateInputType = {
    id?: true
    title?: true
    shortCode?: true
    _all?: true
  }

  export type CommandUnitAggregateArgs = {
    /**
     * Filter which CommandUnit to aggregate.
     * 
    **/
    where?: CommandUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommandUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandUnits
    **/
    _count?: true | CommandUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandUnitMaxAggregateInputType
  }

  export type GetCommandUnitAggregateType<T extends CommandUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandUnit[P]>
      : GetScalarType<T[P], AggregateCommandUnit[P]>
  }




  export type CommandUnitGroupByArgs = {
    where?: CommandUnitWhereInput
    orderBy?: Enumerable<CommandUnitOrderByWithAggregationInput>
    by: Array<CommandUnitScalarFieldEnum>
    having?: CommandUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandUnitCountAggregateInputType | true
    _min?: CommandUnitMinAggregateInputType
    _max?: CommandUnitMaxAggregateInputType
  }


  export type CommandUnitGroupByOutputType = {
    id: string
    title: string
    shortCode: string
    _count: CommandUnitCountAggregateOutputType | null
    _min: CommandUnitMinAggregateOutputType | null
    _max: CommandUnitMaxAggregateOutputType | null
  }

  type GetCommandUnitGroupByPayload<T extends CommandUnitGroupByArgs> = Promise<
    Array<
      PickArray<CommandUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandUnitGroupByOutputType[P]>
            : GetScalarType<T[P], CommandUnitGroupByOutputType[P]>
        }
      >
    >


  export type CommandUnitSelect = {
    id?: boolean
    title?: boolean
    shortCode?: boolean
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    _count?: boolean | CommandUnitCountOutputTypeArgs
  }

  export type CommandUnitInclude = {
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    _count?: boolean | CommandUnitCountOutputTypeArgs
  }

  export type CommandUnitGetPayload<
    S extends boolean | null | undefined | CommandUnitArgs,
    U = keyof S
      > = S extends true
        ? CommandUnit
    : S extends undefined
    ? never
    : S extends CommandUnitArgs | CommandUnitFindManyArgs
    ?'include' extends U
    ? CommandUnit  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CommandUnitCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandUnit ?CommandUnit [P]
  : 
          P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CommandUnitCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : CommandUnit
  : CommandUnit


  type CommandUnitCountArgs = Merge<
    Omit<CommandUnitFindManyArgs, 'select' | 'include'> & {
      select?: CommandUnitCountAggregateInputType | true
    }
  >

  export interface CommandUnitDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommandUnit that matches the filter.
     * @param {CommandUnitFindUniqueArgs} args - Arguments to find a CommandUnit
     * @example
     * // Get one CommandUnit
     * const commandUnit = await prisma.commandUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandUnitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommandUnitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommandUnit'> extends True ? CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>> : CheckSelect<T, Prisma__CommandUnitClient<CommandUnit | null >, Prisma__CommandUnitClient<CommandUnitGetPayload<T> | null >>

    /**
     * Find the first CommandUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitFindFirstArgs} args - Arguments to find a CommandUnit
     * @example
     * // Get one CommandUnit
     * const commandUnit = await prisma.commandUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandUnitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommandUnitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommandUnit'> extends True ? CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>> : CheckSelect<T, Prisma__CommandUnitClient<CommandUnit | null >, Prisma__CommandUnitClient<CommandUnitGetPayload<T> | null >>

    /**
     * Find zero or more CommandUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandUnits
     * const commandUnits = await prisma.commandUnit.findMany()
     * 
     * // Get first 10 CommandUnits
     * const commandUnits = await prisma.commandUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandUnitWithIdOnly = await prisma.commandUnit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandUnitFindManyArgs>(
      args?: SelectSubset<T, CommandUnitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommandUnit>>, PrismaPromise<Array<CommandUnitGetPayload<T>>>>

    /**
     * Create a CommandUnit.
     * @param {CommandUnitCreateArgs} args - Arguments to create a CommandUnit.
     * @example
     * // Create one CommandUnit
     * const CommandUnit = await prisma.commandUnit.create({
     *   data: {
     *     // ... data to create a CommandUnit
     *   }
     * })
     * 
    **/
    create<T extends CommandUnitCreateArgs>(
      args: SelectSubset<T, CommandUnitCreateArgs>
    ): CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>>

    /**
     * Create many CommandUnits.
     *     @param {CommandUnitCreateManyArgs} args - Arguments to create many CommandUnits.
     *     @example
     *     // Create many CommandUnits
     *     const commandUnit = await prisma.commandUnit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommandUnitCreateManyArgs>(
      args?: SelectSubset<T, CommandUnitCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommandUnit.
     * @param {CommandUnitDeleteArgs} args - Arguments to delete one CommandUnit.
     * @example
     * // Delete one CommandUnit
     * const CommandUnit = await prisma.commandUnit.delete({
     *   where: {
     *     // ... filter to delete one CommandUnit
     *   }
     * })
     * 
    **/
    delete<T extends CommandUnitDeleteArgs>(
      args: SelectSubset<T, CommandUnitDeleteArgs>
    ): CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>>

    /**
     * Update one CommandUnit.
     * @param {CommandUnitUpdateArgs} args - Arguments to update one CommandUnit.
     * @example
     * // Update one CommandUnit
     * const commandUnit = await prisma.commandUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandUnitUpdateArgs>(
      args: SelectSubset<T, CommandUnitUpdateArgs>
    ): CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>>

    /**
     * Delete zero or more CommandUnits.
     * @param {CommandUnitDeleteManyArgs} args - Arguments to filter CommandUnits to delete.
     * @example
     * // Delete a few CommandUnits
     * const { count } = await prisma.commandUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandUnitDeleteManyArgs>(
      args?: SelectSubset<T, CommandUnitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandUnits
     * const commandUnit = await prisma.commandUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandUnitUpdateManyArgs>(
      args: SelectSubset<T, CommandUnitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommandUnit.
     * @param {CommandUnitUpsertArgs} args - Arguments to update or create a CommandUnit.
     * @example
     * // Update or create a CommandUnit
     * const commandUnit = await prisma.commandUnit.upsert({
     *   create: {
     *     // ... data to create a CommandUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandUnit we want to update
     *   }
     * })
    **/
    upsert<T extends CommandUnitUpsertArgs>(
      args: SelectSubset<T, CommandUnitUpsertArgs>
    ): CheckSelect<T, Prisma__CommandUnitClient<CommandUnit>, Prisma__CommandUnitClient<CommandUnitGetPayload<T>>>

    /**
     * Count the number of CommandUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitCountArgs} args - Arguments to filter CommandUnits to count.
     * @example
     * // Count the number of CommandUnits
     * const count = await prisma.commandUnit.count({
     *   where: {
     *     // ... the filter for the CommandUnits we want to count
     *   }
     * })
    **/
    count<T extends CommandUnitCountArgs>(
      args?: Subset<T, CommandUnitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandUnitAggregateArgs>(args: Subset<T, CommandUnitAggregateArgs>): PrismaPromise<GetCommandUnitAggregateType<T>>

    /**
     * Group by CommandUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandUnitGroupByArgs['orderBy'] }
        : { orderBy?: CommandUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandUnitGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommandUnitClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    commandUnitProducts<T extends CommandUnitProductFindManyArgs = {}>(args?: Subset<T, CommandUnitProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandUnitProduct>>, PrismaPromise<Array<CommandUnitProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommandUnit findUnique
   */
  export type CommandUnitFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * Throw an Error if a CommandUnit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandUnit to fetch.
     * 
    **/
    where: CommandUnitWhereUniqueInput
  }


  /**
   * CommandUnit findFirst
   */
  export type CommandUnitFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * Throw an Error if a CommandUnit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandUnit to fetch.
     * 
    **/
    where?: CommandUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandUnits.
     * 
    **/
    cursor?: CommandUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandUnits.
     * 
    **/
    distinct?: Enumerable<CommandUnitScalarFieldEnum>
  }


  /**
   * CommandUnit findMany
   */
  export type CommandUnitFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * Filter, which CommandUnits to fetch.
     * 
    **/
    where?: CommandUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnits to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandUnits.
     * 
    **/
    cursor?: CommandUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommandUnitScalarFieldEnum>
  }


  /**
   * CommandUnit create
   */
  export type CommandUnitCreateArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * The data needed to create a CommandUnit.
     * 
    **/
    data: XOR<CommandUnitCreateInput, CommandUnitUncheckedCreateInput>
  }


  /**
   * CommandUnit createMany
   */
  export type CommandUnitCreateManyArgs = {
    data: Enumerable<CommandUnitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommandUnit update
   */
  export type CommandUnitUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * The data needed to update a CommandUnit.
     * 
    **/
    data: XOR<CommandUnitUpdateInput, CommandUnitUncheckedUpdateInput>
    /**
     * Choose, which CommandUnit to update.
     * 
    **/
    where: CommandUnitWhereUniqueInput
  }


  /**
   * CommandUnit updateMany
   */
  export type CommandUnitUpdateManyArgs = {
    data: XOR<CommandUnitUpdateManyMutationInput, CommandUnitUncheckedUpdateManyInput>
    where?: CommandUnitWhereInput
  }


  /**
   * CommandUnit upsert
   */
  export type CommandUnitUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * The filter to search for the CommandUnit to update in case it exists.
     * 
    **/
    where: CommandUnitWhereUniqueInput
    /**
     * In case the CommandUnit found by the `where` argument doesn't exist, create a new CommandUnit with this data.
     * 
    **/
    create: XOR<CommandUnitCreateInput, CommandUnitUncheckedCreateInput>
    /**
     * In case the CommandUnit was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommandUnitUpdateInput, CommandUnitUncheckedUpdateInput>
  }


  /**
   * CommandUnit delete
   */
  export type CommandUnitDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
    /**
     * Filter which CommandUnit to delete.
     * 
    **/
    where: CommandUnitWhereUniqueInput
  }


  /**
   * CommandUnit deleteMany
   */
  export type CommandUnitDeleteManyArgs = {
    where?: CommandUnitWhereInput
  }


  /**
   * CommandUnit without action
   */
  export type CommandUnitArgs = {
    /**
     * Select specific fields to fetch from the CommandUnit
     * 
    **/
    select?: CommandUnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitInclude | null
  }



  /**
   * Model CommandUnitProduct
   */


  export type AggregateCommandUnitProduct = {
    _count: CommandUnitProductCountAggregateOutputType | null
    _avg: CommandUnitProductAvgAggregateOutputType | null
    _sum: CommandUnitProductSumAggregateOutputType | null
    _min: CommandUnitProductMinAggregateOutputType | null
    _max: CommandUnitProductMaxAggregateOutputType | null
  }

  export type CommandUnitProductAvgAggregateOutputType = {
    unitPrice: number | null
  }

  export type CommandUnitProductSumAggregateOutputType = {
    unitPrice: number | null
  }

  export type CommandUnitProductMinAggregateOutputType = {
    id: string | null
    commandUnitId: string | null
    productId: string | null
    isDefault: boolean | null
    unitPrice: number | null
    priceRuleId: string | null
  }

  export type CommandUnitProductMaxAggregateOutputType = {
    id: string | null
    commandUnitId: string | null
    productId: string | null
    isDefault: boolean | null
    unitPrice: number | null
    priceRuleId: string | null
  }

  export type CommandUnitProductCountAggregateOutputType = {
    id: number
    commandUnitId: number
    productId: number
    isDefault: number
    unitPrice: number
    priceRuleId: number
    _all: number
  }


  export type CommandUnitProductAvgAggregateInputType = {
    unitPrice?: true
  }

  export type CommandUnitProductSumAggregateInputType = {
    unitPrice?: true
  }

  export type CommandUnitProductMinAggregateInputType = {
    id?: true
    commandUnitId?: true
    productId?: true
    isDefault?: true
    unitPrice?: true
    priceRuleId?: true
  }

  export type CommandUnitProductMaxAggregateInputType = {
    id?: true
    commandUnitId?: true
    productId?: true
    isDefault?: true
    unitPrice?: true
    priceRuleId?: true
  }

  export type CommandUnitProductCountAggregateInputType = {
    id?: true
    commandUnitId?: true
    productId?: true
    isDefault?: true
    unitPrice?: true
    priceRuleId?: true
    _all?: true
  }

  export type CommandUnitProductAggregateArgs = {
    /**
     * Filter which CommandUnitProduct to aggregate.
     * 
    **/
    where?: CommandUnitProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnitProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommandUnitProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnitProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnitProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandUnitProducts
    **/
    _count?: true | CommandUnitProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandUnitProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandUnitProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandUnitProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandUnitProductMaxAggregateInputType
  }

  export type GetCommandUnitProductAggregateType<T extends CommandUnitProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandUnitProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandUnitProduct[P]>
      : GetScalarType<T[P], AggregateCommandUnitProduct[P]>
  }




  export type CommandUnitProductGroupByArgs = {
    where?: CommandUnitProductWhereInput
    orderBy?: Enumerable<CommandUnitProductOrderByWithAggregationInput>
    by: Array<CommandUnitProductScalarFieldEnum>
    having?: CommandUnitProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandUnitProductCountAggregateInputType | true
    _avg?: CommandUnitProductAvgAggregateInputType
    _sum?: CommandUnitProductSumAggregateInputType
    _min?: CommandUnitProductMinAggregateInputType
    _max?: CommandUnitProductMaxAggregateInputType
  }


  export type CommandUnitProductGroupByOutputType = {
    id: string
    commandUnitId: string
    productId: string
    isDefault: boolean
    unitPrice: number
    priceRuleId: string
    _count: CommandUnitProductCountAggregateOutputType | null
    _avg: CommandUnitProductAvgAggregateOutputType | null
    _sum: CommandUnitProductSumAggregateOutputType | null
    _min: CommandUnitProductMinAggregateOutputType | null
    _max: CommandUnitProductMaxAggregateOutputType | null
  }

  type GetCommandUnitProductGroupByPayload<T extends CommandUnitProductGroupByArgs> = Promise<
    Array<
      PickArray<CommandUnitProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandUnitProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandUnitProductGroupByOutputType[P]>
            : GetScalarType<T[P], CommandUnitProductGroupByOutputType[P]>
        }
      >
    >


  export type CommandUnitProductSelect = {
    id?: boolean
    commandUnitId?: boolean
    commandUnit?: boolean | CommandUnitArgs
    productId?: boolean
    product?: boolean | ProductArgs
    isDefault?: boolean
    unitPrice?: boolean
    priceRuleId?: boolean
    priceRule?: boolean | PriceRuleArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    _count?: boolean | CommandUnitProductCountOutputTypeArgs
  }

  export type CommandUnitProductInclude = {
    commandUnit?: boolean | CommandUnitArgs
    product?: boolean | ProductArgs
    priceRule?: boolean | PriceRuleArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    _count?: boolean | CommandUnitProductCountOutputTypeArgs
  }

  export type CommandUnitProductGetPayload<
    S extends boolean | null | undefined | CommandUnitProductArgs,
    U = keyof S
      > = S extends true
        ? CommandUnitProduct
    : S extends undefined
    ? never
    : S extends CommandUnitProductArgs | CommandUnitProductFindManyArgs
    ?'include' extends U
    ? CommandUnitProduct  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'commandUnit'
        ? CommandUnitGetPayload<S['include'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['include'][P]> | null :
        P extends 'priceRule'
        ? PriceRuleGetPayload<S['include'][P]> :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CommandUnitProductCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandUnitProduct ?CommandUnitProduct [P]
  : 
          P extends 'commandUnit'
        ? CommandUnitGetPayload<S['select'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['select'][P]> | null :
        P extends 'priceRule'
        ? PriceRuleGetPayload<S['select'][P]> :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CommandUnitProductCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : CommandUnitProduct
  : CommandUnitProduct


  type CommandUnitProductCountArgs = Merge<
    Omit<CommandUnitProductFindManyArgs, 'select' | 'include'> & {
      select?: CommandUnitProductCountAggregateInputType | true
    }
  >

  export interface CommandUnitProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommandUnitProduct that matches the filter.
     * @param {CommandUnitProductFindUniqueArgs} args - Arguments to find a CommandUnitProduct
     * @example
     * // Get one CommandUnitProduct
     * const commandUnitProduct = await prisma.commandUnitProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandUnitProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommandUnitProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommandUnitProduct'> extends True ? CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>> : CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct | null >, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T> | null >>

    /**
     * Find the first CommandUnitProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductFindFirstArgs} args - Arguments to find a CommandUnitProduct
     * @example
     * // Get one CommandUnitProduct
     * const commandUnitProduct = await prisma.commandUnitProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandUnitProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommandUnitProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommandUnitProduct'> extends True ? CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>> : CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct | null >, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T> | null >>

    /**
     * Find zero or more CommandUnitProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandUnitProducts
     * const commandUnitProducts = await prisma.commandUnitProduct.findMany()
     * 
     * // Get first 10 CommandUnitProducts
     * const commandUnitProducts = await prisma.commandUnitProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandUnitProductWithIdOnly = await prisma.commandUnitProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandUnitProductFindManyArgs>(
      args?: SelectSubset<T, CommandUnitProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommandUnitProduct>>, PrismaPromise<Array<CommandUnitProductGetPayload<T>>>>

    /**
     * Create a CommandUnitProduct.
     * @param {CommandUnitProductCreateArgs} args - Arguments to create a CommandUnitProduct.
     * @example
     * // Create one CommandUnitProduct
     * const CommandUnitProduct = await prisma.commandUnitProduct.create({
     *   data: {
     *     // ... data to create a CommandUnitProduct
     *   }
     * })
     * 
    **/
    create<T extends CommandUnitProductCreateArgs>(
      args: SelectSubset<T, CommandUnitProductCreateArgs>
    ): CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>>

    /**
     * Create many CommandUnitProducts.
     *     @param {CommandUnitProductCreateManyArgs} args - Arguments to create many CommandUnitProducts.
     *     @example
     *     // Create many CommandUnitProducts
     *     const commandUnitProduct = await prisma.commandUnitProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommandUnitProductCreateManyArgs>(
      args?: SelectSubset<T, CommandUnitProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommandUnitProduct.
     * @param {CommandUnitProductDeleteArgs} args - Arguments to delete one CommandUnitProduct.
     * @example
     * // Delete one CommandUnitProduct
     * const CommandUnitProduct = await prisma.commandUnitProduct.delete({
     *   where: {
     *     // ... filter to delete one CommandUnitProduct
     *   }
     * })
     * 
    **/
    delete<T extends CommandUnitProductDeleteArgs>(
      args: SelectSubset<T, CommandUnitProductDeleteArgs>
    ): CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>>

    /**
     * Update one CommandUnitProduct.
     * @param {CommandUnitProductUpdateArgs} args - Arguments to update one CommandUnitProduct.
     * @example
     * // Update one CommandUnitProduct
     * const commandUnitProduct = await prisma.commandUnitProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandUnitProductUpdateArgs>(
      args: SelectSubset<T, CommandUnitProductUpdateArgs>
    ): CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>>

    /**
     * Delete zero or more CommandUnitProducts.
     * @param {CommandUnitProductDeleteManyArgs} args - Arguments to filter CommandUnitProducts to delete.
     * @example
     * // Delete a few CommandUnitProducts
     * const { count } = await prisma.commandUnitProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandUnitProductDeleteManyArgs>(
      args?: SelectSubset<T, CommandUnitProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandUnitProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandUnitProducts
     * const commandUnitProduct = await prisma.commandUnitProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandUnitProductUpdateManyArgs>(
      args: SelectSubset<T, CommandUnitProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommandUnitProduct.
     * @param {CommandUnitProductUpsertArgs} args - Arguments to update or create a CommandUnitProduct.
     * @example
     * // Update or create a CommandUnitProduct
     * const commandUnitProduct = await prisma.commandUnitProduct.upsert({
     *   create: {
     *     // ... data to create a CommandUnitProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandUnitProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CommandUnitProductUpsertArgs>(
      args: SelectSubset<T, CommandUnitProductUpsertArgs>
    ): CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct>, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T>>>

    /**
     * Count the number of CommandUnitProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductCountArgs} args - Arguments to filter CommandUnitProducts to count.
     * @example
     * // Count the number of CommandUnitProducts
     * const count = await prisma.commandUnitProduct.count({
     *   where: {
     *     // ... the filter for the CommandUnitProducts we want to count
     *   }
     * })
    **/
    count<T extends CommandUnitProductCountArgs>(
      args?: Subset<T, CommandUnitProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandUnitProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandUnitProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandUnitProductAggregateArgs>(args: Subset<T, CommandUnitProductAggregateArgs>): PrismaPromise<GetCommandUnitProductAggregateType<T>>

    /**
     * Group by CommandUnitProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUnitProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandUnitProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandUnitProductGroupByArgs['orderBy'] }
        : { orderBy?: CommandUnitProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandUnitProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandUnitProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandUnitProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommandUnitProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    commandUnit<T extends CommandUnitArgs = {}>(args?: Subset<T, CommandUnitArgs>): CheckSelect<T, Prisma__CommandUnitClient<CommandUnit | null >, Prisma__CommandUnitClient<CommandUnitGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    priceRule<T extends PriceRuleArgs = {}>(args?: Subset<T, PriceRuleArgs>): CheckSelect<T, Prisma__PriceRuleClient<PriceRule | null >, Prisma__PriceRuleClient<PriceRuleGetPayload<T> | null >>;

    commandProducts<T extends CommandProductFindManyArgs = {}>(args?: Subset<T, CommandProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandProduct>>, PrismaPromise<Array<CommandProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommandUnitProduct findUnique
   */
  export type CommandUnitProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * Throw an Error if a CommandUnitProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandUnitProduct to fetch.
     * 
    **/
    where: CommandUnitProductWhereUniqueInput
  }


  /**
   * CommandUnitProduct findFirst
   */
  export type CommandUnitProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * Throw an Error if a CommandUnitProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandUnitProduct to fetch.
     * 
    **/
    where?: CommandUnitProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnitProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandUnitProducts.
     * 
    **/
    cursor?: CommandUnitProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnitProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnitProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandUnitProducts.
     * 
    **/
    distinct?: Enumerable<CommandUnitProductScalarFieldEnum>
  }


  /**
   * CommandUnitProduct findMany
   */
  export type CommandUnitProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * Filter, which CommandUnitProducts to fetch.
     * 
    **/
    where?: CommandUnitProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandUnitProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandUnitProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandUnitProducts.
     * 
    **/
    cursor?: CommandUnitProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandUnitProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandUnitProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommandUnitProductScalarFieldEnum>
  }


  /**
   * CommandUnitProduct create
   */
  export type CommandUnitProductCreateArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * The data needed to create a CommandUnitProduct.
     * 
    **/
    data: XOR<CommandUnitProductCreateInput, CommandUnitProductUncheckedCreateInput>
  }


  /**
   * CommandUnitProduct createMany
   */
  export type CommandUnitProductCreateManyArgs = {
    data: Enumerable<CommandUnitProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommandUnitProduct update
   */
  export type CommandUnitProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * The data needed to update a CommandUnitProduct.
     * 
    **/
    data: XOR<CommandUnitProductUpdateInput, CommandUnitProductUncheckedUpdateInput>
    /**
     * Choose, which CommandUnitProduct to update.
     * 
    **/
    where: CommandUnitProductWhereUniqueInput
  }


  /**
   * CommandUnitProduct updateMany
   */
  export type CommandUnitProductUpdateManyArgs = {
    data: XOR<CommandUnitProductUpdateManyMutationInput, CommandUnitProductUncheckedUpdateManyInput>
    where?: CommandUnitProductWhereInput
  }


  /**
   * CommandUnitProduct upsert
   */
  export type CommandUnitProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * The filter to search for the CommandUnitProduct to update in case it exists.
     * 
    **/
    where: CommandUnitProductWhereUniqueInput
    /**
     * In case the CommandUnitProduct found by the `where` argument doesn't exist, create a new CommandUnitProduct with this data.
     * 
    **/
    create: XOR<CommandUnitProductCreateInput, CommandUnitProductUncheckedCreateInput>
    /**
     * In case the CommandUnitProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommandUnitProductUpdateInput, CommandUnitProductUncheckedUpdateInput>
  }


  /**
   * CommandUnitProduct delete
   */
  export type CommandUnitProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
    /**
     * Filter which CommandUnitProduct to delete.
     * 
    **/
    where: CommandUnitProductWhereUniqueInput
  }


  /**
   * CommandUnitProduct deleteMany
   */
  export type CommandUnitProductDeleteManyArgs = {
    where?: CommandUnitProductWhereInput
  }


  /**
   * CommandUnitProduct without action
   */
  export type CommandUnitProductArgs = {
    /**
     * Select specific fields to fetch from the CommandUnitProduct
     * 
    **/
    select?: CommandUnitProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandUnitProductInclude | null
  }



  /**
   * Model Media
   */


  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    fileDuration: number | null
  }

  export type MediaSumAggregateOutputType = {
    fileDuration: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    filename: string | null
    fileType: string | null
    path: string | null
    fileDuration: number | null
    source: string | null
    userId: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    fileType: string | null
    path: string | null
    fileDuration: number | null
    source: string | null
    userId: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    fileType: number
    path: number
    fileDuration: number
    source: number
    userId: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    fileDuration?: true
  }

  export type MediaSumAggregateInputType = {
    fileDuration?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    path?: true
    fileDuration?: true
    source?: true
    userId?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    path?: true
    fileDuration?: true
    source?: true
    userId?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    fileType?: true
    path?: true
    fileDuration?: true
    source?: true
    userId?: true
    _all?: true
  }

  export type MediaAggregateArgs = {
    /**
     * Filter which Media to aggregate.
     * 
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     * 
    **/
    orderBy?: Enumerable<MediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs = {
    where?: MediaWhereInput
    orderBy?: Enumerable<MediaOrderByWithAggregationInput>
    by: Array<MediaScalarFieldEnum>
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }


  export type MediaGroupByOutputType = {
    id: string
    filename: string
    fileType: string
    path: string
    fileDuration: number | null
    source: string
    userId: string | null
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Promise<
    Array<
      PickArray<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect = {
    id?: boolean
    filename?: boolean
    fileType?: boolean
    path?: boolean
    fileDuration?: boolean
    source?: boolean
    products?: boolean | ProductFindManyArgs
    iconImagesCategories?: boolean | CategoryFindManyArgs
    bannerImagesCategories?: boolean | CategoryFindManyArgs
    marque?: boolean | MarqueFindManyArgs
    pubs?: boolean | PubFindManyArgs
    userShippingAdresses?: boolean | UserShippingAdressFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    receiptMedias?: boolean | ReceiptFindManyArgs
    userId?: boolean
    forUser?: boolean | UserArgs
    _count?: boolean | MediaCountOutputTypeArgs
  }

  export type MediaInclude = {
    products?: boolean | ProductFindManyArgs
    iconImagesCategories?: boolean | CategoryFindManyArgs
    bannerImagesCategories?: boolean | CategoryFindManyArgs
    marque?: boolean | MarqueFindManyArgs
    pubs?: boolean | PubFindManyArgs
    userShippingAdresses?: boolean | UserShippingAdressFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    receiptMedias?: boolean | ReceiptFindManyArgs
    forUser?: boolean | UserArgs
    _count?: boolean | MediaCountOutputTypeArgs
  }

  export type MediaGetPayload<
    S extends boolean | null | undefined | MediaArgs,
    U = keyof S
      > = S extends true
        ? Media
    : S extends undefined
    ? never
    : S extends MediaArgs | MediaFindManyArgs
    ?'include' extends U
    ? Media  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'iconImagesCategories'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'bannerImagesCategories'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'marque'
        ? Array < MarqueGetPayload<S['include'][P]>>  :
        P extends 'pubs'
        ? Array < PubGetPayload<S['include'][P]>>  :
        P extends 'userShippingAdresses'
        ? Array < UserShippingAdressGetPayload<S['include'][P]>>  :
        P extends 'discounts'
        ? Array < DiscountGetPayload<S['include'][P]>>  :
        P extends 'receiptMedias'
        ? Array < ReceiptGetPayload<S['include'][P]>>  :
        P extends 'forUser'
        ? UserGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? MediaCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Media ?Media [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'iconImagesCategories'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'bannerImagesCategories'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'marque'
        ? Array < MarqueGetPayload<S['select'][P]>>  :
        P extends 'pubs'
        ? Array < PubGetPayload<S['select'][P]>>  :
        P extends 'userShippingAdresses'
        ? Array < UserShippingAdressGetPayload<S['select'][P]>>  :
        P extends 'discounts'
        ? Array < DiscountGetPayload<S['select'][P]>>  :
        P extends 'receiptMedias'
        ? Array < ReceiptGetPayload<S['select'][P]>>  :
        P extends 'forUser'
        ? UserGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? MediaCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Media
  : Media


  type MediaCountArgs = Merge<
    Omit<MediaFindManyArgs, 'select' | 'include'> & {
      select?: MediaCountAggregateInputType | true
    }
  >

  export interface MediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Media'> extends True ? CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>> : CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Media'> extends True ? CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>> : CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MediaFindManyArgs>(
      args?: SelectSubset<T, MediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Media>>, PrismaPromise<Array<MediaGetPayload<T>>>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
    **/
    create<T extends MediaCreateArgs>(
      args: SelectSubset<T, MediaCreateArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Create many Media.
     *     @param {MediaCreateManyArgs} args - Arguments to create many Media.
     *     @example
     *     // Create many Media
     *     const media = await prisma.media.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MediaCreateManyArgs>(
      args?: SelectSubset<T, MediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
    **/
    delete<T extends MediaDeleteArgs>(
      args: SelectSubset<T, MediaDeleteArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MediaUpdateArgs>(
      args: SelectSubset<T, MediaUpdateArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MediaDeleteManyArgs>(
      args?: SelectSubset<T, MediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MediaUpdateManyArgs>(
      args: SelectSubset<T, MediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
    **/
    upsert<T extends MediaUpsertArgs>(
      args: SelectSubset<T, MediaUpsertArgs>
    ): CheckSelect<T, Prisma__MediaClient<Media>, Prisma__MediaClient<MediaGetPayload<T>>>

    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    iconImagesCategories<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    bannerImagesCategories<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    marque<T extends MarqueFindManyArgs = {}>(args?: Subset<T, MarqueFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Marque>>, PrismaPromise<Array<MarqueGetPayload<T>>>>;

    pubs<T extends PubFindManyArgs = {}>(args?: Subset<T, PubFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pub>>, PrismaPromise<Array<PubGetPayload<T>>>>;

    userShippingAdresses<T extends UserShippingAdressFindManyArgs = {}>(args?: Subset<T, UserShippingAdressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserShippingAdress>>, PrismaPromise<Array<UserShippingAdressGetPayload<T>>>>;

    discounts<T extends DiscountFindManyArgs = {}>(args?: Subset<T, DiscountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discount>>, PrismaPromise<Array<DiscountGetPayload<T>>>>;

    receiptMedias<T extends ReceiptFindManyArgs = {}>(args?: Subset<T, ReceiptFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Receipt>>, PrismaPromise<Array<ReceiptGetPayload<T>>>>;

    forUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * Throw an Error if a Media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Media to fetch.
     * 
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * Throw an Error if a Media can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Media to fetch.
     * 
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     * 
    **/
    orderBy?: Enumerable<MediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     * 
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     * 
    **/
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * Media findMany
   */
  export type MediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * Filter, which Media to fetch.
     * 
    **/
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     * 
    **/
    orderBy?: Enumerable<MediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     * 
    **/
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MediaScalarFieldEnum>
  }


  /**
   * Media create
   */
  export type MediaCreateArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * The data needed to create a Media.
     * 
    **/
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }


  /**
   * Media createMany
   */
  export type MediaCreateManyArgs = {
    data: Enumerable<MediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Media update
   */
  export type MediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * The data needed to update a Media.
     * 
    **/
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     * 
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs = {
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    where?: MediaWhereInput
  }


  /**
   * Media upsert
   */
  export type MediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * The filter to search for the Media to update in case it exists.
     * 
    **/
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     * 
    **/
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }


  /**
   * Media delete
   */
  export type MediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
    /**
     * Filter which Media to delete.
     * 
    **/
    where: MediaWhereUniqueInput
  }


  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs = {
    where?: MediaWhereInput
  }


  /**
   * Media without action
   */
  export type MediaArgs = {
    /**
     * Select specific fields to fetch from the Media
     * 
    **/
    select?: MediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MediaInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    productWeight: number | null
  }

  export type ProductSumAggregateOutputType = {
    productWeight: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    type: string | null
    productWeight: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sku: string | null
    marqueId: string | null
    variantParentId: string | null
    showProduct: boolean | null
    hasUserDeleted: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    type: string | null
    productWeight: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    sku: string | null
    marqueId: string | null
    variantParentId: string | null
    showProduct: boolean | null
    hasUserDeleted: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    shortDescription: number
    type: number
    productWeight: number
    isPublished: number
    createdAt: number
    updatedAt: number
    sku: number
    marqueId: number
    variantParentId: number
    showProduct: number
    hasUserDeleted: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    productWeight?: true
  }

  export type ProductSumAggregateInputType = {
    productWeight?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    productWeight?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    sku?: true
    marqueId?: true
    variantParentId?: true
    showProduct?: true
    hasUserDeleted?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    productWeight?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    sku?: true
    marqueId?: true
    variantParentId?: true
    showProduct?: true
    hasUserDeleted?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    productWeight?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    sku?: true
    marqueId?: true
    variantParentId?: true
    showProduct?: true
    hasUserDeleted?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    shortDescription: string | null
    type: string
    productWeight: number | null
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    sku: string | null
    marqueId: string | null
    variantParentId: string | null
    showProduct: boolean
    hasUserDeleted: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Promise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    type?: boolean
    productWeight?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sku?: boolean
    marqueId?: boolean
    marque?: boolean | MarqueArgs
    variantParentId?: boolean
    variantParent?: boolean | ProductArgs
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: boolean | ProductAttributeFindManyArgs
    variationMetas?: boolean | ProductAttributeMetaFindManyArgs
    variations?: boolean | ProductFindManyArgs
    categories?: boolean | CategoryFindManyArgs
    shippingZones?: boolean | ShippingZoneFindManyArgs
    tags?: boolean | TagFindManyArgs
    medias?: boolean | MediaFindManyArgs
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    marque?: boolean | MarqueArgs
    variantParent?: boolean | ProductArgs
    productAttributes?: boolean | ProductAttributeFindManyArgs
    variationMetas?: boolean | ProductAttributeMetaFindManyArgs
    variations?: boolean | ProductFindManyArgs
    categories?: boolean | CategoryFindManyArgs
    shippingZones?: boolean | ShippingZoneFindManyArgs
    tags?: boolean | TagFindManyArgs
    medias?: boolean | MediaFindManyArgs
    commandUnitProducts?: boolean | CommandUnitProductFindManyArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    discounts?: boolean | DiscountFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'marque'
        ? MarqueGetPayload<S['include'][P]> | null :
        P extends 'variantParent'
        ? ProductGetPayload<S['include'][P]> | null :
        P extends 'productAttributes'
        ? Array < ProductAttributeGetPayload<S['include'][P]>>  :
        P extends 'variationMetas'
        ? Array < ProductAttributeMetaGetPayload<S['include'][P]>>  :
        P extends 'variations'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'categories'
        ? Array < CategoryGetPayload<S['include'][P]>>  :
        P extends 'shippingZones'
        ? Array < ShippingZoneGetPayload<S['include'][P]>>  :
        P extends 'tags'
        ? Array < TagGetPayload<S['include'][P]>>  :
        P extends 'medias'
        ? Array < MediaGetPayload<S['include'][P]>>  :
        P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['include'][P]>>  :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['include'][P]>>  :
        P extends 'discounts'
        ? Array < DiscountGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Product ?Product [P]
  : 
          P extends 'marque'
        ? MarqueGetPayload<S['select'][P]> | null :
        P extends 'variantParent'
        ? ProductGetPayload<S['select'][P]> | null :
        P extends 'productAttributes'
        ? Array < ProductAttributeGetPayload<S['select'][P]>>  :
        P extends 'variationMetas'
        ? Array < ProductAttributeMetaGetPayload<S['select'][P]>>  :
        P extends 'variations'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'categories'
        ? Array < CategoryGetPayload<S['select'][P]>>  :
        P extends 'shippingZones'
        ? Array < ShippingZoneGetPayload<S['select'][P]>>  :
        P extends 'tags'
        ? Array < TagGetPayload<S['select'][P]>>  :
        P extends 'medias'
        ? Array < MediaGetPayload<S['select'][P]>>  :
        P extends 'commandUnitProducts'
        ? Array < CommandUnitProductGetPayload<S['select'][P]>>  :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['select'][P]>>  :
        P extends 'discounts'
        ? Array < DiscountGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    marque<T extends MarqueArgs = {}>(args?: Subset<T, MarqueArgs>): CheckSelect<T, Prisma__MarqueClient<Marque | null >, Prisma__MarqueClient<MarqueGetPayload<T> | null >>;

    variantParent<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    productAttributes<T extends ProductAttributeFindManyArgs = {}>(args?: Subset<T, ProductAttributeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttribute>>, PrismaPromise<Array<ProductAttributeGetPayload<T>>>>;

    variationMetas<T extends ProductAttributeMetaFindManyArgs = {}>(args?: Subset<T, ProductAttributeMetaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductAttributeMeta>>, PrismaPromise<Array<ProductAttributeMetaGetPayload<T>>>>;

    variations<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    categories<T extends CategoryFindManyArgs = {}>(args?: Subset<T, CategoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>;

    shippingZones<T extends ShippingZoneFindManyArgs = {}>(args?: Subset<T, ShippingZoneFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShippingZone>>, PrismaPromise<Array<ShippingZoneGetPayload<T>>>>;

    tags<T extends TagFindManyArgs = {}>(args?: Subset<T, TagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Tag>>, PrismaPromise<Array<TagGetPayload<T>>>>;

    medias<T extends MediaFindManyArgs = {}>(args?: Subset<T, MediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Media>>, PrismaPromise<Array<MediaGetPayload<T>>>>;

    commandUnitProducts<T extends CommandUnitProductFindManyArgs = {}>(args?: Subset<T, CommandUnitProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandUnitProduct>>, PrismaPromise<Array<CommandUnitProductGetPayload<T>>>>;

    commandProducts<T extends CommandProductFindManyArgs = {}>(args?: Subset<T, CommandProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandProduct>>, PrismaPromise<Array<CommandProductGetPayload<T>>>>;

    discounts<T extends DiscountFindManyArgs = {}>(args?: Subset<T, DiscountFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Discount>>, PrismaPromise<Array<DiscountGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    priority: number | null
  }

  export type NotificationSumAggregateOutputType = {
    priority: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    content: string | null
    title: string | null
    createdAt: Date | null
    context: string | null
    priority: number | null
    canLockScreen: boolean | null
    theme: string | null
    commandId: string | null
    hasUserRead: boolean | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    content: string | null
    title: string | null
    createdAt: Date | null
    context: string | null
    priority: number | null
    canLockScreen: boolean | null
    theme: string | null
    commandId: string | null
    hasUserRead: boolean | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    content: number
    title: number
    createdAt: number
    context: number
    priority: number
    canLockScreen: number
    theme: number
    commandId: number
    hasUserRead: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    priority?: true
  }

  export type NotificationSumAggregateInputType = {
    priority?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    content?: true
    title?: true
    createdAt?: true
    context?: true
    priority?: true
    canLockScreen?: true
    theme?: true
    commandId?: true
    hasUserRead?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    content?: true
    title?: true
    createdAt?: true
    context?: true
    priority?: true
    canLockScreen?: true
    theme?: true
    commandId?: true
    hasUserRead?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    content?: true
    title?: true
    createdAt?: true
    context?: true
    priority?: true
    canLockScreen?: true
    theme?: true
    commandId?: true
    hasUserRead?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    content: string
    title: string
    createdAt: Date
    context: string
    priority: number
    canLockScreen: boolean
    theme: string
    commandId: string | null
    hasUserRead: boolean
    userId: string | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Promise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    id?: boolean
    content?: boolean
    title?: boolean
    createdAt?: boolean
    context?: boolean
    priority?: boolean
    canLockScreen?: boolean
    theme?: boolean
    commandId?: boolean
    hasUserRead?: boolean
    command?: boolean | CommandArgs
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type NotificationInclude = {
    command?: boolean | CommandArgs
    user?: boolean | UserArgs
  }

  export type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationArgs,
    U = keyof S
      > = S extends true
        ? Notification
    : S extends undefined
    ? never
    : S extends NotificationArgs | NotificationFindManyArgs
    ?'include' extends U
    ? Notification  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'command'
        ? CommandGetPayload<S['include'][P]> | null :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Notification ?Notification [P]
  : 
          P extends 'command'
        ? CommandGetPayload<S['select'][P]> | null :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : Notification
  : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    command<T extends CommandArgs = {}>(args?: Subset<T, CommandArgs>): CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    passwordHash: string | null
    email: string | null
    phone: string | null
    accoundActivated: boolean | null
    role: string | null
    currentRole: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    passwordHash: string | null
    email: string | null
    phone: string | null
    accoundActivated: boolean | null
    role: string | null
    currentRole: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    passwordHash: number
    email: number
    phone: number
    accoundActivated: number
    role: number
    currentRole: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    passwordHash?: true
    email?: true
    phone?: true
    accoundActivated?: true
    role?: true
    currentRole?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    passwordHash?: true
    email?: true
    phone?: true
    accoundActivated?: true
    role?: true
    currentRole?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    passwordHash?: true
    email?: true
    phone?: true
    accoundActivated?: true
    role?: true
    currentRole?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated: boolean
    role: string
    currentRole: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    passwordHash?: boolean
    email?: boolean
    phone?: boolean
    profileImage?: boolean | MediaArgs
    accoundActivated?: boolean
    role?: boolean
    currentRole?: boolean
    commands?: boolean | CommandFindManyArgs
    shippingAdress?: boolean | UserShippingAdressFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    profileImage?: boolean | MediaArgs
    commands?: boolean | CommandFindManyArgs
    shippingAdress?: boolean | UserShippingAdressFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'profileImage'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'commands'
        ? Array < CommandGetPayload<S['include'][P]>>  :
        P extends 'shippingAdress'
        ? Array < UserShippingAdressGetPayload<S['include'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'profileImage'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'commands'
        ? Array < CommandGetPayload<S['select'][P]>>  :
        P extends 'shippingAdress'
        ? Array < UserShippingAdressGetPayload<S['select'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    profileImage<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    commands<T extends CommandFindManyArgs = {}>(args?: Subset<T, CommandFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Command>>, PrismaPromise<Array<CommandGetPayload<T>>>>;

    shippingAdress<T extends UserShippingAdressFindManyArgs = {}>(args?: Subset<T, UserShippingAdressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserShippingAdress>>, PrismaPromise<Array<UserShippingAdressGetPayload<T>>>>;

    notifications<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserShippingAdress
   */


  export type AggregateUserShippingAdress = {
    _count: UserShippingAdressCountAggregateOutputType | null
    _min: UserShippingAdressMinAggregateOutputType | null
    _max: UserShippingAdressMaxAggregateOutputType | null
  }

  export type UserShippingAdressMinAggregateOutputType = {
    id: string | null
    shippingZoneId: string | null
    fullName: string | null
    phone: string | null
    alternatePhone: string | null
    adressType: string | null
    quatier: string | null
    hasUserDeleted: boolean | null
    additionalDetails: string | null
    audioFileId: string | null
    forUserId: string | null
  }

  export type UserShippingAdressMaxAggregateOutputType = {
    id: string | null
    shippingZoneId: string | null
    fullName: string | null
    phone: string | null
    alternatePhone: string | null
    adressType: string | null
    quatier: string | null
    hasUserDeleted: boolean | null
    additionalDetails: string | null
    audioFileId: string | null
    forUserId: string | null
  }

  export type UserShippingAdressCountAggregateOutputType = {
    id: number
    shippingZoneId: number
    fullName: number
    phone: number
    alternatePhone: number
    adressType: number
    quatier: number
    hasUserDeleted: number
    additionalDetails: number
    audioFileId: number
    forUserId: number
    _all: number
  }


  export type UserShippingAdressMinAggregateInputType = {
    id?: true
    shippingZoneId?: true
    fullName?: true
    phone?: true
    alternatePhone?: true
    adressType?: true
    quatier?: true
    hasUserDeleted?: true
    additionalDetails?: true
    audioFileId?: true
    forUserId?: true
  }

  export type UserShippingAdressMaxAggregateInputType = {
    id?: true
    shippingZoneId?: true
    fullName?: true
    phone?: true
    alternatePhone?: true
    adressType?: true
    quatier?: true
    hasUserDeleted?: true
    additionalDetails?: true
    audioFileId?: true
    forUserId?: true
  }

  export type UserShippingAdressCountAggregateInputType = {
    id?: true
    shippingZoneId?: true
    fullName?: true
    phone?: true
    alternatePhone?: true
    adressType?: true
    quatier?: true
    hasUserDeleted?: true
    additionalDetails?: true
    audioFileId?: true
    forUserId?: true
    _all?: true
  }

  export type UserShippingAdressAggregateArgs = {
    /**
     * Filter which UserShippingAdress to aggregate.
     * 
    **/
    where?: UserShippingAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShippingAdresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserShippingAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserShippingAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShippingAdresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShippingAdresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserShippingAdresses
    **/
    _count?: true | UserShippingAdressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserShippingAdressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserShippingAdressMaxAggregateInputType
  }

  export type GetUserShippingAdressAggregateType<T extends UserShippingAdressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserShippingAdress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserShippingAdress[P]>
      : GetScalarType<T[P], AggregateUserShippingAdress[P]>
  }




  export type UserShippingAdressGroupByArgs = {
    where?: UserShippingAdressWhereInput
    orderBy?: Enumerable<UserShippingAdressOrderByWithAggregationInput>
    by: Array<UserShippingAdressScalarFieldEnum>
    having?: UserShippingAdressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserShippingAdressCountAggregateInputType | true
    _min?: UserShippingAdressMinAggregateInputType
    _max?: UserShippingAdressMaxAggregateInputType
  }


  export type UserShippingAdressGroupByOutputType = {
    id: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted: boolean
    additionalDetails: string | null
    audioFileId: string | null
    forUserId: string
    _count: UserShippingAdressCountAggregateOutputType | null
    _min: UserShippingAdressMinAggregateOutputType | null
    _max: UserShippingAdressMaxAggregateOutputType | null
  }

  type GetUserShippingAdressGroupByPayload<T extends UserShippingAdressGroupByArgs> = Promise<
    Array<
      PickArray<UserShippingAdressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserShippingAdressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserShippingAdressGroupByOutputType[P]>
            : GetScalarType<T[P], UserShippingAdressGroupByOutputType[P]>
        }
      >
    >


  export type UserShippingAdressSelect = {
    id?: boolean
    shippingZoneId?: boolean
    fullName?: boolean
    phone?: boolean
    alternatePhone?: boolean
    adressType?: boolean
    shippingZone?: boolean | ShippingZoneArgs
    quatier?: boolean
    hasUserDeleted?: boolean
    additionalDetails?: boolean
    audioFileId?: boolean
    audioFile?: boolean | MediaArgs
    forUserId?: boolean
    forUser?: boolean | UserArgs
    commands?: boolean | CommandFindManyArgs
    _count?: boolean | UserShippingAdressCountOutputTypeArgs
  }

  export type UserShippingAdressInclude = {
    shippingZone?: boolean | ShippingZoneArgs
    audioFile?: boolean | MediaArgs
    forUser?: boolean | UserArgs
    commands?: boolean | CommandFindManyArgs
    _count?: boolean | UserShippingAdressCountOutputTypeArgs
  }

  export type UserShippingAdressGetPayload<
    S extends boolean | null | undefined | UserShippingAdressArgs,
    U = keyof S
      > = S extends true
        ? UserShippingAdress
    : S extends undefined
    ? never
    : S extends UserShippingAdressArgs | UserShippingAdressFindManyArgs
    ?'include' extends U
    ? UserShippingAdress  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'shippingZone'
        ? ShippingZoneGetPayload<S['include'][P]> :
        P extends 'audioFile'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'forUser'
        ? UserGetPayload<S['include'][P]> :
        P extends 'commands'
        ? Array < CommandGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserShippingAdressCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserShippingAdress ?UserShippingAdress [P]
  : 
          P extends 'shippingZone'
        ? ShippingZoneGetPayload<S['select'][P]> :
        P extends 'audioFile'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'forUser'
        ? UserGetPayload<S['select'][P]> :
        P extends 'commands'
        ? Array < CommandGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserShippingAdressCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : UserShippingAdress
  : UserShippingAdress


  type UserShippingAdressCountArgs = Merge<
    Omit<UserShippingAdressFindManyArgs, 'select' | 'include'> & {
      select?: UserShippingAdressCountAggregateInputType | true
    }
  >

  export interface UserShippingAdressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserShippingAdress that matches the filter.
     * @param {UserShippingAdressFindUniqueArgs} args - Arguments to find a UserShippingAdress
     * @example
     * // Get one UserShippingAdress
     * const userShippingAdress = await prisma.userShippingAdress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserShippingAdressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserShippingAdressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserShippingAdress'> extends True ? CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>> : CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress | null >, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T> | null >>

    /**
     * Find the first UserShippingAdress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressFindFirstArgs} args - Arguments to find a UserShippingAdress
     * @example
     * // Get one UserShippingAdress
     * const userShippingAdress = await prisma.userShippingAdress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserShippingAdressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserShippingAdressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserShippingAdress'> extends True ? CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>> : CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress | null >, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T> | null >>

    /**
     * Find zero or more UserShippingAdresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserShippingAdresses
     * const userShippingAdresses = await prisma.userShippingAdress.findMany()
     * 
     * // Get first 10 UserShippingAdresses
     * const userShippingAdresses = await prisma.userShippingAdress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userShippingAdressWithIdOnly = await prisma.userShippingAdress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserShippingAdressFindManyArgs>(
      args?: SelectSubset<T, UserShippingAdressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserShippingAdress>>, PrismaPromise<Array<UserShippingAdressGetPayload<T>>>>

    /**
     * Create a UserShippingAdress.
     * @param {UserShippingAdressCreateArgs} args - Arguments to create a UserShippingAdress.
     * @example
     * // Create one UserShippingAdress
     * const UserShippingAdress = await prisma.userShippingAdress.create({
     *   data: {
     *     // ... data to create a UserShippingAdress
     *   }
     * })
     * 
    **/
    create<T extends UserShippingAdressCreateArgs>(
      args: SelectSubset<T, UserShippingAdressCreateArgs>
    ): CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>>

    /**
     * Create many UserShippingAdresses.
     *     @param {UserShippingAdressCreateManyArgs} args - Arguments to create many UserShippingAdresses.
     *     @example
     *     // Create many UserShippingAdresses
     *     const userShippingAdress = await prisma.userShippingAdress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserShippingAdressCreateManyArgs>(
      args?: SelectSubset<T, UserShippingAdressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserShippingAdress.
     * @param {UserShippingAdressDeleteArgs} args - Arguments to delete one UserShippingAdress.
     * @example
     * // Delete one UserShippingAdress
     * const UserShippingAdress = await prisma.userShippingAdress.delete({
     *   where: {
     *     // ... filter to delete one UserShippingAdress
     *   }
     * })
     * 
    **/
    delete<T extends UserShippingAdressDeleteArgs>(
      args: SelectSubset<T, UserShippingAdressDeleteArgs>
    ): CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>>

    /**
     * Update one UserShippingAdress.
     * @param {UserShippingAdressUpdateArgs} args - Arguments to update one UserShippingAdress.
     * @example
     * // Update one UserShippingAdress
     * const userShippingAdress = await prisma.userShippingAdress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserShippingAdressUpdateArgs>(
      args: SelectSubset<T, UserShippingAdressUpdateArgs>
    ): CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>>

    /**
     * Delete zero or more UserShippingAdresses.
     * @param {UserShippingAdressDeleteManyArgs} args - Arguments to filter UserShippingAdresses to delete.
     * @example
     * // Delete a few UserShippingAdresses
     * const { count } = await prisma.userShippingAdress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserShippingAdressDeleteManyArgs>(
      args?: SelectSubset<T, UserShippingAdressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserShippingAdresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserShippingAdresses
     * const userShippingAdress = await prisma.userShippingAdress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserShippingAdressUpdateManyArgs>(
      args: SelectSubset<T, UserShippingAdressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserShippingAdress.
     * @param {UserShippingAdressUpsertArgs} args - Arguments to update or create a UserShippingAdress.
     * @example
     * // Update or create a UserShippingAdress
     * const userShippingAdress = await prisma.userShippingAdress.upsert({
     *   create: {
     *     // ... data to create a UserShippingAdress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserShippingAdress we want to update
     *   }
     * })
    **/
    upsert<T extends UserShippingAdressUpsertArgs>(
      args: SelectSubset<T, UserShippingAdressUpsertArgs>
    ): CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress>, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T>>>

    /**
     * Count the number of UserShippingAdresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressCountArgs} args - Arguments to filter UserShippingAdresses to count.
     * @example
     * // Count the number of UserShippingAdresses
     * const count = await prisma.userShippingAdress.count({
     *   where: {
     *     // ... the filter for the UserShippingAdresses we want to count
     *   }
     * })
    **/
    count<T extends UserShippingAdressCountArgs>(
      args?: Subset<T, UserShippingAdressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserShippingAdressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserShippingAdress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserShippingAdressAggregateArgs>(args: Subset<T, UserShippingAdressAggregateArgs>): PrismaPromise<GetUserShippingAdressAggregateType<T>>

    /**
     * Group by UserShippingAdress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserShippingAdressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserShippingAdressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserShippingAdressGroupByArgs['orderBy'] }
        : { orderBy?: UserShippingAdressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserShippingAdressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserShippingAdressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserShippingAdress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserShippingAdressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    shippingZone<T extends ShippingZoneArgs = {}>(args?: Subset<T, ShippingZoneArgs>): CheckSelect<T, Prisma__ShippingZoneClient<ShippingZone | null >, Prisma__ShippingZoneClient<ShippingZoneGetPayload<T> | null >>;

    audioFile<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    forUser<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    commands<T extends CommandFindManyArgs = {}>(args?: Subset<T, CommandFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Command>>, PrismaPromise<Array<CommandGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserShippingAdress findUnique
   */
  export type UserShippingAdressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * Throw an Error if a UserShippingAdress can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserShippingAdress to fetch.
     * 
    **/
    where: UserShippingAdressWhereUniqueInput
  }


  /**
   * UserShippingAdress findFirst
   */
  export type UserShippingAdressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * Throw an Error if a UserShippingAdress can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserShippingAdress to fetch.
     * 
    **/
    where?: UserShippingAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShippingAdresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserShippingAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserShippingAdresses.
     * 
    **/
    cursor?: UserShippingAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShippingAdresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShippingAdresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserShippingAdresses.
     * 
    **/
    distinct?: Enumerable<UserShippingAdressScalarFieldEnum>
  }


  /**
   * UserShippingAdress findMany
   */
  export type UserShippingAdressFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * Filter, which UserShippingAdresses to fetch.
     * 
    **/
    where?: UserShippingAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserShippingAdresses to fetch.
     * 
    **/
    orderBy?: Enumerable<UserShippingAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserShippingAdresses.
     * 
    **/
    cursor?: UserShippingAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserShippingAdresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserShippingAdresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserShippingAdressScalarFieldEnum>
  }


  /**
   * UserShippingAdress create
   */
  export type UserShippingAdressCreateArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * The data needed to create a UserShippingAdress.
     * 
    **/
    data: XOR<UserShippingAdressCreateInput, UserShippingAdressUncheckedCreateInput>
  }


  /**
   * UserShippingAdress createMany
   */
  export type UserShippingAdressCreateManyArgs = {
    data: Enumerable<UserShippingAdressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserShippingAdress update
   */
  export type UserShippingAdressUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * The data needed to update a UserShippingAdress.
     * 
    **/
    data: XOR<UserShippingAdressUpdateInput, UserShippingAdressUncheckedUpdateInput>
    /**
     * Choose, which UserShippingAdress to update.
     * 
    **/
    where: UserShippingAdressWhereUniqueInput
  }


  /**
   * UserShippingAdress updateMany
   */
  export type UserShippingAdressUpdateManyArgs = {
    data: XOR<UserShippingAdressUpdateManyMutationInput, UserShippingAdressUncheckedUpdateManyInput>
    where?: UserShippingAdressWhereInput
  }


  /**
   * UserShippingAdress upsert
   */
  export type UserShippingAdressUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * The filter to search for the UserShippingAdress to update in case it exists.
     * 
    **/
    where: UserShippingAdressWhereUniqueInput
    /**
     * In case the UserShippingAdress found by the `where` argument doesn't exist, create a new UserShippingAdress with this data.
     * 
    **/
    create: XOR<UserShippingAdressCreateInput, UserShippingAdressUncheckedCreateInput>
    /**
     * In case the UserShippingAdress was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserShippingAdressUpdateInput, UserShippingAdressUncheckedUpdateInput>
  }


  /**
   * UserShippingAdress delete
   */
  export type UserShippingAdressDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
    /**
     * Filter which UserShippingAdress to delete.
     * 
    **/
    where: UserShippingAdressWhereUniqueInput
  }


  /**
   * UserShippingAdress deleteMany
   */
  export type UserShippingAdressDeleteManyArgs = {
    where?: UserShippingAdressWhereInput
  }


  /**
   * UserShippingAdress without action
   */
  export type UserShippingAdressArgs = {
    /**
     * Select specific fields to fetch from the UserShippingAdress
     * 
    **/
    select?: UserShippingAdressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserShippingAdressInclude | null
  }



  /**
   * Model Command
   */


  export type AggregateCommand = {
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  export type CommandAvgAggregateOutputType = {
    totalPrice: number | null
    orderId: number | null
  }

  export type CommandSumAggregateOutputType = {
    totalPrice: number | null
    orderId: number | null
  }

  export type CommandMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    totalPrice: number | null
    orderId: number | null
    archived: boolean | null
    delivered: boolean | null
    status: string | null
    orderedById: string | null
    hasUserCanceled: boolean | null
    hasUserDeleted: boolean | null
    shippingAdressId: string | null
    receiptId: string | null
    appliedDiscountId: string | null
  }

  export type CommandMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    totalPrice: number | null
    orderId: number | null
    archived: boolean | null
    delivered: boolean | null
    status: string | null
    orderedById: string | null
    hasUserCanceled: boolean | null
    hasUserDeleted: boolean | null
    shippingAdressId: string | null
    receiptId: string | null
    appliedDiscountId: string | null
  }

  export type CommandCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    totalPrice: number
    orderId: number
    archived: number
    delivered: number
    status: number
    orderedById: number
    hasUserCanceled: number
    hasUserDeleted: number
    shippingAdressId: number
    receiptId: number
    appliedDiscountId: number
    _all: number
  }


  export type CommandAvgAggregateInputType = {
    totalPrice?: true
    orderId?: true
  }

  export type CommandSumAggregateInputType = {
    totalPrice?: true
    orderId?: true
  }

  export type CommandMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    totalPrice?: true
    orderId?: true
    archived?: true
    delivered?: true
    status?: true
    orderedById?: true
    hasUserCanceled?: true
    hasUserDeleted?: true
    shippingAdressId?: true
    receiptId?: true
    appliedDiscountId?: true
  }

  export type CommandMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    totalPrice?: true
    orderId?: true
    archived?: true
    delivered?: true
    status?: true
    orderedById?: true
    hasUserCanceled?: true
    hasUserDeleted?: true
    shippingAdressId?: true
    receiptId?: true
    appliedDiscountId?: true
  }

  export type CommandCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    totalPrice?: true
    orderId?: true
    archived?: true
    delivered?: true
    status?: true
    orderedById?: true
    hasUserCanceled?: true
    hasUserDeleted?: true
    shippingAdressId?: true
    receiptId?: true
    appliedDiscountId?: true
    _all?: true
  }

  export type CommandAggregateArgs = {
    /**
     * Filter which Command to aggregate.
     * 
    **/
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commands
    **/
    _count?: true | CommandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandMaxAggregateInputType
  }

  export type GetCommandAggregateType<T extends CommandAggregateArgs> = {
        [P in keyof T & keyof AggregateCommand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommand[P]>
      : GetScalarType<T[P], AggregateCommand[P]>
  }




  export type CommandGroupByArgs = {
    where?: CommandWhereInput
    orderBy?: Enumerable<CommandOrderByWithAggregationInput>
    by: Array<CommandScalarFieldEnum>
    having?: CommandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandCountAggregateInputType | true
    _avg?: CommandAvgAggregateInputType
    _sum?: CommandSumAggregateInputType
    _min?: CommandMinAggregateInputType
    _max?: CommandMaxAggregateInputType
  }


  export type CommandGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    totalPrice: number
    orderId: number
    archived: boolean | null
    delivered: boolean
    status: string
    orderedById: string
    hasUserCanceled: boolean
    hasUserDeleted: boolean
    shippingAdressId: string | null
    receiptId: string
    appliedDiscountId: string | null
    _count: CommandCountAggregateOutputType | null
    _avg: CommandAvgAggregateOutputType | null
    _sum: CommandSumAggregateOutputType | null
    _min: CommandMinAggregateOutputType | null
    _max: CommandMaxAggregateOutputType | null
  }

  type GetCommandGroupByPayload<T extends CommandGroupByArgs> = Promise<
    Array<
      PickArray<CommandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandGroupByOutputType[P]>
            : GetScalarType<T[P], CommandGroupByOutputType[P]>
        }
      >
    >


  export type CommandSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    totalPrice?: boolean
    orderId?: boolean
    archived?: boolean
    delivered?: boolean
    status?: boolean
    orderedById?: boolean
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy?: boolean | UserArgs
    shippingAdressId?: boolean
    shippingAdress?: boolean | UserShippingAdressArgs
    receiptId?: boolean
    receipt?: boolean | ReceiptArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    appliedDiscountId?: boolean
    appliedDiscount?: boolean | DiscountArgs
    _count?: boolean | CommandCountOutputTypeArgs
  }

  export type CommandInclude = {
    orderedBy?: boolean | UserArgs
    shippingAdress?: boolean | UserShippingAdressArgs
    receipt?: boolean | ReceiptArgs
    commandProducts?: boolean | CommandProductFindManyArgs
    notifications?: boolean | NotificationFindManyArgs
    appliedDiscount?: boolean | DiscountArgs
    _count?: boolean | CommandCountOutputTypeArgs
  }

  export type CommandGetPayload<
    S extends boolean | null | undefined | CommandArgs,
    U = keyof S
      > = S extends true
        ? Command
    : S extends undefined
    ? never
    : S extends CommandArgs | CommandFindManyArgs
    ?'include' extends U
    ? Command  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'orderedBy'
        ? UserGetPayload<S['include'][P]> :
        P extends 'shippingAdress'
        ? UserShippingAdressGetPayload<S['include'][P]> | null :
        P extends 'receipt'
        ? ReceiptGetPayload<S['include'][P]> :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['include'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'appliedDiscount'
        ? DiscountGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? CommandCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Command ?Command [P]
  : 
          P extends 'orderedBy'
        ? UserGetPayload<S['select'][P]> :
        P extends 'shippingAdress'
        ? UserShippingAdressGetPayload<S['select'][P]> | null :
        P extends 'receipt'
        ? ReceiptGetPayload<S['select'][P]> :
        P extends 'commandProducts'
        ? Array < CommandProductGetPayload<S['select'][P]>>  :
        P extends 'notifications'
        ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'appliedDiscount'
        ? DiscountGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? CommandCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Command
  : Command


  type CommandCountArgs = Merge<
    Omit<CommandFindManyArgs, 'select' | 'include'> & {
      select?: CommandCountAggregateInputType | true
    }
  >

  export interface CommandDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Command that matches the filter.
     * @param {CommandFindUniqueArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommandFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Command'> extends True ? CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>> : CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>

    /**
     * Find the first Command that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindFirstArgs} args - Arguments to find a Command
     * @example
     * // Get one Command
     * const command = await prisma.command.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommandFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Command'> extends True ? CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>> : CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>

    /**
     * Find zero or more Commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commands
     * const commands = await prisma.command.findMany()
     * 
     * // Get first 10 Commands
     * const commands = await prisma.command.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandWithIdOnly = await prisma.command.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandFindManyArgs>(
      args?: SelectSubset<T, CommandFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Command>>, PrismaPromise<Array<CommandGetPayload<T>>>>

    /**
     * Create a Command.
     * @param {CommandCreateArgs} args - Arguments to create a Command.
     * @example
     * // Create one Command
     * const Command = await prisma.command.create({
     *   data: {
     *     // ... data to create a Command
     *   }
     * })
     * 
    **/
    create<T extends CommandCreateArgs>(
      args: SelectSubset<T, CommandCreateArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Create many Commands.
     *     @param {CommandCreateManyArgs} args - Arguments to create many Commands.
     *     @example
     *     // Create many Commands
     *     const command = await prisma.command.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommandCreateManyArgs>(
      args?: SelectSubset<T, CommandCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Command.
     * @param {CommandDeleteArgs} args - Arguments to delete one Command.
     * @example
     * // Delete one Command
     * const Command = await prisma.command.delete({
     *   where: {
     *     // ... filter to delete one Command
     *   }
     * })
     * 
    **/
    delete<T extends CommandDeleteArgs>(
      args: SelectSubset<T, CommandDeleteArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Update one Command.
     * @param {CommandUpdateArgs} args - Arguments to update one Command.
     * @example
     * // Update one Command
     * const command = await prisma.command.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandUpdateArgs>(
      args: SelectSubset<T, CommandUpdateArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Delete zero or more Commands.
     * @param {CommandDeleteManyArgs} args - Arguments to filter Commands to delete.
     * @example
     * // Delete a few Commands
     * const { count } = await prisma.command.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandDeleteManyArgs>(
      args?: SelectSubset<T, CommandDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commands
     * const command = await prisma.command.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandUpdateManyArgs>(
      args: SelectSubset<T, CommandUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Command.
     * @param {CommandUpsertArgs} args - Arguments to update or create a Command.
     * @example
     * // Update or create a Command
     * const command = await prisma.command.upsert({
     *   create: {
     *     // ... data to create a Command
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Command we want to update
     *   }
     * })
    **/
    upsert<T extends CommandUpsertArgs>(
      args: SelectSubset<T, CommandUpsertArgs>
    ): CheckSelect<T, Prisma__CommandClient<Command>, Prisma__CommandClient<CommandGetPayload<T>>>

    /**
     * Count the number of Commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandCountArgs} args - Arguments to filter Commands to count.
     * @example
     * // Count the number of Commands
     * const count = await prisma.command.count({
     *   where: {
     *     // ... the filter for the Commands we want to count
     *   }
     * })
    **/
    count<T extends CommandCountArgs>(
      args?: Subset<T, CommandCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandAggregateArgs>(args: Subset<T, CommandAggregateArgs>): PrismaPromise<GetCommandAggregateType<T>>

    /**
     * Group by Command.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandGroupByArgs['orderBy'] }
        : { orderBy?: CommandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Command.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommandClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orderedBy<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    shippingAdress<T extends UserShippingAdressArgs = {}>(args?: Subset<T, UserShippingAdressArgs>): CheckSelect<T, Prisma__UserShippingAdressClient<UserShippingAdress | null >, Prisma__UserShippingAdressClient<UserShippingAdressGetPayload<T> | null >>;

    receipt<T extends ReceiptArgs = {}>(args?: Subset<T, ReceiptArgs>): CheckSelect<T, Prisma__ReceiptClient<Receipt | null >, Prisma__ReceiptClient<ReceiptGetPayload<T> | null >>;

    commandProducts<T extends CommandProductFindManyArgs = {}>(args?: Subset<T, CommandProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CommandProduct>>, PrismaPromise<Array<CommandProductGetPayload<T>>>>;

    notifications<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>;

    appliedDiscount<T extends DiscountArgs = {}>(args?: Subset<T, DiscountArgs>): CheckSelect<T, Prisma__DiscountClient<Discount | null >, Prisma__DiscountClient<DiscountGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Command findUnique
   */
  export type CommandFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * Throw an Error if a Command can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Command to fetch.
     * 
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command findFirst
   */
  export type CommandFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * Throw an Error if a Command can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Command to fetch.
     * 
    **/
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commands.
     * 
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commands.
     * 
    **/
    distinct?: Enumerable<CommandScalarFieldEnum>
  }


  /**
   * Command findMany
   */
  export type CommandFindManyArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * Filter, which Commands to fetch.
     * 
    **/
    where?: CommandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commands to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commands.
     * 
    **/
    cursor?: CommandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commands from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commands.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommandScalarFieldEnum>
  }


  /**
   * Command create
   */
  export type CommandCreateArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * The data needed to create a Command.
     * 
    **/
    data: XOR<CommandCreateInput, CommandUncheckedCreateInput>
  }


  /**
   * Command createMany
   */
  export type CommandCreateManyArgs = {
    data: Enumerable<CommandCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Command update
   */
  export type CommandUpdateArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * The data needed to update a Command.
     * 
    **/
    data: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
    /**
     * Choose, which Command to update.
     * 
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command updateMany
   */
  export type CommandUpdateManyArgs = {
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyInput>
    where?: CommandWhereInput
  }


  /**
   * Command upsert
   */
  export type CommandUpsertArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * The filter to search for the Command to update in case it exists.
     * 
    **/
    where: CommandWhereUniqueInput
    /**
     * In case the Command found by the `where` argument doesn't exist, create a new Command with this data.
     * 
    **/
    create: XOR<CommandCreateInput, CommandUncheckedCreateInput>
    /**
     * In case the Command was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommandUpdateInput, CommandUncheckedUpdateInput>
  }


  /**
   * Command delete
   */
  export type CommandDeleteArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
    /**
     * Filter which Command to delete.
     * 
    **/
    where: CommandWhereUniqueInput
  }


  /**
   * Command deleteMany
   */
  export type CommandDeleteManyArgs = {
    where?: CommandWhereInput
  }


  /**
   * Command without action
   */
  export type CommandArgs = {
    /**
     * Select specific fields to fetch from the Command
     * 
    **/
    select?: CommandSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandInclude | null
  }



  /**
   * Model CommandProduct
   */


  export type AggregateCommandProduct = {
    _count: CommandProductCountAggregateOutputType | null
    _avg: CommandProductAvgAggregateOutputType | null
    _sum: CommandProductSumAggregateOutputType | null
    _min: CommandProductMinAggregateOutputType | null
    _max: CommandProductMaxAggregateOutputType | null
  }

  export type CommandProductAvgAggregateOutputType = {
    quantite: number | null
  }

  export type CommandProductSumAggregateOutputType = {
    quantite: number | null
  }

  export type CommandProductMinAggregateOutputType = {
    id: string | null
    productId: string | null
    hasUserDeleted: boolean | null
    commandUnitProductId: string | null
    quantite: number | null
    commandId: string | null
    hasCustomerConfirmShipping: boolean | null
    hasAgentConfirmShipping: boolean | null
  }

  export type CommandProductMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    hasUserDeleted: boolean | null
    commandUnitProductId: string | null
    quantite: number | null
    commandId: string | null
    hasCustomerConfirmShipping: boolean | null
    hasAgentConfirmShipping: boolean | null
  }

  export type CommandProductCountAggregateOutputType = {
    id: number
    productId: number
    hasUserDeleted: number
    commandUnitProductId: number
    quantite: number
    commandId: number
    hasCustomerConfirmShipping: number
    hasAgentConfirmShipping: number
    _all: number
  }


  export type CommandProductAvgAggregateInputType = {
    quantite?: true
  }

  export type CommandProductSumAggregateInputType = {
    quantite?: true
  }

  export type CommandProductMinAggregateInputType = {
    id?: true
    productId?: true
    hasUserDeleted?: true
    commandUnitProductId?: true
    quantite?: true
    commandId?: true
    hasCustomerConfirmShipping?: true
    hasAgentConfirmShipping?: true
  }

  export type CommandProductMaxAggregateInputType = {
    id?: true
    productId?: true
    hasUserDeleted?: true
    commandUnitProductId?: true
    quantite?: true
    commandId?: true
    hasCustomerConfirmShipping?: true
    hasAgentConfirmShipping?: true
  }

  export type CommandProductCountAggregateInputType = {
    id?: true
    productId?: true
    hasUserDeleted?: true
    commandUnitProductId?: true
    quantite?: true
    commandId?: true
    hasCustomerConfirmShipping?: true
    hasAgentConfirmShipping?: true
    _all?: true
  }

  export type CommandProductAggregateArgs = {
    /**
     * Filter which CommandProduct to aggregate.
     * 
    **/
    where?: CommandProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommandProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandProducts
    **/
    _count?: true | CommandProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandProductMaxAggregateInputType
  }

  export type GetCommandProductAggregateType<T extends CommandProductAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandProduct[P]>
      : GetScalarType<T[P], AggregateCommandProduct[P]>
  }




  export type CommandProductGroupByArgs = {
    where?: CommandProductWhereInput
    orderBy?: Enumerable<CommandProductOrderByWithAggregationInput>
    by: Array<CommandProductScalarFieldEnum>
    having?: CommandProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandProductCountAggregateInputType | true
    _avg?: CommandProductAvgAggregateInputType
    _sum?: CommandProductSumAggregateInputType
    _min?: CommandProductMinAggregateInputType
    _max?: CommandProductMaxAggregateInputType
  }


  export type CommandProductGroupByOutputType = {
    id: string
    productId: string
    hasUserDeleted: boolean
    commandUnitProductId: string
    quantite: number
    commandId: string
    hasCustomerConfirmShipping: boolean
    hasAgentConfirmShipping: boolean
    _count: CommandProductCountAggregateOutputType | null
    _avg: CommandProductAvgAggregateOutputType | null
    _sum: CommandProductSumAggregateOutputType | null
    _min: CommandProductMinAggregateOutputType | null
    _max: CommandProductMaxAggregateOutputType | null
  }

  type GetCommandProductGroupByPayload<T extends CommandProductGroupByArgs> = Promise<
    Array<
      PickArray<CommandProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandProductGroupByOutputType[P]>
            : GetScalarType<T[P], CommandProductGroupByOutputType[P]>
        }
      >
    >


  export type CommandProductSelect = {
    id?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    hasUserDeleted?: boolean
    commandUnitProductId?: boolean
    commandUnitProduct?: boolean | CommandUnitProductArgs
    quantite?: boolean
    commandId?: boolean
    command?: boolean | CommandArgs
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductInclude = {
    product?: boolean | ProductArgs
    commandUnitProduct?: boolean | CommandUnitProductArgs
    command?: boolean | CommandArgs
  }

  export type CommandProductGetPayload<
    S extends boolean | null | undefined | CommandProductArgs,
    U = keyof S
      > = S extends true
        ? CommandProduct
    : S extends undefined
    ? never
    : S extends CommandProductArgs | CommandProductFindManyArgs
    ?'include' extends U
    ? CommandProduct  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'commandUnitProduct'
        ? CommandUnitProductGetPayload<S['include'][P]> | null :
        P extends 'command'
        ? CommandGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CommandProduct ?CommandProduct [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'commandUnitProduct'
        ? CommandUnitProductGetPayload<S['select'][P]> | null :
        P extends 'command'
        ? CommandGetPayload<S['select'][P]> : never
  } 
    : CommandProduct
  : CommandProduct


  type CommandProductCountArgs = Merge<
    Omit<CommandProductFindManyArgs, 'select' | 'include'> & {
      select?: CommandProductCountAggregateInputType | true
    }
  >

  export interface CommandProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CommandProduct that matches the filter.
     * @param {CommandProductFindUniqueArgs} args - Arguments to find a CommandProduct
     * @example
     * // Get one CommandProduct
     * const commandProduct = await prisma.commandProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommandProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommandProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommandProduct'> extends True ? CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>> : CheckSelect<T, Prisma__CommandProductClient<CommandProduct | null >, Prisma__CommandProductClient<CommandProductGetPayload<T> | null >>

    /**
     * Find the first CommandProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductFindFirstArgs} args - Arguments to find a CommandProduct
     * @example
     * // Get one CommandProduct
     * const commandProduct = await prisma.commandProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommandProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommandProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommandProduct'> extends True ? CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>> : CheckSelect<T, Prisma__CommandProductClient<CommandProduct | null >, Prisma__CommandProductClient<CommandProductGetPayload<T> | null >>

    /**
     * Find zero or more CommandProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandProducts
     * const commandProducts = await prisma.commandProduct.findMany()
     * 
     * // Get first 10 CommandProducts
     * const commandProducts = await prisma.commandProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandProductWithIdOnly = await prisma.commandProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommandProductFindManyArgs>(
      args?: SelectSubset<T, CommandProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CommandProduct>>, PrismaPromise<Array<CommandProductGetPayload<T>>>>

    /**
     * Create a CommandProduct.
     * @param {CommandProductCreateArgs} args - Arguments to create a CommandProduct.
     * @example
     * // Create one CommandProduct
     * const CommandProduct = await prisma.commandProduct.create({
     *   data: {
     *     // ... data to create a CommandProduct
     *   }
     * })
     * 
    **/
    create<T extends CommandProductCreateArgs>(
      args: SelectSubset<T, CommandProductCreateArgs>
    ): CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>>

    /**
     * Create many CommandProducts.
     *     @param {CommandProductCreateManyArgs} args - Arguments to create many CommandProducts.
     *     @example
     *     // Create many CommandProducts
     *     const commandProduct = await prisma.commandProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommandProductCreateManyArgs>(
      args?: SelectSubset<T, CommandProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CommandProduct.
     * @param {CommandProductDeleteArgs} args - Arguments to delete one CommandProduct.
     * @example
     * // Delete one CommandProduct
     * const CommandProduct = await prisma.commandProduct.delete({
     *   where: {
     *     // ... filter to delete one CommandProduct
     *   }
     * })
     * 
    **/
    delete<T extends CommandProductDeleteArgs>(
      args: SelectSubset<T, CommandProductDeleteArgs>
    ): CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>>

    /**
     * Update one CommandProduct.
     * @param {CommandProductUpdateArgs} args - Arguments to update one CommandProduct.
     * @example
     * // Update one CommandProduct
     * const commandProduct = await prisma.commandProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommandProductUpdateArgs>(
      args: SelectSubset<T, CommandProductUpdateArgs>
    ): CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>>

    /**
     * Delete zero or more CommandProducts.
     * @param {CommandProductDeleteManyArgs} args - Arguments to filter CommandProducts to delete.
     * @example
     * // Delete a few CommandProducts
     * const { count } = await prisma.commandProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommandProductDeleteManyArgs>(
      args?: SelectSubset<T, CommandProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandProducts
     * const commandProduct = await prisma.commandProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommandProductUpdateManyArgs>(
      args: SelectSubset<T, CommandProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CommandProduct.
     * @param {CommandProductUpsertArgs} args - Arguments to update or create a CommandProduct.
     * @example
     * // Update or create a CommandProduct
     * const commandProduct = await prisma.commandProduct.upsert({
     *   create: {
     *     // ... data to create a CommandProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandProduct we want to update
     *   }
     * })
    **/
    upsert<T extends CommandProductUpsertArgs>(
      args: SelectSubset<T, CommandProductUpsertArgs>
    ): CheckSelect<T, Prisma__CommandProductClient<CommandProduct>, Prisma__CommandProductClient<CommandProductGetPayload<T>>>

    /**
     * Count the number of CommandProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductCountArgs} args - Arguments to filter CommandProducts to count.
     * @example
     * // Count the number of CommandProducts
     * const count = await prisma.commandProduct.count({
     *   where: {
     *     // ... the filter for the CommandProducts we want to count
     *   }
     * })
    **/
    count<T extends CommandProductCountArgs>(
      args?: Subset<T, CommandProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandProductAggregateArgs>(args: Subset<T, CommandProductAggregateArgs>): PrismaPromise<GetCommandProductAggregateType<T>>

    /**
     * Group by CommandProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandProductGroupByArgs['orderBy'] }
        : { orderBy?: CommandProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommandProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    commandUnitProduct<T extends CommandUnitProductArgs = {}>(args?: Subset<T, CommandUnitProductArgs>): CheckSelect<T, Prisma__CommandUnitProductClient<CommandUnitProduct | null >, Prisma__CommandUnitProductClient<CommandUnitProductGetPayload<T> | null >>;

    command<T extends CommandArgs = {}>(args?: Subset<T, CommandArgs>): CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CommandProduct findUnique
   */
  export type CommandProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * Throw an Error if a CommandProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandProduct to fetch.
     * 
    **/
    where: CommandProductWhereUniqueInput
  }


  /**
   * CommandProduct findFirst
   */
  export type CommandProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * Throw an Error if a CommandProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CommandProduct to fetch.
     * 
    **/
    where?: CommandProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandProducts.
     * 
    **/
    cursor?: CommandProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandProducts.
     * 
    **/
    distinct?: Enumerable<CommandProductScalarFieldEnum>
  }


  /**
   * CommandProduct findMany
   */
  export type CommandProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * Filter, which CommandProducts to fetch.
     * 
    **/
    where?: CommandProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<CommandProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandProducts.
     * 
    **/
    cursor?: CommandProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommandProductScalarFieldEnum>
  }


  /**
   * CommandProduct create
   */
  export type CommandProductCreateArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * The data needed to create a CommandProduct.
     * 
    **/
    data: XOR<CommandProductCreateInput, CommandProductUncheckedCreateInput>
  }


  /**
   * CommandProduct createMany
   */
  export type CommandProductCreateManyArgs = {
    data: Enumerable<CommandProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommandProduct update
   */
  export type CommandProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * The data needed to update a CommandProduct.
     * 
    **/
    data: XOR<CommandProductUpdateInput, CommandProductUncheckedUpdateInput>
    /**
     * Choose, which CommandProduct to update.
     * 
    **/
    where: CommandProductWhereUniqueInput
  }


  /**
   * CommandProduct updateMany
   */
  export type CommandProductUpdateManyArgs = {
    data: XOR<CommandProductUpdateManyMutationInput, CommandProductUncheckedUpdateManyInput>
    where?: CommandProductWhereInput
  }


  /**
   * CommandProduct upsert
   */
  export type CommandProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * The filter to search for the CommandProduct to update in case it exists.
     * 
    **/
    where: CommandProductWhereUniqueInput
    /**
     * In case the CommandProduct found by the `where` argument doesn't exist, create a new CommandProduct with this data.
     * 
    **/
    create: XOR<CommandProductCreateInput, CommandProductUncheckedCreateInput>
    /**
     * In case the CommandProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommandProductUpdateInput, CommandProductUncheckedUpdateInput>
  }


  /**
   * CommandProduct delete
   */
  export type CommandProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
    /**
     * Filter which CommandProduct to delete.
     * 
    **/
    where: CommandProductWhereUniqueInput
  }


  /**
   * CommandProduct deleteMany
   */
  export type CommandProductDeleteManyArgs = {
    where?: CommandProductWhereInput
  }


  /**
   * CommandProduct without action
   */
  export type CommandProductArgs = {
    /**
     * Select specific fields to fetch from the CommandProduct
     * 
    **/
    select?: CommandProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommandProductInclude | null
  }



  /**
   * Model Receipt
   */


  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    amount: number | null
  }

  export type ReceiptSumAggregateOutputType = {
    amount: number | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: string | null
    amount: number | null
    createdAt: Date | null
    hasUserDeleted: boolean | null
    paidAt: Date | null
    isPaid: boolean | null
    outPaymentId: string | null
    receiptMediaId: string | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    createdAt: Date | null
    hasUserDeleted: boolean | null
    paidAt: Date | null
    isPaid: boolean | null
    outPaymentId: string | null
    receiptMediaId: string | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    amount: number
    createdAt: number
    hasUserDeleted: number
    paidAt: number
    isPaid: number
    outPaymentId: number
    outPaymentDetails: number
    receiptMetas: number
    receiptMediaId: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    amount?: true
  }

  export type ReceiptSumAggregateInputType = {
    amount?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    amount?: true
    createdAt?: true
    hasUserDeleted?: true
    paidAt?: true
    isPaid?: true
    outPaymentId?: true
    receiptMediaId?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    amount?: true
    createdAt?: true
    hasUserDeleted?: true
    paidAt?: true
    isPaid?: true
    outPaymentId?: true
    receiptMediaId?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    amount?: true
    createdAt?: true
    hasUserDeleted?: true
    paidAt?: true
    isPaid?: true
    outPaymentId?: true
    outPaymentDetails?: true
    receiptMetas?: true
    receiptMediaId?: true
    _all?: true
  }

  export type ReceiptAggregateArgs = {
    /**
     * Filter which Receipt to aggregate.
     * 
    **/
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     * 
    **/
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs = {
    where?: ReceiptWhereInput
    orderBy?: Enumerable<ReceiptOrderByWithAggregationInput>
    by: Array<ReceiptScalarFieldEnum>
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }


  export type ReceiptGroupByOutputType = {
    id: string
    amount: number
    createdAt: Date
    hasUserDeleted: boolean
    paidAt: Date | null
    isPaid: boolean
    outPaymentId: string | null
    outPaymentDetails: JsonValue | null
    receiptMetas: JsonValue
    receiptMediaId: string | null
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Promise<
    Array<
      PickArray<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect = {
    id?: boolean
    amount?: boolean
    createdAt?: boolean
    hasUserDeleted?: boolean
    paidAt?: boolean
    isPaid?: boolean
    outPaymentId?: boolean
    outPaymentDetails?: boolean
    receiptMetas?: boolean
    receiptMediaId?: boolean
    receiptMedia?: boolean | MediaArgs
    command?: boolean | CommandArgs
  }

  export type ReceiptInclude = {
    receiptMedia?: boolean | MediaArgs
    command?: boolean | CommandArgs
  }

  export type ReceiptGetPayload<
    S extends boolean | null | undefined | ReceiptArgs,
    U = keyof S
      > = S extends true
        ? Receipt
    : S extends undefined
    ? never
    : S extends ReceiptArgs | ReceiptFindManyArgs
    ?'include' extends U
    ? Receipt  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'receiptMedia'
        ? MediaGetPayload<S['include'][P]> | null :
        P extends 'command'
        ? CommandGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Receipt ?Receipt [P]
  : 
          P extends 'receiptMedia'
        ? MediaGetPayload<S['select'][P]> | null :
        P extends 'command'
        ? CommandGetPayload<S['select'][P]> | null : never
  } 
    : Receipt
  : Receipt


  type ReceiptCountArgs = Merge<
    Omit<ReceiptFindManyArgs, 'select' | 'include'> & {
      select?: ReceiptCountAggregateInputType | true
    }
  >

  export interface ReceiptDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceiptFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReceiptFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Receipt'> extends True ? CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>> : CheckSelect<T, Prisma__ReceiptClient<Receipt | null >, Prisma__ReceiptClient<ReceiptGetPayload<T> | null >>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceiptFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReceiptFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Receipt'> extends True ? CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>> : CheckSelect<T, Prisma__ReceiptClient<Receipt | null >, Prisma__ReceiptClient<ReceiptGetPayload<T> | null >>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceiptFindManyArgs>(
      args?: SelectSubset<T, ReceiptFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Receipt>>, PrismaPromise<Array<ReceiptGetPayload<T>>>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
    **/
    create<T extends ReceiptCreateArgs>(
      args: SelectSubset<T, ReceiptCreateArgs>
    ): CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>>

    /**
     * Create many Receipts.
     *     @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     *     @example
     *     // Create many Receipts
     *     const receipt = await prisma.receipt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReceiptCreateManyArgs>(
      args?: SelectSubset<T, ReceiptCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
    **/
    delete<T extends ReceiptDeleteArgs>(
      args: SelectSubset<T, ReceiptDeleteArgs>
    ): CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceiptUpdateArgs>(
      args: SelectSubset<T, ReceiptUpdateArgs>
    ): CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceiptDeleteManyArgs>(
      args?: SelectSubset<T, ReceiptDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceiptUpdateManyArgs>(
      args: SelectSubset<T, ReceiptUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
    **/
    upsert<T extends ReceiptUpsertArgs>(
      args: SelectSubset<T, ReceiptUpsertArgs>
    ): CheckSelect<T, Prisma__ReceiptClient<Receipt>, Prisma__ReceiptClient<ReceiptGetPayload<T>>>

    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReceiptClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    receiptMedia<T extends MediaArgs = {}>(args?: Subset<T, MediaArgs>): CheckSelect<T, Prisma__MediaClient<Media | null >, Prisma__MediaClient<MediaGetPayload<T> | null >>;

    command<T extends CommandArgs = {}>(args?: Subset<T, CommandArgs>): CheckSelect<T, Prisma__CommandClient<Command | null >, Prisma__CommandClient<CommandGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * Throw an Error if a Receipt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Receipt to fetch.
     * 
    **/
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * Throw an Error if a Receipt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Receipt to fetch.
     * 
    **/
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     * 
    **/
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     * 
    **/
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     * 
    **/
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }


  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * Filter, which Receipts to fetch.
     * 
    **/
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     * 
    **/
    orderBy?: Enumerable<ReceiptOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     * 
    **/
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReceiptScalarFieldEnum>
  }


  /**
   * Receipt create
   */
  export type ReceiptCreateArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * The data needed to create a Receipt.
     * 
    **/
    data: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }


  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs = {
    data: Enumerable<ReceiptCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * The data needed to update a Receipt.
     * 
    **/
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     * 
    **/
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs = {
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    where?: ReceiptWhereInput
  }


  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     * 
    **/
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     * 
    **/
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }


  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
    /**
     * Filter which Receipt to delete.
     * 
    **/
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs = {
    where?: ReceiptWhereInput
  }


  /**
   * Receipt without action
   */
  export type ReceiptArgs = {
    /**
     * Select specific fields to fetch from the Receipt
     * 
    **/
    select?: ReceiptSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReceiptInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const VerificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    otpCode: 'otpCode',
    email: 'email',
    tel: 'tel',
    context: 'context',
    pwdRecoverKey: 'pwdRecoverKey',
    hasBeenVerified: 'hasBeenVerified',
    expireAt: 'expireAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    iconImageId: 'iconImageId',
    bannerImageId: 'bannerImageId'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const MarqueScalarFieldEnum: {
    id: 'id',
    imageId: 'imageId',
    name: 'name',
    categoryId: 'categoryId'
  };

  export type MarqueScalarFieldEnum = (typeof MarqueScalarFieldEnum)[keyof typeof MarqueScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bannerImageId: 'bannerImageId',
    discountType: 'discountType',
    discountNature: 'discountNature',
    discountCode: 'discountCode',
    discount: 'discount',
    startAt: 'startAt',
    endAt: 'endAt',
    inCartProductMin: 'inCartProductMin',
    inCartProductMax: 'inCartProductMax',
    commandAmountMin: 'commandAmountMin',
    commandAmountMax: 'commandAmountMax',
    description: 'description'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const PriceRuleScalarFieldEnum: {
    id: 'id',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    amountPercent: 'amountPercent'
  };

  export type PriceRuleScalarFieldEnum = (typeof PriceRuleScalarFieldEnum)[keyof typeof PriceRuleScalarFieldEnum]


  export const PubScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bannerImageId: 'bannerImageId',
    link: 'link',
    description: 'description',
    startAt: 'startAt',
    endAt: 'endAt',
    forDiscountId: 'forDiscountId'
  };

  export type PubScalarFieldEnum = (typeof PubScalarFieldEnum)[keyof typeof PubScalarFieldEnum]


  export const ShippingZoneScalarFieldEnum: {
    id: 'id',
    townName: 'townName',
    townCode: 'townCode',
    baseShippingPrice: 'baseShippingPrice'
  };

  export type ShippingZoneScalarFieldEnum = (typeof ShippingZoneScalarFieldEnum)[keyof typeof ShippingZoneScalarFieldEnum]


  export const ShippingRuleScalarFieldEnum: {
    id: 'id',
    ruleName: 'ruleName',
    rule: 'rule',
    description: 'description'
  };

  export type ShippingRuleScalarFieldEnum = (typeof ShippingRuleScalarFieldEnum)[keyof typeof ShippingRuleScalarFieldEnum]


  export const GeneralMetaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    value: 'value'
  };

  export type GeneralMetaScalarFieldEnum = (typeof GeneralMetaScalarFieldEnum)[keyof typeof GeneralMetaScalarFieldEnum]


  export const ProductAttributeMetaScalarFieldEnum: {
    id: 'id',
    attributeId: 'attributeId',
    name: 'name',
    value: 'value'
  };

  export type ProductAttributeMetaScalarFieldEnum = (typeof ProductAttributeMetaScalarFieldEnum)[keyof typeof ProductAttributeMetaScalarFieldEnum]


  export const ProductAttributeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    global: 'global',
    categoryId: 'categoryId',
    onlyForProductId: 'onlyForProductId'
  };

  export type ProductAttributeScalarFieldEnum = (typeof ProductAttributeScalarFieldEnum)[keyof typeof ProductAttributeScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CommandUnitScalarFieldEnum: {
    id: 'id',
    title: 'title',
    shortCode: 'shortCode'
  };

  export type CommandUnitScalarFieldEnum = (typeof CommandUnitScalarFieldEnum)[keyof typeof CommandUnitScalarFieldEnum]


  export const CommandUnitProductScalarFieldEnum: {
    id: 'id',
    commandUnitId: 'commandUnitId',
    productId: 'productId',
    isDefault: 'isDefault',
    unitPrice: 'unitPrice',
    priceRuleId: 'priceRuleId'
  };

  export type CommandUnitProductScalarFieldEnum = (typeof CommandUnitProductScalarFieldEnum)[keyof typeof CommandUnitProductScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    fileType: 'fileType',
    path: 'path',
    fileDuration: 'fileDuration',
    source: 'source',
    userId: 'userId'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    type: 'type',
    productWeight: 'productWeight',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sku: 'sku',
    marqueId: 'marqueId',
    variantParentId: 'variantParentId',
    showProduct: 'showProduct',
    hasUserDeleted: 'hasUserDeleted'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    content: 'content',
    title: 'title',
    createdAt: 'createdAt',
    context: 'context',
    priority: 'priority',
    canLockScreen: 'canLockScreen',
    theme: 'theme',
    commandId: 'commandId',
    hasUserRead: 'hasUserRead',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    passwordHash: 'passwordHash',
    email: 'email',
    phone: 'phone',
    accoundActivated: 'accoundActivated',
    role: 'role',
    currentRole: 'currentRole'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserShippingAdressScalarFieldEnum: {
    id: 'id',
    shippingZoneId: 'shippingZoneId',
    fullName: 'fullName',
    phone: 'phone',
    alternatePhone: 'alternatePhone',
    adressType: 'adressType',
    quatier: 'quatier',
    hasUserDeleted: 'hasUserDeleted',
    additionalDetails: 'additionalDetails',
    audioFileId: 'audioFileId',
    forUserId: 'forUserId'
  };

  export type UserShippingAdressScalarFieldEnum = (typeof UserShippingAdressScalarFieldEnum)[keyof typeof UserShippingAdressScalarFieldEnum]


  export const CommandScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    totalPrice: 'totalPrice',
    orderId: 'orderId',
    archived: 'archived',
    delivered: 'delivered',
    status: 'status',
    orderedById: 'orderedById',
    hasUserCanceled: 'hasUserCanceled',
    hasUserDeleted: 'hasUserDeleted',
    shippingAdressId: 'shippingAdressId',
    receiptId: 'receiptId',
    appliedDiscountId: 'appliedDiscountId'
  };

  export type CommandScalarFieldEnum = (typeof CommandScalarFieldEnum)[keyof typeof CommandScalarFieldEnum]


  export const CommandProductScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    hasUserDeleted: 'hasUserDeleted',
    commandUnitProductId: 'commandUnitProductId',
    quantite: 'quantite',
    commandId: 'commandId',
    hasCustomerConfirmShipping: 'hasCustomerConfirmShipping',
    hasAgentConfirmShipping: 'hasAgentConfirmShipping'
  };

  export type CommandProductScalarFieldEnum = (typeof CommandProductScalarFieldEnum)[keyof typeof CommandProductScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    createdAt: 'createdAt',
    hasUserDeleted: 'hasUserDeleted',
    paidAt: 'paidAt',
    isPaid: 'isPaid',
    outPaymentId: 'outPaymentId',
    outPaymentDetails: 'outPaymentDetails',
    receiptMetas: 'receiptMetas',
    receiptMediaId: 'receiptMediaId'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: 'JsonNull'
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull'
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type VerificationWhereInput = {
    AND?: Enumerable<VerificationWhereInput>
    OR?: Enumerable<VerificationWhereInput>
    NOT?: Enumerable<VerificationWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    otpCode?: StringFilter | string
    email?: StringNullableFilter | string | null
    tel?: StringNullableFilter | string | null
    context?: StringFilter | string
    pwdRecoverKey?: StringNullableFilter | string | null
    hasBeenVerified?: BoolFilter | boolean
    expireAt?: DateTimeFilter | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    otpCode?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    context?: SortOrder
    pwdRecoverKey?: SortOrder
    hasBeenVerified?: SortOrder
    expireAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = {
    id?: string
  }

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    otpCode?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    context?: SortOrder
    pwdRecoverKey?: SortOrder
    hasBeenVerified?: SortOrder
    expireAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VerificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<VerificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VerificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    otpCode?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    tel?: StringNullableWithAggregatesFilter | string | null
    context?: StringWithAggregatesFilter | string
    pwdRecoverKey?: StringNullableWithAggregatesFilter | string | null
    hasBeenVerified?: BoolWithAggregatesFilter | boolean
    expireAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    parentId?: StringNullableFilter | string | null
    parent?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    iconImageId?: StringNullableFilter | string | null
    bannerImageId?: StringNullableFilter | string | null
    iconImage?: XOR<MediaRelationFilter, MediaWhereInput> | null
    bannerImage?: XOR<MediaRelationFilter, MediaWhereInput> | null
    marques?: MarqueListRelationFilter
    products?: ProductListRelationFilter
    children?: CategoryListRelationFilter
    attributes?: ProductAttributeListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    iconImageId?: SortOrder
    bannerImageId?: SortOrder
    iconImage?: MediaOrderByWithRelationInput
    bannerImage?: MediaOrderByWithRelationInput
    marques?: MarqueOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    children?: CategoryOrderByRelationAggregateInput
    attributes?: ProductAttributeOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    iconImageId?: SortOrder
    bannerImageId?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    parentId?: StringNullableWithAggregatesFilter | string | null
    iconImageId?: StringNullableWithAggregatesFilter | string | null
    bannerImageId?: StringNullableWithAggregatesFilter | string | null
  }

  export type MarqueWhereInput = {
    AND?: Enumerable<MarqueWhereInput>
    OR?: Enumerable<MarqueWhereInput>
    NOT?: Enumerable<MarqueWhereInput>
    id?: StringFilter | string
    imageId?: StringNullableFilter | string | null
    image?: XOR<MediaRelationFilter, MediaWhereInput> | null
    name?: StringFilter | string
    categoryId?: StringFilter | string
    category?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type MarqueOrderByWithRelationInput = {
    id?: SortOrder
    imageId?: SortOrder
    image?: MediaOrderByWithRelationInput
    name?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type MarqueWhereUniqueInput = {
    id?: string
  }

  export type MarqueOrderByWithAggregationInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    _count?: MarqueCountOrderByAggregateInput
    _max?: MarqueMaxOrderByAggregateInput
    _min?: MarqueMinOrderByAggregateInput
  }

  export type MarqueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarqueScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarqueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarqueScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    imageId?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    categoryId?: StringWithAggregatesFilter | string
  }

  export type DiscountWhereInput = {
    AND?: Enumerable<DiscountWhereInput>
    OR?: Enumerable<DiscountWhereInput>
    NOT?: Enumerable<DiscountWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    bannerImageId?: StringNullableFilter | string | null
    bannerImage?: XOR<MediaRelationFilter, MediaWhereInput> | null
    discountType?: StringFilter | string
    discountNature?: StringFilter | string
    discountCode?: StringFilter | string
    discount?: IntFilter | number
    startAt?: DateTimeFilter | Date | string
    endAt?: DateTimeFilter | Date | string
    inCartProductMin?: IntNullableFilter | number | null
    inCartProductMax?: IntNullableFilter | number | null
    commandAmountMin?: IntNullableFilter | number | null
    commandAmountMax?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
    command?: CommandListRelationFilter
    pubs?: PubListRelationFilter
    product?: ProductListRelationFilter
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    bannerImage?: MediaOrderByWithRelationInput
    discountType?: SortOrder
    discountNature?: SortOrder
    discountCode?: SortOrder
    discount?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
    description?: SortOrder
    command?: CommandOrderByRelationAggregateInput
    pubs?: PubOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
  }

  export type DiscountWhereUniqueInput = {
    id?: string
  }

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    discountType?: SortOrder
    discountNature?: SortOrder
    discountCode?: SortOrder
    discount?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
    description?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    bannerImageId?: StringNullableWithAggregatesFilter | string | null
    discountType?: StringWithAggregatesFilter | string
    discountNature?: StringWithAggregatesFilter | string
    discountCode?: StringWithAggregatesFilter | string
    discount?: IntWithAggregatesFilter | number
    startAt?: DateTimeWithAggregatesFilter | Date | string
    endAt?: DateTimeWithAggregatesFilter | Date | string
    inCartProductMin?: IntNullableWithAggregatesFilter | number | null
    inCartProductMax?: IntNullableWithAggregatesFilter | number | null
    commandAmountMin?: IntNullableWithAggregatesFilter | number | null
    commandAmountMax?: IntNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type PriceRuleWhereInput = {
    AND?: Enumerable<PriceRuleWhereInput>
    OR?: Enumerable<PriceRuleWhereInput>
    NOT?: Enumerable<PriceRuleWhereInput>
    id?: StringFilter | string
    minPrice?: IntFilter | number
    maxPrice?: IntNullableFilter | number | null
    amountPercent?: IntFilter | number
    commandUnitProducts?: CommandUnitProductListRelationFilter
  }

  export type PriceRuleOrderByWithRelationInput = {
    id?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
    commandUnitProducts?: CommandUnitProductOrderByRelationAggregateInput
  }

  export type PriceRuleWhereUniqueInput = {
    id?: string
  }

  export type PriceRuleOrderByWithAggregationInput = {
    id?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
    _count?: PriceRuleCountOrderByAggregateInput
    _avg?: PriceRuleAvgOrderByAggregateInput
    _max?: PriceRuleMaxOrderByAggregateInput
    _min?: PriceRuleMinOrderByAggregateInput
    _sum?: PriceRuleSumOrderByAggregateInput
  }

  export type PriceRuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceRuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceRuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceRuleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    minPrice?: IntWithAggregatesFilter | number
    maxPrice?: IntNullableWithAggregatesFilter | number | null
    amountPercent?: IntWithAggregatesFilter | number
  }

  export type PubWhereInput = {
    AND?: Enumerable<PubWhereInput>
    OR?: Enumerable<PubWhereInput>
    NOT?: Enumerable<PubWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    bannerImageId?: StringNullableFilter | string | null
    bannerImage?: XOR<MediaRelationFilter, MediaWhereInput> | null
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    startAt?: DateTimeFilter | Date | string
    endAt?: DateTimeFilter | Date | string
    forDiscountId?: StringNullableFilter | string | null
    forDiscount?: XOR<DiscountRelationFilter, DiscountWhereInput> | null
  }

  export type PubOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    bannerImage?: MediaOrderByWithRelationInput
    link?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    forDiscountId?: SortOrder
    forDiscount?: DiscountOrderByWithRelationInput
  }

  export type PubWhereUniqueInput = {
    id?: string
  }

  export type PubOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    forDiscountId?: SortOrder
    _count?: PubCountOrderByAggregateInput
    _max?: PubMaxOrderByAggregateInput
    _min?: PubMinOrderByAggregateInput
  }

  export type PubScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PubScalarWhereWithAggregatesInput>
    OR?: Enumerable<PubScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PubScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    bannerImageId?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    startAt?: DateTimeWithAggregatesFilter | Date | string
    endAt?: DateTimeWithAggregatesFilter | Date | string
    forDiscountId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ShippingZoneWhereInput = {
    AND?: Enumerable<ShippingZoneWhereInput>
    OR?: Enumerable<ShippingZoneWhereInput>
    NOT?: Enumerable<ShippingZoneWhereInput>
    id?: StringFilter | string
    townName?: StringFilter | string
    townCode?: StringFilter | string
    baseShippingPrice?: IntFilter | number
    userShippingAdress?: UserShippingAdressListRelationFilter
    products?: ProductListRelationFilter
  }

  export type ShippingZoneOrderByWithRelationInput = {
    id?: SortOrder
    townName?: SortOrder
    townCode?: SortOrder
    baseShippingPrice?: SortOrder
    userShippingAdress?: UserShippingAdressOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type ShippingZoneWhereUniqueInput = {
    id?: string
  }

  export type ShippingZoneOrderByWithAggregationInput = {
    id?: SortOrder
    townName?: SortOrder
    townCode?: SortOrder
    baseShippingPrice?: SortOrder
    _count?: ShippingZoneCountOrderByAggregateInput
    _avg?: ShippingZoneAvgOrderByAggregateInput
    _max?: ShippingZoneMaxOrderByAggregateInput
    _min?: ShippingZoneMinOrderByAggregateInput
    _sum?: ShippingZoneSumOrderByAggregateInput
  }

  export type ShippingZoneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShippingZoneScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShippingZoneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShippingZoneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    townName?: StringWithAggregatesFilter | string
    townCode?: StringWithAggregatesFilter | string
    baseShippingPrice?: IntWithAggregatesFilter | number
  }

  export type ShippingRuleWhereInput = {
    AND?: Enumerable<ShippingRuleWhereInput>
    OR?: Enumerable<ShippingRuleWhereInput>
    NOT?: Enumerable<ShippingRuleWhereInput>
    id?: StringFilter | string
    ruleName?: StringFilter | string
    rule?: JsonFilter
    description?: StringFilter | string
  }

  export type ShippingRuleOrderByWithRelationInput = {
    id?: SortOrder
    ruleName?: SortOrder
    rule?: SortOrder
    description?: SortOrder
  }

  export type ShippingRuleWhereUniqueInput = {
    id?: string
  }

  export type ShippingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    ruleName?: SortOrder
    rule?: SortOrder
    description?: SortOrder
    _count?: ShippingRuleCountOrderByAggregateInput
    _max?: ShippingRuleMaxOrderByAggregateInput
    _min?: ShippingRuleMinOrderByAggregateInput
  }

  export type ShippingRuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShippingRuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShippingRuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShippingRuleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    ruleName?: StringWithAggregatesFilter | string
    rule?: JsonWithAggregatesFilter
    description?: StringWithAggregatesFilter | string
  }

  export type GeneralMetaWhereInput = {
    AND?: Enumerable<GeneralMetaWhereInput>
    OR?: Enumerable<GeneralMetaWhereInput>
    NOT?: Enumerable<GeneralMetaWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    key?: StringFilter | string
    value?: JsonFilter
  }

  export type GeneralMetaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type GeneralMetaWhereUniqueInput = {
    id?: string
  }

  export type GeneralMetaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: GeneralMetaCountOrderByAggregateInput
    _max?: GeneralMetaMaxOrderByAggregateInput
    _min?: GeneralMetaMinOrderByAggregateInput
  }

  export type GeneralMetaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GeneralMetaScalarWhereWithAggregatesInput>
    OR?: Enumerable<GeneralMetaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GeneralMetaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    value?: JsonWithAggregatesFilter
  }

  export type ProductAttributeMetaWhereInput = {
    AND?: Enumerable<ProductAttributeMetaWhereInput>
    OR?: Enumerable<ProductAttributeMetaWhereInput>
    NOT?: Enumerable<ProductAttributeMetaWhereInput>
    id?: StringFilter | string
    attributeId?: StringFilter | string
    attribute?: XOR<ProductAttributeRelationFilter, ProductAttributeWhereInput>
    name?: StringFilter | string
    value?: JsonFilter
    products?: ProductListRelationFilter
  }

  export type ProductAttributeMetaOrderByWithRelationInput = {
    id?: SortOrder
    attributeId?: SortOrder
    attribute?: ProductAttributeOrderByWithRelationInput
    name?: SortOrder
    value?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ProductAttributeMetaWhereUniqueInput = {
    id?: string
  }

  export type ProductAttributeMetaOrderByWithAggregationInput = {
    id?: SortOrder
    attributeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    _count?: ProductAttributeMetaCountOrderByAggregateInput
    _max?: ProductAttributeMetaMaxOrderByAggregateInput
    _min?: ProductAttributeMetaMinOrderByAggregateInput
  }

  export type ProductAttributeMetaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductAttributeMetaScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductAttributeMetaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductAttributeMetaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    attributeId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    value?: JsonWithAggregatesFilter
  }

  export type ProductAttributeWhereInput = {
    AND?: Enumerable<ProductAttributeWhereInput>
    OR?: Enumerable<ProductAttributeWhereInput>
    NOT?: Enumerable<ProductAttributeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringNullableFilter | string | null
    global?: BoolFilter | boolean
    metas?: ProductAttributeMetaListRelationFilter
    categoryId?: StringNullableFilter | string | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput> | null
    onlyForProductId?: StringNullableFilter | string | null
    onlyForProduct?: XOR<ProductRelationFilter, ProductWhereInput> | null
  }

  export type ProductAttributeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    global?: SortOrder
    metas?: ProductAttributeMetaOrderByRelationAggregateInput
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    onlyForProductId?: SortOrder
    onlyForProduct?: ProductOrderByWithRelationInput
  }

  export type ProductAttributeWhereUniqueInput = {
    id?: string
  }

  export type ProductAttributeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    global?: SortOrder
    categoryId?: SortOrder
    onlyForProductId?: SortOrder
    _count?: ProductAttributeCountOrderByAggregateInput
    _max?: ProductAttributeMaxOrderByAggregateInput
    _min?: ProductAttributeMinOrderByAggregateInput
  }

  export type ProductAttributeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductAttributeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductAttributeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductAttributeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    global?: BoolWithAggregatesFilter | boolean
    categoryId?: StringNullableWithAggregatesFilter | string | null
    onlyForProductId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TagWhereInput = {
    AND?: Enumerable<TagWhereInput>
    OR?: Enumerable<TagWhereInput>
    NOT?: Enumerable<TagWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    products?: ProductListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = {
    id?: string
  }

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TagScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
  }

  export type CommandUnitWhereInput = {
    AND?: Enumerable<CommandUnitWhereInput>
    OR?: Enumerable<CommandUnitWhereInput>
    NOT?: Enumerable<CommandUnitWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    shortCode?: StringFilter | string
    commandUnitProducts?: CommandUnitProductListRelationFilter
  }

  export type CommandUnitOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    shortCode?: SortOrder
    commandUnitProducts?: CommandUnitProductOrderByRelationAggregateInput
  }

  export type CommandUnitWhereUniqueInput = {
    id?: string
  }

  export type CommandUnitOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    shortCode?: SortOrder
    _count?: CommandUnitCountOrderByAggregateInput
    _max?: CommandUnitMaxOrderByAggregateInput
    _min?: CommandUnitMinOrderByAggregateInput
  }

  export type CommandUnitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommandUnitScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommandUnitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommandUnitScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    shortCode?: StringWithAggregatesFilter | string
  }

  export type CommandUnitProductWhereInput = {
    AND?: Enumerable<CommandUnitProductWhereInput>
    OR?: Enumerable<CommandUnitProductWhereInput>
    NOT?: Enumerable<CommandUnitProductWhereInput>
    id?: StringFilter | string
    commandUnitId?: StringFilter | string
    commandUnit?: XOR<CommandUnitRelationFilter, CommandUnitWhereInput>
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    isDefault?: BoolFilter | boolean
    unitPrice?: IntFilter | number
    priceRuleId?: StringFilter | string
    priceRule?: XOR<PriceRuleRelationFilter, PriceRuleWhereInput>
    commandProducts?: CommandProductListRelationFilter
  }

  export type CommandUnitProductOrderByWithRelationInput = {
    id?: SortOrder
    commandUnitId?: SortOrder
    commandUnit?: CommandUnitOrderByWithRelationInput
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    isDefault?: SortOrder
    unitPrice?: SortOrder
    priceRuleId?: SortOrder
    priceRule?: PriceRuleOrderByWithRelationInput
    commandProducts?: CommandProductOrderByRelationAggregateInput
  }

  export type CommandUnitProductWhereUniqueInput = {
    id?: string
  }

  export type CommandUnitProductOrderByWithAggregationInput = {
    id?: SortOrder
    commandUnitId?: SortOrder
    productId?: SortOrder
    isDefault?: SortOrder
    unitPrice?: SortOrder
    priceRuleId?: SortOrder
    _count?: CommandUnitProductCountOrderByAggregateInput
    _avg?: CommandUnitProductAvgOrderByAggregateInput
    _max?: CommandUnitProductMaxOrderByAggregateInput
    _min?: CommandUnitProductMinOrderByAggregateInput
    _sum?: CommandUnitProductSumOrderByAggregateInput
  }

  export type CommandUnitProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommandUnitProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommandUnitProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommandUnitProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    commandUnitId?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    isDefault?: BoolWithAggregatesFilter | boolean
    unitPrice?: IntWithAggregatesFilter | number
    priceRuleId?: StringWithAggregatesFilter | string
  }

  export type MediaWhereInput = {
    AND?: Enumerable<MediaWhereInput>
    OR?: Enumerable<MediaWhereInput>
    NOT?: Enumerable<MediaWhereInput>
    id?: StringFilter | string
    filename?: StringFilter | string
    fileType?: StringFilter | string
    path?: StringFilter | string
    fileDuration?: FloatNullableFilter | number | null
    source?: StringFilter | string
    products?: ProductListRelationFilter
    iconImagesCategories?: CategoryListRelationFilter
    bannerImagesCategories?: CategoryListRelationFilter
    marque?: MarqueListRelationFilter
    pubs?: PubListRelationFilter
    userShippingAdresses?: UserShippingAdressListRelationFilter
    discounts?: DiscountListRelationFilter
    receiptMedias?: ReceiptListRelationFilter
    userId?: StringNullableFilter | string | null
    forUser?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    fileDuration?: SortOrder
    source?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    iconImagesCategories?: CategoryOrderByRelationAggregateInput
    bannerImagesCategories?: CategoryOrderByRelationAggregateInput
    marque?: MarqueOrderByRelationAggregateInput
    pubs?: PubOrderByRelationAggregateInput
    userShippingAdresses?: UserShippingAdressOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
    receiptMedias?: ReceiptOrderByRelationAggregateInput
    userId?: SortOrder
    forUser?: UserOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    fileDuration?: SortOrder
    source?: SortOrder
    userId?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<MediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MediaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    filename?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    path?: StringWithAggregatesFilter | string
    fileDuration?: FloatNullableWithAggregatesFilter | number | null
    source?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    shortDescription?: StringNullableFilter | string | null
    type?: StringFilter | string
    productWeight?: IntNullableFilter | number | null
    isPublished?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sku?: StringNullableFilter | string | null
    marqueId?: StringNullableFilter | string | null
    marque?: XOR<MarqueRelationFilter, MarqueWhereInput> | null
    variantParentId?: StringNullableFilter | string | null
    variantParent?: XOR<ProductRelationFilter, ProductWhereInput> | null
    showProduct?: BoolFilter | boolean
    hasUserDeleted?: BoolFilter | boolean
    productAttributes?: ProductAttributeListRelationFilter
    variationMetas?: ProductAttributeMetaListRelationFilter
    variations?: ProductListRelationFilter
    categories?: CategoryListRelationFilter
    shippingZones?: ShippingZoneListRelationFilter
    tags?: TagListRelationFilter
    medias?: MediaListRelationFilter
    commandUnitProducts?: CommandUnitProductListRelationFilter
    commandProducts?: CommandProductListRelationFilter
    discounts?: DiscountListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    productWeight?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sku?: SortOrder
    marqueId?: SortOrder
    marque?: MarqueOrderByWithRelationInput
    variantParentId?: SortOrder
    variantParent?: ProductOrderByWithRelationInput
    showProduct?: SortOrder
    hasUserDeleted?: SortOrder
    productAttributes?: ProductAttributeOrderByRelationAggregateInput
    variationMetas?: ProductAttributeMetaOrderByRelationAggregateInput
    variations?: ProductOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    shippingZones?: ShippingZoneOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    medias?: MediaOrderByRelationAggregateInput
    commandUnitProducts?: CommandUnitProductOrderByRelationAggregateInput
    commandProducts?: CommandProductOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    productWeight?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sku?: SortOrder
    marqueId?: SortOrder
    variantParentId?: SortOrder
    showProduct?: SortOrder
    hasUserDeleted?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    shortDescription?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    productWeight?: IntNullableWithAggregatesFilter | number | null
    isPublished?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    sku?: StringNullableWithAggregatesFilter | string | null
    marqueId?: StringNullableWithAggregatesFilter | string | null
    variantParentId?: StringNullableWithAggregatesFilter | string | null
    showProduct?: BoolWithAggregatesFilter | boolean
    hasUserDeleted?: BoolWithAggregatesFilter | boolean
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    title?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    context?: StringFilter | string
    priority?: IntFilter | number
    canLockScreen?: BoolFilter | boolean
    theme?: StringFilter | string
    commandId?: StringNullableFilter | string | null
    hasUserRead?: BoolFilter | boolean
    command?: XOR<CommandRelationFilter, CommandWhereInput> | null
    userId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    context?: SortOrder
    priority?: SortOrder
    canLockScreen?: SortOrder
    theme?: SortOrder
    commandId?: SortOrder
    hasUserRead?: SortOrder
    command?: CommandOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = {
    id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    context?: SortOrder
    priority?: SortOrder
    canLockScreen?: SortOrder
    theme?: SortOrder
    commandId?: SortOrder
    hasUserRead?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    context?: StringWithAggregatesFilter | string
    priority?: IntWithAggregatesFilter | number
    canLockScreen?: BoolWithAggregatesFilter | boolean
    theme?: StringWithAggregatesFilter | string
    commandId?: StringNullableWithAggregatesFilter | string | null
    hasUserRead?: BoolWithAggregatesFilter | boolean
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    passwordHash?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    profileImage?: XOR<MediaRelationFilter, MediaWhereInput> | null
    accoundActivated?: BoolFilter | boolean
    role?: StringFilter | string
    currentRole?: StringFilter | string
    commands?: CommandListRelationFilter
    shippingAdress?: UserShippingAdressListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    passwordHash?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profileImage?: MediaOrderByWithRelationInput
    accoundActivated?: SortOrder
    role?: SortOrder
    currentRole?: SortOrder
    commands?: CommandOrderByRelationAggregateInput
    shippingAdress?: UserShippingAdressOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    passwordHash?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    accoundActivated?: SortOrder
    role?: SortOrder
    currentRole?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    passwordHash?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    accoundActivated?: BoolWithAggregatesFilter | boolean
    role?: StringWithAggregatesFilter | string
    currentRole?: StringWithAggregatesFilter | string
  }

  export type UserShippingAdressWhereInput = {
    AND?: Enumerable<UserShippingAdressWhereInput>
    OR?: Enumerable<UserShippingAdressWhereInput>
    NOT?: Enumerable<UserShippingAdressWhereInput>
    id?: StringFilter | string
    shippingZoneId?: StringFilter | string
    fullName?: StringFilter | string
    phone?: StringFilter | string
    alternatePhone?: StringFilter | string
    adressType?: StringFilter | string
    shippingZone?: XOR<ShippingZoneRelationFilter, ShippingZoneWhereInput>
    quatier?: StringFilter | string
    hasUserDeleted?: BoolFilter | boolean
    additionalDetails?: StringNullableFilter | string | null
    audioFileId?: StringNullableFilter | string | null
    audioFile?: XOR<MediaRelationFilter, MediaWhereInput> | null
    forUserId?: StringFilter | string
    forUser?: XOR<UserRelationFilter, UserWhereInput>
    commands?: CommandListRelationFilter
  }

  export type UserShippingAdressOrderByWithRelationInput = {
    id?: SortOrder
    shippingZoneId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    adressType?: SortOrder
    shippingZone?: ShippingZoneOrderByWithRelationInput
    quatier?: SortOrder
    hasUserDeleted?: SortOrder
    additionalDetails?: SortOrder
    audioFileId?: SortOrder
    audioFile?: MediaOrderByWithRelationInput
    forUserId?: SortOrder
    forUser?: UserOrderByWithRelationInput
    commands?: CommandOrderByRelationAggregateInput
  }

  export type UserShippingAdressWhereUniqueInput = {
    id?: string
  }

  export type UserShippingAdressOrderByWithAggregationInput = {
    id?: SortOrder
    shippingZoneId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    adressType?: SortOrder
    quatier?: SortOrder
    hasUserDeleted?: SortOrder
    additionalDetails?: SortOrder
    audioFileId?: SortOrder
    forUserId?: SortOrder
    _count?: UserShippingAdressCountOrderByAggregateInput
    _max?: UserShippingAdressMaxOrderByAggregateInput
    _min?: UserShippingAdressMinOrderByAggregateInput
  }

  export type UserShippingAdressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserShippingAdressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserShippingAdressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserShippingAdressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    shippingZoneId?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    alternatePhone?: StringWithAggregatesFilter | string
    adressType?: StringWithAggregatesFilter | string
    quatier?: StringWithAggregatesFilter | string
    hasUserDeleted?: BoolWithAggregatesFilter | boolean
    additionalDetails?: StringNullableWithAggregatesFilter | string | null
    audioFileId?: StringNullableWithAggregatesFilter | string | null
    forUserId?: StringWithAggregatesFilter | string
  }

  export type CommandWhereInput = {
    AND?: Enumerable<CommandWhereInput>
    OR?: Enumerable<CommandWhereInput>
    NOT?: Enumerable<CommandWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    totalPrice?: IntFilter | number
    orderId?: IntFilter | number
    archived?: BoolNullableFilter | boolean | null
    delivered?: BoolFilter | boolean
    status?: StringFilter | string
    orderedById?: StringFilter | string
    hasUserCanceled?: BoolFilter | boolean
    hasUserDeleted?: BoolFilter | boolean
    orderedBy?: XOR<UserRelationFilter, UserWhereInput>
    shippingAdressId?: StringNullableFilter | string | null
    shippingAdress?: XOR<UserShippingAdressRelationFilter, UserShippingAdressWhereInput> | null
    receiptId?: StringFilter | string
    receipt?: XOR<ReceiptRelationFilter, ReceiptWhereInput>
    commandProducts?: CommandProductListRelationFilter
    notifications?: NotificationListRelationFilter
    appliedDiscountId?: StringNullableFilter | string | null
    appliedDiscount?: XOR<DiscountRelationFilter, DiscountWhereInput> | null
  }

  export type CommandOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPrice?: SortOrder
    orderId?: SortOrder
    archived?: SortOrder
    delivered?: SortOrder
    status?: SortOrder
    orderedById?: SortOrder
    hasUserCanceled?: SortOrder
    hasUserDeleted?: SortOrder
    orderedBy?: UserOrderByWithRelationInput
    shippingAdressId?: SortOrder
    shippingAdress?: UserShippingAdressOrderByWithRelationInput
    receiptId?: SortOrder
    receipt?: ReceiptOrderByWithRelationInput
    commandProducts?: CommandProductOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    appliedDiscountId?: SortOrder
    appliedDiscount?: DiscountOrderByWithRelationInput
  }

  export type CommandWhereUniqueInput = {
    id?: string
    receiptId?: string
  }

  export type CommandOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPrice?: SortOrder
    orderId?: SortOrder
    archived?: SortOrder
    delivered?: SortOrder
    status?: SortOrder
    orderedById?: SortOrder
    hasUserCanceled?: SortOrder
    hasUserDeleted?: SortOrder
    shippingAdressId?: SortOrder
    receiptId?: SortOrder
    appliedDiscountId?: SortOrder
    _count?: CommandCountOrderByAggregateInput
    _avg?: CommandAvgOrderByAggregateInput
    _max?: CommandMaxOrderByAggregateInput
    _min?: CommandMinOrderByAggregateInput
    _sum?: CommandSumOrderByAggregateInput
  }

  export type CommandScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommandScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommandScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommandScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    totalPrice?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
    archived?: BoolNullableWithAggregatesFilter | boolean | null
    delivered?: BoolWithAggregatesFilter | boolean
    status?: StringWithAggregatesFilter | string
    orderedById?: StringWithAggregatesFilter | string
    hasUserCanceled?: BoolWithAggregatesFilter | boolean
    hasUserDeleted?: BoolWithAggregatesFilter | boolean
    shippingAdressId?: StringNullableWithAggregatesFilter | string | null
    receiptId?: StringWithAggregatesFilter | string
    appliedDiscountId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CommandProductWhereInput = {
    AND?: Enumerable<CommandProductWhereInput>
    OR?: Enumerable<CommandProductWhereInput>
    NOT?: Enumerable<CommandProductWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    hasUserDeleted?: BoolFilter | boolean
    commandUnitProductId?: StringFilter | string
    commandUnitProduct?: XOR<CommandUnitProductRelationFilter, CommandUnitProductWhereInput> | null
    quantite?: IntFilter | number
    commandId?: StringFilter | string
    command?: XOR<CommandRelationFilter, CommandWhereInput>
    hasCustomerConfirmShipping?: BoolFilter | boolean
    hasAgentConfirmShipping?: BoolFilter | boolean
  }

  export type CommandProductOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    hasUserDeleted?: SortOrder
    commandUnitProductId?: SortOrder
    commandUnitProduct?: CommandUnitProductOrderByWithRelationInput
    quantite?: SortOrder
    commandId?: SortOrder
    command?: CommandOrderByWithRelationInput
    hasCustomerConfirmShipping?: SortOrder
    hasAgentConfirmShipping?: SortOrder
  }

  export type CommandProductWhereUniqueInput = {
    id?: string
  }

  export type CommandProductOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    hasUserDeleted?: SortOrder
    commandUnitProductId?: SortOrder
    quantite?: SortOrder
    commandId?: SortOrder
    hasCustomerConfirmShipping?: SortOrder
    hasAgentConfirmShipping?: SortOrder
    _count?: CommandProductCountOrderByAggregateInput
    _avg?: CommandProductAvgOrderByAggregateInput
    _max?: CommandProductMaxOrderByAggregateInput
    _min?: CommandProductMinOrderByAggregateInput
    _sum?: CommandProductSumOrderByAggregateInput
  }

  export type CommandProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommandProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommandProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommandProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    productId?: StringWithAggregatesFilter | string
    hasUserDeleted?: BoolWithAggregatesFilter | boolean
    commandUnitProductId?: StringWithAggregatesFilter | string
    quantite?: IntWithAggregatesFilter | number
    commandId?: StringWithAggregatesFilter | string
    hasCustomerConfirmShipping?: BoolWithAggregatesFilter | boolean
    hasAgentConfirmShipping?: BoolWithAggregatesFilter | boolean
  }

  export type ReceiptWhereInput = {
    AND?: Enumerable<ReceiptWhereInput>
    OR?: Enumerable<ReceiptWhereInput>
    NOT?: Enumerable<ReceiptWhereInput>
    id?: StringFilter | string
    amount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    hasUserDeleted?: BoolFilter | boolean
    paidAt?: DateTimeNullableFilter | Date | string | null
    isPaid?: BoolFilter | boolean
    outPaymentId?: StringNullableFilter | string | null
    outPaymentDetails?: JsonNullableFilter
    receiptMetas?: JsonFilter
    receiptMediaId?: StringNullableFilter | string | null
    receiptMedia?: XOR<MediaRelationFilter, MediaWhereInput> | null
    command?: XOR<CommandRelationFilter, CommandWhereInput> | null
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    hasUserDeleted?: SortOrder
    paidAt?: SortOrder
    isPaid?: SortOrder
    outPaymentId?: SortOrder
    outPaymentDetails?: SortOrder
    receiptMetas?: SortOrder
    receiptMediaId?: SortOrder
    receiptMedia?: MediaOrderByWithRelationInput
    command?: CommandOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = {
    id?: string
  }

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    hasUserDeleted?: SortOrder
    paidAt?: SortOrder
    isPaid?: SortOrder
    outPaymentId?: SortOrder
    outPaymentDetails?: SortOrder
    receiptMetas?: SortOrder
    receiptMediaId?: SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReceiptScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amount?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    hasUserDeleted?: BoolWithAggregatesFilter | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isPaid?: BoolWithAggregatesFilter | boolean
    outPaymentId?: StringNullableWithAggregatesFilter | string | null
    outPaymentDetails?: JsonNullableWithAggregatesFilter
    receiptMetas?: JsonWithAggregatesFilter
    receiptMediaId?: StringNullableWithAggregatesFilter | string | null
  }

  export type VerificationCreateInput = {
    id?: string
    type: string
    otpCode: string
    email?: string | null
    tel?: string | null
    context: string
    pwdRecoverKey?: string | null
    hasBeenVerified?: boolean
    expireAt: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    type: string
    otpCode: string
    email?: string | null
    tel?: string | null
    context: string
    pwdRecoverKey?: string | null
    hasBeenVerified?: boolean
    expireAt: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    context?: StringFieldUpdateOperationsInput | string
    pwdRecoverKey?: NullableStringFieldUpdateOperationsInput | string | null
    hasBeenVerified?: BoolFieldUpdateOperationsInput | boolean
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    context?: StringFieldUpdateOperationsInput | string
    pwdRecoverKey?: NullableStringFieldUpdateOperationsInput | string | null
    hasBeenVerified?: BoolFieldUpdateOperationsInput | boolean
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    type: string
    otpCode: string
    email?: string | null
    tel?: string | null
    context: string
    pwdRecoverKey?: string | null
    hasBeenVerified?: boolean
    expireAt: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    context?: StringFieldUpdateOperationsInput | string
    pwdRecoverKey?: NullableStringFieldUpdateOperationsInput | string | null
    hasBeenVerified?: BoolFieldUpdateOperationsInput | boolean
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    context?: StringFieldUpdateOperationsInput | string
    pwdRecoverKey?: NullableStringFieldUpdateOperationsInput | string | null
    hasBeenVerified?: BoolFieldUpdateOperationsInput | boolean
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarqueCreateInput = {
    id?: string
    name: string
    categoryId: string
    image?: MediaCreateNestedOneWithoutMarqueInput
    category?: CategoryCreateNestedManyWithoutMarquesInput
    products?: ProductCreateNestedManyWithoutMarqueInput
  }

  export type MarqueUncheckedCreateInput = {
    id?: string
    imageId?: string | null
    name: string
    categoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutMarqueInput
  }

  export type MarqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    image?: MediaUpdateOneWithoutMarqueInput
    category?: CategoryUpdateManyWithoutMarquesInput
    products?: ProductUpdateManyWithoutMarqueInput
  }

  export type MarqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutMarqueInput
  }

  export type MarqueCreateManyInput = {
    id?: string
    imageId?: string | null
    name: string
    categoryId: string
  }

  export type MarqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type MarqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type DiscountCreateInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    bannerImage?: MediaCreateNestedOneWithoutDiscountsInput
    command?: CommandCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubCreateNestedManyWithoutForDiscountInput
    product?: ProductCreateNestedManyWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    command?: CommandUncheckedCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedCreateNestedManyWithoutForDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImage?: MediaUpdateOneWithoutDiscountsInput
    command?: CommandUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUpdateManyWithoutForDiscountInput
    product?: ProductUpdateManyWithoutDiscountsInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUncheckedUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedUpdateManyWithoutForDiscountInput
  }

  export type DiscountCreateManyInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceRuleCreateInput = {
    id?: string
    minPrice: number
    maxPrice?: number | null
    amountPercent: number
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutPriceRuleInput
  }

  export type PriceRuleUncheckedCreateInput = {
    id?: string
    minPrice: number
    maxPrice?: number | null
    amountPercent: number
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutPriceRuleInput
  }

  export type PriceRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutPriceRuleInput
  }

  export type PriceRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutPriceRuleInput
  }

  export type PriceRuleCreateManyInput = {
    id?: string
    minPrice: number
    maxPrice?: number | null
    amountPercent: number
  }

  export type PriceRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
  }

  export type PriceRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
  }

  export type PubCreateInput = {
    id?: string
    name: string
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    bannerImage?: MediaCreateNestedOneWithoutPubsInput
    forDiscount?: DiscountCreateNestedOneWithoutPubsInput
  }

  export type PubUncheckedCreateInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    forDiscountId?: string | null
  }

  export type PubUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerImage?: MediaUpdateOneWithoutPubsInput
    forDiscount?: DiscountUpdateOneWithoutPubsInput
  }

  export type PubUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PubCreateManyInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    forDiscountId?: string | null
  }

  export type PubUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PubUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShippingZoneCreateInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
    userShippingAdress?: UserShippingAdressCreateNestedManyWithoutShippingZoneInput
    products?: ProductCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedCreateInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
    userShippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutShippingZoneInput
  }

  export type ShippingZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
    userShippingAdress?: UserShippingAdressUpdateManyWithoutShippingZoneInput
    products?: ProductUpdateManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
    userShippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutShippingZoneInput
  }

  export type ShippingZoneCreateManyInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
  }

  export type ShippingZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
  }

  export type ShippingZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
  }

  export type ShippingRuleCreateInput = {
    id?: string
    ruleName: string
    rule: JsonNullValueInput | InputJsonValue
    description: string
  }

  export type ShippingRuleUncheckedCreateInput = {
    id?: string
    ruleName: string
    rule: JsonNullValueInput | InputJsonValue
    description: string
  }

  export type ShippingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleName?: StringFieldUpdateOperationsInput | string
    rule?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ShippingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleName?: StringFieldUpdateOperationsInput | string
    rule?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ShippingRuleCreateManyInput = {
    id?: string
    ruleName: string
    rule: JsonNullValueInput | InputJsonValue
    description: string
  }

  export type ShippingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleName?: StringFieldUpdateOperationsInput | string
    rule?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ShippingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleName?: StringFieldUpdateOperationsInput | string
    rule?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
  }

  export type GeneralMetaCreateInput = {
    id?: string
    name: string
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaCreateManyInput = {
    id?: string
    name: string
    key: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type GeneralMetaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaCreateInput = {
    id?: string
    name: string
    value: JsonNullValueInput | InputJsonValue
    attribute: ProductAttributeCreateNestedOneWithoutMetasInput
    products?: ProductCreateNestedManyWithoutVariationMetasInput
  }

  export type ProductAttributeMetaUncheckedCreateInput = {
    id?: string
    attributeId: string
    name: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    attribute?: ProductAttributeUpdateOneRequiredWithoutMetasInput
    products?: ProductUpdateManyWithoutVariationMetasInput
  }

  export type ProductAttributeMetaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaCreateManyInput = {
    id?: string
    attributeId: string
    name: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    metas?: ProductAttributeMetaCreateNestedManyWithoutAttributeInput
    category?: CategoryCreateNestedOneWithoutAttributesInput
    onlyForProduct?: ProductCreateNestedOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    categoryId?: string | null
    onlyForProductId?: string | null
    metas?: ProductAttributeMetaUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type ProductAttributeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    metas?: ProductAttributeMetaUpdateManyWithoutAttributeInput
    category?: CategoryUpdateOneWithoutAttributesInput
    onlyForProduct?: ProductUpdateOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onlyForProductId?: NullableStringFieldUpdateOperationsInput | string | null
    metas?: ProductAttributeMetaUncheckedUpdateManyWithoutAttributeInput
  }

  export type ProductAttributeCreateManyInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    categoryId?: string | null
    onlyForProductId?: string | null
  }

  export type ProductAttributeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductAttributeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onlyForProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    products?: ProductCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutTagsInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUnitCreateInput = {
    id?: string
    title: string
    shortCode: string
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutCommandUnitInput
  }

  export type CommandUnitUncheckedCreateInput = {
    id?: string
    title: string
    shortCode: string
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutCommandUnitInput
  }

  export type CommandUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutCommandUnitInput
  }

  export type CommandUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutCommandUnitInput
  }

  export type CommandUnitCreateManyInput = {
    id?: string
    title: string
    shortCode: string
  }

  export type CommandUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUnitProductCreateInput = {
    id?: string
    isDefault?: boolean
    unitPrice: number
    commandUnit: CommandUnitCreateNestedOneWithoutCommandUnitProductsInput
    product?: ProductCreateNestedOneWithoutCommandUnitProductsInput
    priceRule: PriceRuleCreateNestedOneWithoutCommandUnitProductsInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedCreateInput = {
    id?: string
    commandUnitId: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    commandUnit?: CommandUnitUpdateOneRequiredWithoutCommandUnitProductsInput
    product?: ProductUpdateOneWithoutCommandUnitProductsInput
    priceRule?: PriceRuleUpdateOneRequiredWithoutCommandUnitProductsInput
    commandProducts?: CommandProductUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    priceRuleId?: StringFieldUpdateOperationsInput | string
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductCreateManyInput = {
    id?: string
    commandUnitId: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
  }

  export type CommandUnitProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
  }

  export type CommandUnitProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    priceRuleId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type MediaCreateManyInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    hasUserRead?: boolean
    command?: CommandCreateNestedOneWithoutNotificationsInput
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    commandId?: string | null
    hasUserRead?: boolean
    userId?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    command?: CommandUpdateOneWithoutNotificationsInput
    user?: UserUpdateOneWithoutNotificationsInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    commandId?: NullableStringFieldUpdateOperationsInput | string | null
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    commandId?: string | null
    hasUserRead?: boolean
    userId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    commandId?: NullableStringFieldUpdateOperationsInput | string | null
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaCreateNestedOneWithoutForUserInput
    commands?: CommandCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressCreateNestedManyWithoutForUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaUncheckedCreateNestedOneWithoutForUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutForUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUpdateOneWithoutForUserInput
    commands?: CommandUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUpdateManyWithoutForUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUncheckedUpdateOneWithoutForUserInput
    commands?: CommandUncheckedUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutForUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
  }

  export type UserShippingAdressCreateInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    shippingZone: ShippingZoneCreateNestedOneWithoutUserShippingAdressInput
    audioFile?: MediaCreateNestedOneWithoutUserShippingAdressesInput
    forUser: UserCreateNestedOneWithoutShippingAdressInput
    commands?: CommandCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedCreateInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    forUserId: string
    commands?: CommandUncheckedCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    shippingZone?: ShippingZoneUpdateOneRequiredWithoutUserShippingAdressInput
    audioFile?: MediaUpdateOneWithoutUserShippingAdressesInput
    forUser?: UserUpdateOneRequiredWithoutShippingAdressInput
    commands?: CommandUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
    commands?: CommandUncheckedUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressCreateManyInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    forUserId: string
  }

  export type UserShippingAdressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserShippingAdressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
  }

  export type CommandCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type CommandCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
  }

  export type CommandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandProductCreateInput = {
    id?: string
    hasUserDeleted?: boolean
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
    product: ProductCreateNestedOneWithoutCommandProductsInput
    commandUnitProduct?: CommandUnitProductCreateNestedOneWithoutCommandProductsInput
    command: CommandCreateNestedOneWithoutCommandProductsInput
  }

  export type CommandProductUncheckedCreateInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCommandProductsInput
    commandUnitProduct?: CommandUnitProductUpdateOneWithoutCommandProductsInput
    command?: CommandUpdateOneRequiredWithoutCommandProductsInput
  }

  export type CommandProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    commandUnitProductId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    commandId?: StringFieldUpdateOperationsInput | string
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandProductCreateManyInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    commandUnitProductId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    commandId?: StringFieldUpdateOperationsInput | string
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReceiptCreateInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    receiptMedia?: MediaCreateNestedOneWithoutReceiptMediasInput
    command?: CommandCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    receiptMediaId?: string | null
    command?: CommandUncheckedCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    receiptMedia?: MediaUpdateOneWithoutReceiptMediasInput
    command?: CommandUpdateOneWithoutReceiptInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    receiptMediaId?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUncheckedUpdateOneWithoutReceiptInput
  }

  export type ReceiptCreateManyInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    receiptMediaId?: string | null
  }

  export type ReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    receiptMediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    otpCode?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    context?: SortOrder
    pwdRecoverKey?: SortOrder
    hasBeenVerified?: SortOrder
    expireAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    otpCode?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    context?: SortOrder
    pwdRecoverKey?: SortOrder
    hasBeenVerified?: SortOrder
    expireAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    otpCode?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    context?: SortOrder
    pwdRecoverKey?: SortOrder
    hasBeenVerified?: SortOrder
    expireAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type MediaRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type MarqueListRelationFilter = {
    every?: MarqueWhereInput
    some?: MarqueWhereInput
    none?: MarqueWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductAttributeListRelationFilter = {
    every?: ProductAttributeWhereInput
    some?: ProductAttributeWhereInput
    none?: ProductAttributeWhereInput
  }

  export type MarqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAttributeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    iconImageId?: SortOrder
    bannerImageId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    iconImageId?: SortOrder
    bannerImageId?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    iconImageId?: SortOrder
    bannerImageId?: SortOrder
  }

  export type MarqueCountOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type MarqueMaxOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type MarqueMinOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CommandListRelationFilter = {
    every?: CommandWhereInput
    some?: CommandWhereInput
    none?: CommandWhereInput
  }

  export type PubListRelationFilter = {
    every?: PubWhereInput
    some?: PubWhereInput
    none?: PubWhereInput
  }

  export type CommandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    discountType?: SortOrder
    discountNature?: SortOrder
    discountCode?: SortOrder
    discount?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
    description?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    discount?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    discountType?: SortOrder
    discountNature?: SortOrder
    discountCode?: SortOrder
    discount?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
    description?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    discountType?: SortOrder
    discountNature?: SortOrder
    discountCode?: SortOrder
    discount?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
    description?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    discount?: SortOrder
    inCartProductMin?: SortOrder
    inCartProductMax?: SortOrder
    commandAmountMin?: SortOrder
    commandAmountMax?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type CommandUnitProductListRelationFilter = {
    every?: CommandUnitProductWhereInput
    some?: CommandUnitProductWhereInput
    none?: CommandUnitProductWhereInput
  }

  export type CommandUnitProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceRuleCountOrderByAggregateInput = {
    id?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
  }

  export type PriceRuleAvgOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
  }

  export type PriceRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
  }

  export type PriceRuleMinOrderByAggregateInput = {
    id?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
  }

  export type PriceRuleSumOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    amountPercent?: SortOrder
  }

  export type DiscountRelationFilter = {
    is?: DiscountWhereInput | null
    isNot?: DiscountWhereInput | null
  }

  export type PubCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    forDiscountId?: SortOrder
  }

  export type PubMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    forDiscountId?: SortOrder
  }

  export type PubMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bannerImageId?: SortOrder
    link?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    forDiscountId?: SortOrder
  }

  export type UserShippingAdressListRelationFilter = {
    every?: UserShippingAdressWhereInput
    some?: UserShippingAdressWhereInput
    none?: UserShippingAdressWhereInput
  }

  export type UserShippingAdressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingZoneCountOrderByAggregateInput = {
    id?: SortOrder
    townName?: SortOrder
    townCode?: SortOrder
    baseShippingPrice?: SortOrder
  }

  export type ShippingZoneAvgOrderByAggregateInput = {
    baseShippingPrice?: SortOrder
  }

  export type ShippingZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    townName?: SortOrder
    townCode?: SortOrder
    baseShippingPrice?: SortOrder
  }

  export type ShippingZoneMinOrderByAggregateInput = {
    id?: SortOrder
    townName?: SortOrder
    townCode?: SortOrder
    baseShippingPrice?: SortOrder
  }

  export type ShippingZoneSumOrderByAggregateInput = {
    baseShippingPrice?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type ShippingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    ruleName?: SortOrder
    rule?: SortOrder
    description?: SortOrder
  }

  export type ShippingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleName?: SortOrder
    description?: SortOrder
  }

  export type ShippingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    ruleName?: SortOrder
    description?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type GeneralMetaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type GeneralMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
  }

  export type GeneralMetaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
  }

  export type ProductAttributeRelationFilter = {
    is?: ProductAttributeWhereInput
    isNot?: ProductAttributeWhereInput
  }

  export type ProductAttributeMetaCountOrderByAggregateInput = {
    id?: SortOrder
    attributeId?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type ProductAttributeMetaMaxOrderByAggregateInput = {
    id?: SortOrder
    attributeId?: SortOrder
    name?: SortOrder
  }

  export type ProductAttributeMetaMinOrderByAggregateInput = {
    id?: SortOrder
    attributeId?: SortOrder
    name?: SortOrder
  }

  export type ProductAttributeMetaListRelationFilter = {
    every?: ProductAttributeMetaWhereInput
    some?: ProductAttributeMetaWhereInput
    none?: ProductAttributeMetaWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProductAttributeMetaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAttributeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    global?: SortOrder
    categoryId?: SortOrder
    onlyForProductId?: SortOrder
  }

  export type ProductAttributeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    global?: SortOrder
    categoryId?: SortOrder
    onlyForProductId?: SortOrder
  }

  export type ProductAttributeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    global?: SortOrder
    categoryId?: SortOrder
    onlyForProductId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type CommandUnitCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    shortCode?: SortOrder
  }

  export type CommandUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    shortCode?: SortOrder
  }

  export type CommandUnitMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    shortCode?: SortOrder
  }

  export type CommandUnitRelationFilter = {
    is?: CommandUnitWhereInput
    isNot?: CommandUnitWhereInput
  }

  export type PriceRuleRelationFilter = {
    is?: PriceRuleWhereInput
    isNot?: PriceRuleWhereInput
  }

  export type CommandProductListRelationFilter = {
    every?: CommandProductWhereInput
    some?: CommandProductWhereInput
    none?: CommandProductWhereInput
  }

  export type CommandProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandUnitProductCountOrderByAggregateInput = {
    id?: SortOrder
    commandUnitId?: SortOrder
    productId?: SortOrder
    isDefault?: SortOrder
    unitPrice?: SortOrder
    priceRuleId?: SortOrder
  }

  export type CommandUnitProductAvgOrderByAggregateInput = {
    unitPrice?: SortOrder
  }

  export type CommandUnitProductMaxOrderByAggregateInput = {
    id?: SortOrder
    commandUnitId?: SortOrder
    productId?: SortOrder
    isDefault?: SortOrder
    unitPrice?: SortOrder
    priceRuleId?: SortOrder
  }

  export type CommandUnitProductMinOrderByAggregateInput = {
    id?: SortOrder
    commandUnitId?: SortOrder
    productId?: SortOrder
    isDefault?: SortOrder
    unitPrice?: SortOrder
    priceRuleId?: SortOrder
  }

  export type CommandUnitProductSumOrderByAggregateInput = {
    unitPrice?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    fileDuration?: SortOrder
    source?: SortOrder
    userId?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    fileDuration?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    fileDuration?: SortOrder
    source?: SortOrder
    userId?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    fileType?: SortOrder
    path?: SortOrder
    fileDuration?: SortOrder
    source?: SortOrder
    userId?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    fileDuration?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type MarqueRelationFilter = {
    is?: MarqueWhereInput | null
    isNot?: MarqueWhereInput | null
  }

  export type ShippingZoneListRelationFilter = {
    every?: ShippingZoneWhereInput
    some?: ShippingZoneWhereInput
    none?: ShippingZoneWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ShippingZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    productWeight?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sku?: SortOrder
    marqueId?: SortOrder
    variantParentId?: SortOrder
    showProduct?: SortOrder
    hasUserDeleted?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    productWeight?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    productWeight?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sku?: SortOrder
    marqueId?: SortOrder
    variantParentId?: SortOrder
    showProduct?: SortOrder
    hasUserDeleted?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    productWeight?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sku?: SortOrder
    marqueId?: SortOrder
    variantParentId?: SortOrder
    showProduct?: SortOrder
    hasUserDeleted?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    productWeight?: SortOrder
  }

  export type CommandRelationFilter = {
    is?: CommandWhereInput | null
    isNot?: CommandWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    context?: SortOrder
    priority?: SortOrder
    canLockScreen?: SortOrder
    theme?: SortOrder
    commandId?: SortOrder
    hasUserRead?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    context?: SortOrder
    priority?: SortOrder
    canLockScreen?: SortOrder
    theme?: SortOrder
    commandId?: SortOrder
    hasUserRead?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    context?: SortOrder
    priority?: SortOrder
    canLockScreen?: SortOrder
    theme?: SortOrder
    commandId?: SortOrder
    hasUserRead?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    passwordHash?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    accoundActivated?: SortOrder
    role?: SortOrder
    currentRole?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    passwordHash?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    accoundActivated?: SortOrder
    role?: SortOrder
    currentRole?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    passwordHash?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    accoundActivated?: SortOrder
    role?: SortOrder
    currentRole?: SortOrder
  }

  export type ShippingZoneRelationFilter = {
    is?: ShippingZoneWhereInput
    isNot?: ShippingZoneWhereInput
  }

  export type UserShippingAdressCountOrderByAggregateInput = {
    id?: SortOrder
    shippingZoneId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    adressType?: SortOrder
    quatier?: SortOrder
    hasUserDeleted?: SortOrder
    additionalDetails?: SortOrder
    audioFileId?: SortOrder
    forUserId?: SortOrder
  }

  export type UserShippingAdressMaxOrderByAggregateInput = {
    id?: SortOrder
    shippingZoneId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    adressType?: SortOrder
    quatier?: SortOrder
    hasUserDeleted?: SortOrder
    additionalDetails?: SortOrder
    audioFileId?: SortOrder
    forUserId?: SortOrder
  }

  export type UserShippingAdressMinOrderByAggregateInput = {
    id?: SortOrder
    shippingZoneId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    adressType?: SortOrder
    quatier?: SortOrder
    hasUserDeleted?: SortOrder
    additionalDetails?: SortOrder
    audioFileId?: SortOrder
    forUserId?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type UserShippingAdressRelationFilter = {
    is?: UserShippingAdressWhereInput | null
    isNot?: UserShippingAdressWhereInput | null
  }

  export type ReceiptRelationFilter = {
    is?: ReceiptWhereInput
    isNot?: ReceiptWhereInput
  }

  export type CommandCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPrice?: SortOrder
    orderId?: SortOrder
    archived?: SortOrder
    delivered?: SortOrder
    status?: SortOrder
    orderedById?: SortOrder
    hasUserCanceled?: SortOrder
    hasUserDeleted?: SortOrder
    shippingAdressId?: SortOrder
    receiptId?: SortOrder
    appliedDiscountId?: SortOrder
  }

  export type CommandAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    orderId?: SortOrder
  }

  export type CommandMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPrice?: SortOrder
    orderId?: SortOrder
    archived?: SortOrder
    delivered?: SortOrder
    status?: SortOrder
    orderedById?: SortOrder
    hasUserCanceled?: SortOrder
    hasUserDeleted?: SortOrder
    shippingAdressId?: SortOrder
    receiptId?: SortOrder
    appliedDiscountId?: SortOrder
  }

  export type CommandMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    totalPrice?: SortOrder
    orderId?: SortOrder
    archived?: SortOrder
    delivered?: SortOrder
    status?: SortOrder
    orderedById?: SortOrder
    hasUserCanceled?: SortOrder
    hasUserDeleted?: SortOrder
    shippingAdressId?: SortOrder
    receiptId?: SortOrder
    appliedDiscountId?: SortOrder
  }

  export type CommandSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    orderId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type CommandUnitProductRelationFilter = {
    is?: CommandUnitProductWhereInput | null
    isNot?: CommandUnitProductWhereInput | null
  }

  export type CommandProductCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    hasUserDeleted?: SortOrder
    commandUnitProductId?: SortOrder
    quantite?: SortOrder
    commandId?: SortOrder
    hasCustomerConfirmShipping?: SortOrder
    hasAgentConfirmShipping?: SortOrder
  }

  export type CommandProductAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type CommandProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    hasUserDeleted?: SortOrder
    commandUnitProductId?: SortOrder
    quantite?: SortOrder
    commandId?: SortOrder
    hasCustomerConfirmShipping?: SortOrder
    hasAgentConfirmShipping?: SortOrder
  }

  export type CommandProductMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    hasUserDeleted?: SortOrder
    commandUnitProductId?: SortOrder
    quantite?: SortOrder
    commandId?: SortOrder
    hasCustomerConfirmShipping?: SortOrder
    hasAgentConfirmShipping?: SortOrder
  }

  export type CommandProductSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    hasUserDeleted?: SortOrder
    paidAt?: SortOrder
    isPaid?: SortOrder
    outPaymentId?: SortOrder
    outPaymentDetails?: SortOrder
    receiptMetas?: SortOrder
    receiptMediaId?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    hasUserDeleted?: SortOrder
    paidAt?: SortOrder
    isPaid?: SortOrder
    outPaymentId?: SortOrder
    receiptMediaId?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    hasUserDeleted?: SortOrder
    paidAt?: SortOrder
    isPaid?: SortOrder
    outPaymentId?: SortOrder
    receiptMediaId?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutIconImagesCategoriesInput = {
    create?: XOR<MediaCreateWithoutIconImagesCategoriesInput, MediaUncheckedCreateWithoutIconImagesCategoriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutIconImagesCategoriesInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutBannerImagesCategoriesInput = {
    create?: XOR<MediaCreateWithoutBannerImagesCategoriesInput, MediaUncheckedCreateWithoutBannerImagesCategoriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutBannerImagesCategoriesInput
    connect?: MediaWhereUniqueInput
  }

  export type MarqueCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutCategoryInput>, Enumerable<MarqueUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutCategoryInput>
    connect?: Enumerable<MarqueWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductAttributeCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutCategoryInput>, Enumerable<ProductAttributeUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutCategoryInput>
    createMany?: ProductAttributeCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutCategoryInput>, Enumerable<ProductAttributeUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutCategoryInput>
    createMany?: ProductAttributeCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
  }

  export type CategoryUpdateOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type MediaUpdateOneWithoutIconImagesCategoriesInput = {
    create?: XOR<MediaCreateWithoutIconImagesCategoriesInput, MediaUncheckedCreateWithoutIconImagesCategoriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutIconImagesCategoriesInput
    upsert?: MediaUpsertWithoutIconImagesCategoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutIconImagesCategoriesInput, MediaUncheckedUpdateWithoutIconImagesCategoriesInput>
  }

  export type MediaUpdateOneWithoutBannerImagesCategoriesInput = {
    create?: XOR<MediaCreateWithoutBannerImagesCategoriesInput, MediaUncheckedCreateWithoutBannerImagesCategoriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutBannerImagesCategoriesInput
    upsert?: MediaUpsertWithoutBannerImagesCategoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutBannerImagesCategoriesInput, MediaUncheckedUpdateWithoutBannerImagesCategoriesInput>
  }

  export type MarqueUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutCategoryInput>, Enumerable<MarqueUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<MarqueUpsertWithWhereUniqueWithoutCategoryInput>
    set?: Enumerable<MarqueWhereUniqueInput>
    disconnect?: Enumerable<MarqueWhereUniqueInput>
    delete?: Enumerable<MarqueWhereUniqueInput>
    connect?: Enumerable<MarqueWhereUniqueInput>
    update?: Enumerable<MarqueUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<MarqueUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<MarqueScalarWhereInput>
  }

  export type ProductUpdateManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutCategoriesInput>, Enumerable<ProductUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutCategoriesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductAttributeUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutCategoryInput>, Enumerable<ProductAttributeUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ProductAttributeUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ProductAttributeCreateManyCategoryInputEnvelope
    set?: Enumerable<ProductAttributeWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeWhereUniqueInput>
    delete?: Enumerable<ProductAttributeWhereUniqueInput>
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
    update?: Enumerable<ProductAttributeUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ProductAttributeUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ProductAttributeScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutParentInput>, Enumerable<CategoryUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductAttributeUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutCategoryInput>, Enumerable<ProductAttributeUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ProductAttributeUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ProductAttributeCreateManyCategoryInputEnvelope
    set?: Enumerable<ProductAttributeWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeWhereUniqueInput>
    delete?: Enumerable<ProductAttributeWhereUniqueInput>
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
    update?: Enumerable<ProductAttributeUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ProductAttributeUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ProductAttributeScalarWhereInput>
  }

  export type MediaCreateNestedOneWithoutMarqueInput = {
    create?: XOR<MediaCreateWithoutMarqueInput, MediaUncheckedCreateWithoutMarqueInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMarqueInput
    connect?: MediaWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutMarquesInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutMarquesInput>, Enumerable<CategoryUncheckedCreateWithoutMarquesInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutMarquesInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutMarqueInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMarqueInput>, Enumerable<ProductUncheckedCreateWithoutMarqueInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMarqueInput>
    createMany?: ProductCreateManyMarqueInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutMarqueInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMarqueInput>, Enumerable<ProductUncheckedCreateWithoutMarqueInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMarqueInput>
    createMany?: ProductCreateManyMarqueInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type MediaUpdateOneWithoutMarqueInput = {
    create?: XOR<MediaCreateWithoutMarqueInput, MediaUncheckedCreateWithoutMarqueInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMarqueInput
    upsert?: MediaUpsertWithoutMarqueInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutMarqueInput, MediaUncheckedUpdateWithoutMarqueInput>
  }

  export type CategoryUpdateManyWithoutMarquesInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutMarquesInput>, Enumerable<CategoryUncheckedCreateWithoutMarquesInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutMarquesInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutMarquesInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutMarquesInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutMarquesInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ProductUpdateManyWithoutMarqueInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMarqueInput>, Enumerable<ProductUncheckedCreateWithoutMarqueInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMarqueInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutMarqueInput>
    createMany?: ProductCreateManyMarqueInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutMarqueInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutMarqueInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutMarqueInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMarqueInput>, Enumerable<ProductUncheckedCreateWithoutMarqueInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMarqueInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutMarqueInput>
    createMany?: ProductCreateManyMarqueInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutMarqueInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutMarqueInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type MediaCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<MediaCreateWithoutDiscountsInput, MediaUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDiscountsInput
    connect?: MediaWhereUniqueInput
  }

  export type CommandCreateNestedManyWithoutAppliedDiscountInput = {
    create?: XOR<Enumerable<CommandCreateWithoutAppliedDiscountInput>, Enumerable<CommandUncheckedCreateWithoutAppliedDiscountInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutAppliedDiscountInput>
    createMany?: CommandCreateManyAppliedDiscountInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type PubCreateNestedManyWithoutForDiscountInput = {
    create?: XOR<Enumerable<PubCreateWithoutForDiscountInput>, Enumerable<PubUncheckedCreateWithoutForDiscountInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutForDiscountInput>
    createMany?: PubCreateManyForDiscountInputEnvelope
    connect?: Enumerable<PubWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutDiscountsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDiscountsInput>, Enumerable<ProductUncheckedCreateWithoutDiscountsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDiscountsInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CommandUncheckedCreateNestedManyWithoutAppliedDiscountInput = {
    create?: XOR<Enumerable<CommandCreateWithoutAppliedDiscountInput>, Enumerable<CommandUncheckedCreateWithoutAppliedDiscountInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutAppliedDiscountInput>
    createMany?: CommandCreateManyAppliedDiscountInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type PubUncheckedCreateNestedManyWithoutForDiscountInput = {
    create?: XOR<Enumerable<PubCreateWithoutForDiscountInput>, Enumerable<PubUncheckedCreateWithoutForDiscountInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutForDiscountInput>
    createMany?: PubCreateManyForDiscountInputEnvelope
    connect?: Enumerable<PubWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaUpdateOneWithoutDiscountsInput = {
    create?: XOR<MediaCreateWithoutDiscountsInput, MediaUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutDiscountsInput
    upsert?: MediaUpsertWithoutDiscountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutDiscountsInput, MediaUncheckedUpdateWithoutDiscountsInput>
  }

  export type CommandUpdateManyWithoutAppliedDiscountInput = {
    create?: XOR<Enumerable<CommandCreateWithoutAppliedDiscountInput>, Enumerable<CommandUncheckedCreateWithoutAppliedDiscountInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutAppliedDiscountInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutAppliedDiscountInput>
    createMany?: CommandCreateManyAppliedDiscountInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutAppliedDiscountInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutAppliedDiscountInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type PubUpdateManyWithoutForDiscountInput = {
    create?: XOR<Enumerable<PubCreateWithoutForDiscountInput>, Enumerable<PubUncheckedCreateWithoutForDiscountInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutForDiscountInput>
    upsert?: Enumerable<PubUpsertWithWhereUniqueWithoutForDiscountInput>
    createMany?: PubCreateManyForDiscountInputEnvelope
    set?: Enumerable<PubWhereUniqueInput>
    disconnect?: Enumerable<PubWhereUniqueInput>
    delete?: Enumerable<PubWhereUniqueInput>
    connect?: Enumerable<PubWhereUniqueInput>
    update?: Enumerable<PubUpdateWithWhereUniqueWithoutForDiscountInput>
    updateMany?: Enumerable<PubUpdateManyWithWhereWithoutForDiscountInput>
    deleteMany?: Enumerable<PubScalarWhereInput>
  }

  export type ProductUpdateManyWithoutDiscountsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutDiscountsInput>, Enumerable<ProductUncheckedCreateWithoutDiscountsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutDiscountsInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutDiscountsInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutDiscountsInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutDiscountsInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CommandUncheckedUpdateManyWithoutAppliedDiscountInput = {
    create?: XOR<Enumerable<CommandCreateWithoutAppliedDiscountInput>, Enumerable<CommandUncheckedCreateWithoutAppliedDiscountInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutAppliedDiscountInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutAppliedDiscountInput>
    createMany?: CommandCreateManyAppliedDiscountInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutAppliedDiscountInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutAppliedDiscountInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type PubUncheckedUpdateManyWithoutForDiscountInput = {
    create?: XOR<Enumerable<PubCreateWithoutForDiscountInput>, Enumerable<PubUncheckedCreateWithoutForDiscountInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutForDiscountInput>
    upsert?: Enumerable<PubUpsertWithWhereUniqueWithoutForDiscountInput>
    createMany?: PubCreateManyForDiscountInputEnvelope
    set?: Enumerable<PubWhereUniqueInput>
    disconnect?: Enumerable<PubWhereUniqueInput>
    delete?: Enumerable<PubWhereUniqueInput>
    connect?: Enumerable<PubWhereUniqueInput>
    update?: Enumerable<PubUpdateWithWhereUniqueWithoutForDiscountInput>
    updateMany?: Enumerable<PubUpdateManyWithWhereWithoutForDiscountInput>
    deleteMany?: Enumerable<PubScalarWhereInput>
  }

  export type CommandUnitProductCreateNestedManyWithoutPriceRuleInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutPriceRuleInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutPriceRuleInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutPriceRuleInput>
    createMany?: CommandUnitProductCreateManyPriceRuleInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandUnitProductUncheckedCreateNestedManyWithoutPriceRuleInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutPriceRuleInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutPriceRuleInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutPriceRuleInput>
    createMany?: CommandUnitProductCreateManyPriceRuleInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandUnitProductUpdateManyWithoutPriceRuleInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutPriceRuleInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutPriceRuleInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutPriceRuleInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutPriceRuleInput>
    createMany?: CommandUnitProductCreateManyPriceRuleInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutPriceRuleInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutPriceRuleInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type CommandUnitProductUncheckedUpdateManyWithoutPriceRuleInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutPriceRuleInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutPriceRuleInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutPriceRuleInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutPriceRuleInput>
    createMany?: CommandUnitProductCreateManyPriceRuleInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutPriceRuleInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutPriceRuleInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type MediaCreateNestedOneWithoutPubsInput = {
    create?: XOR<MediaCreateWithoutPubsInput, MediaUncheckedCreateWithoutPubsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPubsInput
    connect?: MediaWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutPubsInput = {
    create?: XOR<DiscountCreateWithoutPubsInput, DiscountUncheckedCreateWithoutPubsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutPubsInput
    connect?: DiscountWhereUniqueInput
  }

  export type MediaUpdateOneWithoutPubsInput = {
    create?: XOR<MediaCreateWithoutPubsInput, MediaUncheckedCreateWithoutPubsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPubsInput
    upsert?: MediaUpsertWithoutPubsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutPubsInput, MediaUncheckedUpdateWithoutPubsInput>
  }

  export type DiscountUpdateOneWithoutPubsInput = {
    create?: XOR<DiscountCreateWithoutPubsInput, DiscountUncheckedCreateWithoutPubsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutPubsInput
    upsert?: DiscountUpsertWithoutPubsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutPubsInput, DiscountUncheckedUpdateWithoutPubsInput>
  }

  export type UserShippingAdressCreateNestedManyWithoutShippingZoneInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutShippingZoneInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutShippingZoneInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutShippingZoneInput>
    createMany?: UserShippingAdressCreateManyShippingZoneInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutShippingZonesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShippingZonesInput>, Enumerable<ProductUncheckedCreateWithoutShippingZonesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShippingZonesInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserShippingAdressUncheckedCreateNestedManyWithoutShippingZoneInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutShippingZoneInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutShippingZoneInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutShippingZoneInput>
    createMany?: UserShippingAdressCreateManyShippingZoneInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type UserShippingAdressUpdateManyWithoutShippingZoneInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutShippingZoneInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutShippingZoneInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutShippingZoneInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutShippingZoneInput>
    createMany?: UserShippingAdressCreateManyShippingZoneInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutShippingZoneInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutShippingZoneInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type ProductUpdateManyWithoutShippingZonesInput = {
    create?: XOR<Enumerable<ProductCreateWithoutShippingZonesInput>, Enumerable<ProductUncheckedCreateWithoutShippingZonesInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutShippingZonesInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutShippingZonesInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutShippingZonesInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutShippingZonesInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutShippingZoneInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutShippingZoneInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutShippingZoneInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutShippingZoneInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutShippingZoneInput>
    createMany?: UserShippingAdressCreateManyShippingZoneInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutShippingZoneInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutShippingZoneInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type ProductAttributeCreateNestedOneWithoutMetasInput = {
    create?: XOR<ProductAttributeCreateWithoutMetasInput, ProductAttributeUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ProductAttributeCreateOrConnectWithoutMetasInput
    connect?: ProductAttributeWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutVariationMetasInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariationMetasInput>, Enumerable<ProductUncheckedCreateWithoutVariationMetasInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariationMetasInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductAttributeUpdateOneRequiredWithoutMetasInput = {
    create?: XOR<ProductAttributeCreateWithoutMetasInput, ProductAttributeUncheckedCreateWithoutMetasInput>
    connectOrCreate?: ProductAttributeCreateOrConnectWithoutMetasInput
    upsert?: ProductAttributeUpsertWithoutMetasInput
    connect?: ProductAttributeWhereUniqueInput
    update?: XOR<ProductAttributeUpdateWithoutMetasInput, ProductAttributeUncheckedUpdateWithoutMetasInput>
  }

  export type ProductUpdateManyWithoutVariationMetasInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariationMetasInput>, Enumerable<ProductUncheckedCreateWithoutVariationMetasInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariationMetasInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutVariationMetasInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutVariationMetasInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutVariationMetasInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductAttributeMetaCreateNestedManyWithoutAttributeInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutAttributeInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutAttributeInput>
    createMany?: ProductAttributeMetaCreateManyAttributeInputEnvelope
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
  }

  export type CategoryCreateNestedOneWithoutAttributesInput = {
    create?: XOR<CategoryCreateWithoutAttributesInput, CategoryUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAttributesInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductAttributesInput = {
    create?: XOR<ProductCreateWithoutProductAttributesInput, ProductUncheckedCreateWithoutProductAttributesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductAttributesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductAttributeMetaUncheckedCreateNestedManyWithoutAttributeInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutAttributeInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutAttributeInput>
    createMany?: ProductAttributeMetaCreateManyAttributeInputEnvelope
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
  }

  export type ProductAttributeMetaUpdateManyWithoutAttributeInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutAttributeInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutAttributeInput>
    upsert?: Enumerable<ProductAttributeMetaUpsertWithWhereUniqueWithoutAttributeInput>
    createMany?: ProductAttributeMetaCreateManyAttributeInputEnvelope
    set?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    delete?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    update?: Enumerable<ProductAttributeMetaUpdateWithWhereUniqueWithoutAttributeInput>
    updateMany?: Enumerable<ProductAttributeMetaUpdateManyWithWhereWithoutAttributeInput>
    deleteMany?: Enumerable<ProductAttributeMetaScalarWhereInput>
  }

  export type CategoryUpdateOneWithoutAttributesInput = {
    create?: XOR<CategoryCreateWithoutAttributesInput, CategoryUncheckedCreateWithoutAttributesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAttributesInput
    upsert?: CategoryUpsertWithoutAttributesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutAttributesInput, CategoryUncheckedUpdateWithoutAttributesInput>
  }

  export type ProductUpdateOneWithoutProductAttributesInput = {
    create?: XOR<ProductCreateWithoutProductAttributesInput, ProductUncheckedCreateWithoutProductAttributesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductAttributesInput
    upsert?: ProductUpsertWithoutProductAttributesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductAttributesInput, ProductUncheckedUpdateWithoutProductAttributesInput>
  }

  export type ProductAttributeMetaUncheckedUpdateManyWithoutAttributeInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutAttributeInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutAttributeInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutAttributeInput>
    upsert?: Enumerable<ProductAttributeMetaUpsertWithWhereUniqueWithoutAttributeInput>
    createMany?: ProductAttributeMetaCreateManyAttributeInputEnvelope
    set?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    delete?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    update?: Enumerable<ProductAttributeMetaUpdateWithWhereUniqueWithoutAttributeInput>
    updateMany?: Enumerable<ProductAttributeMetaUpdateManyWithWhereWithoutAttributeInput>
    deleteMany?: Enumerable<ProductAttributeMetaScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutTagsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTagsInput>, Enumerable<ProductUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTagsInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutTagsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutTagsInput>, Enumerable<ProductUncheckedCreateWithoutTagsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutTagsInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutTagsInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutTagsInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutTagsInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CommandUnitProductCreateNestedManyWithoutCommandUnitInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutCommandUnitInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutCommandUnitInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutCommandUnitInput>
    createMany?: CommandUnitProductCreateManyCommandUnitInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandUnitProductUncheckedCreateNestedManyWithoutCommandUnitInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutCommandUnitInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutCommandUnitInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutCommandUnitInput>
    createMany?: CommandUnitProductCreateManyCommandUnitInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandUnitProductUpdateManyWithoutCommandUnitInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutCommandUnitInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutCommandUnitInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutCommandUnitInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutCommandUnitInput>
    createMany?: CommandUnitProductCreateManyCommandUnitInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutCommandUnitInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutCommandUnitInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type CommandUnitProductUncheckedUpdateManyWithoutCommandUnitInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutCommandUnitInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutCommandUnitInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutCommandUnitInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutCommandUnitInput>
    createMany?: CommandUnitProductCreateManyCommandUnitInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutCommandUnitInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutCommandUnitInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type CommandUnitCreateNestedOneWithoutCommandUnitProductsInput = {
    create?: XOR<CommandUnitCreateWithoutCommandUnitProductsInput, CommandUnitUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: CommandUnitCreateOrConnectWithoutCommandUnitProductsInput
    connect?: CommandUnitWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCommandUnitProductsInput = {
    create?: XOR<ProductCreateWithoutCommandUnitProductsInput, ProductUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommandUnitProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type PriceRuleCreateNestedOneWithoutCommandUnitProductsInput = {
    create?: XOR<PriceRuleCreateWithoutCommandUnitProductsInput, PriceRuleUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: PriceRuleCreateOrConnectWithoutCommandUnitProductsInput
    connect?: PriceRuleWhereUniqueInput
  }

  export type CommandProductCreateNestedManyWithoutCommandUnitProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandUnitProductInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandUnitProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandUnitProductInput>
    createMany?: CommandProductCreateManyCommandUnitProductInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type CommandProductUncheckedCreateNestedManyWithoutCommandUnitProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandUnitProductInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandUnitProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandUnitProductInput>
    createMany?: CommandProductCreateManyCommandUnitProductInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type CommandUnitUpdateOneRequiredWithoutCommandUnitProductsInput = {
    create?: XOR<CommandUnitCreateWithoutCommandUnitProductsInput, CommandUnitUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: CommandUnitCreateOrConnectWithoutCommandUnitProductsInput
    upsert?: CommandUnitUpsertWithoutCommandUnitProductsInput
    connect?: CommandUnitWhereUniqueInput
    update?: XOR<CommandUnitUpdateWithoutCommandUnitProductsInput, CommandUnitUncheckedUpdateWithoutCommandUnitProductsInput>
  }

  export type ProductUpdateOneWithoutCommandUnitProductsInput = {
    create?: XOR<ProductCreateWithoutCommandUnitProductsInput, ProductUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommandUnitProductsInput
    upsert?: ProductUpsertWithoutCommandUnitProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCommandUnitProductsInput, ProductUncheckedUpdateWithoutCommandUnitProductsInput>
  }

  export type PriceRuleUpdateOneRequiredWithoutCommandUnitProductsInput = {
    create?: XOR<PriceRuleCreateWithoutCommandUnitProductsInput, PriceRuleUncheckedCreateWithoutCommandUnitProductsInput>
    connectOrCreate?: PriceRuleCreateOrConnectWithoutCommandUnitProductsInput
    upsert?: PriceRuleUpsertWithoutCommandUnitProductsInput
    connect?: PriceRuleWhereUniqueInput
    update?: XOR<PriceRuleUpdateWithoutCommandUnitProductsInput, PriceRuleUncheckedUpdateWithoutCommandUnitProductsInput>
  }

  export type CommandProductUpdateManyWithoutCommandUnitProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandUnitProductInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandUnitProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandUnitProductInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutCommandUnitProductInput>
    createMany?: CommandProductCreateManyCommandUnitProductInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutCommandUnitProductInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutCommandUnitProductInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type CommandProductUncheckedUpdateManyWithoutCommandUnitProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandUnitProductInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandUnitProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandUnitProductInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutCommandUnitProductInput>
    createMany?: CommandProductCreateManyCommandUnitProductInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutCommandUnitProductInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutCommandUnitProductInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutMediasInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMediasInput>, Enumerable<ProductUncheckedCreateWithoutMediasInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMediasInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutIconImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutIconImageInput>, Enumerable<CategoryUncheckedCreateWithoutIconImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutIconImageInput>
    createMany?: CategoryCreateManyIconImageInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutBannerImageInput>, Enumerable<CategoryUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutBannerImageInput>
    createMany?: CategoryCreateManyBannerImageInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type MarqueCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutImageInput>, Enumerable<MarqueUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutImageInput>
    createMany?: MarqueCreateManyImageInputEnvelope
    connect?: Enumerable<MarqueWhereUniqueInput>
  }

  export type PubCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<PubCreateWithoutBannerImageInput>, Enumerable<PubUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutBannerImageInput>
    createMany?: PubCreateManyBannerImageInputEnvelope
    connect?: Enumerable<PubWhereUniqueInput>
  }

  export type UserShippingAdressCreateNestedManyWithoutAudioFileInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutAudioFileInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutAudioFileInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutAudioFileInput>
    createMany?: UserShippingAdressCreateManyAudioFileInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type DiscountCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutBannerImageInput>, Enumerable<DiscountUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutBannerImageInput>
    createMany?: DiscountCreateManyBannerImageInputEnvelope
    connect?: Enumerable<DiscountWhereUniqueInput>
  }

  export type ReceiptCreateNestedManyWithoutReceiptMediaInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutReceiptMediaInput>, Enumerable<ReceiptUncheckedCreateWithoutReceiptMediaInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutReceiptMediaInput>
    createMany?: ReceiptCreateManyReceiptMediaInputEnvelope
    connect?: Enumerable<ReceiptWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutProfileImageInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryUncheckedCreateNestedManyWithoutIconImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutIconImageInput>, Enumerable<CategoryUncheckedCreateWithoutIconImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutIconImageInput>
    createMany?: CategoryCreateManyIconImageInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type CategoryUncheckedCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutBannerImageInput>, Enumerable<CategoryUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutBannerImageInput>
    createMany?: CategoryCreateManyBannerImageInputEnvelope
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type MarqueUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutImageInput>, Enumerable<MarqueUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutImageInput>
    createMany?: MarqueCreateManyImageInputEnvelope
    connect?: Enumerable<MarqueWhereUniqueInput>
  }

  export type PubUncheckedCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<PubCreateWithoutBannerImageInput>, Enumerable<PubUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutBannerImageInput>
    createMany?: PubCreateManyBannerImageInputEnvelope
    connect?: Enumerable<PubWhereUniqueInput>
  }

  export type UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutAudioFileInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutAudioFileInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutAudioFileInput>
    createMany?: UserShippingAdressCreateManyAudioFileInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type DiscountUncheckedCreateNestedManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutBannerImageInput>, Enumerable<DiscountUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutBannerImageInput>
    createMany?: DiscountCreateManyBannerImageInputEnvelope
    connect?: Enumerable<DiscountWhereUniqueInput>
  }

  export type ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutReceiptMediaInput>, Enumerable<ReceiptUncheckedCreateWithoutReceiptMediaInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutReceiptMediaInput>
    createMany?: ReceiptCreateManyReceiptMediaInputEnvelope
    connect?: Enumerable<ReceiptWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateManyWithoutMediasInput = {
    create?: XOR<Enumerable<ProductCreateWithoutMediasInput>, Enumerable<ProductUncheckedCreateWithoutMediasInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutMediasInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutMediasInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutMediasInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutMediasInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutIconImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutIconImageInput>, Enumerable<CategoryUncheckedCreateWithoutIconImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutIconImageInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutIconImageInput>
    createMany?: CategoryCreateManyIconImageInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutIconImageInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutIconImageInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutBannerImageInput>, Enumerable<CategoryUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: CategoryCreateManyBannerImageInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type MarqueUpdateManyWithoutImageInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutImageInput>, Enumerable<MarqueUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<MarqueUpsertWithWhereUniqueWithoutImageInput>
    createMany?: MarqueCreateManyImageInputEnvelope
    set?: Enumerable<MarqueWhereUniqueInput>
    disconnect?: Enumerable<MarqueWhereUniqueInput>
    delete?: Enumerable<MarqueWhereUniqueInput>
    connect?: Enumerable<MarqueWhereUniqueInput>
    update?: Enumerable<MarqueUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<MarqueUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<MarqueScalarWhereInput>
  }

  export type PubUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<PubCreateWithoutBannerImageInput>, Enumerable<PubUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<PubUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: PubCreateManyBannerImageInputEnvelope
    set?: Enumerable<PubWhereUniqueInput>
    disconnect?: Enumerable<PubWhereUniqueInput>
    delete?: Enumerable<PubWhereUniqueInput>
    connect?: Enumerable<PubWhereUniqueInput>
    update?: Enumerable<PubUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<PubUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<PubScalarWhereInput>
  }

  export type UserShippingAdressUpdateManyWithoutAudioFileInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutAudioFileInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutAudioFileInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutAudioFileInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutAudioFileInput>
    createMany?: UserShippingAdressCreateManyAudioFileInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutAudioFileInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutAudioFileInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type DiscountUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutBannerImageInput>, Enumerable<DiscountUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<DiscountUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: DiscountCreateManyBannerImageInputEnvelope
    set?: Enumerable<DiscountWhereUniqueInput>
    disconnect?: Enumerable<DiscountWhereUniqueInput>
    delete?: Enumerable<DiscountWhereUniqueInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
    update?: Enumerable<DiscountUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<DiscountUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<DiscountScalarWhereInput>
  }

  export type ReceiptUpdateManyWithoutReceiptMediaInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutReceiptMediaInput>, Enumerable<ReceiptUncheckedCreateWithoutReceiptMediaInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutReceiptMediaInput>
    upsert?: Enumerable<ReceiptUpsertWithWhereUniqueWithoutReceiptMediaInput>
    createMany?: ReceiptCreateManyReceiptMediaInputEnvelope
    set?: Enumerable<ReceiptWhereUniqueInput>
    disconnect?: Enumerable<ReceiptWhereUniqueInput>
    delete?: Enumerable<ReceiptWhereUniqueInput>
    connect?: Enumerable<ReceiptWhereUniqueInput>
    update?: Enumerable<ReceiptUpdateWithWhereUniqueWithoutReceiptMediaInput>
    updateMany?: Enumerable<ReceiptUpdateManyWithWhereWithoutReceiptMediaInput>
    deleteMany?: Enumerable<ReceiptScalarWhereInput>
  }

  export type UserUpdateOneWithoutProfileImageInput = {
    create?: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileImageInput
    upsert?: UserUpsertWithoutProfileImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileImageInput, UserUncheckedUpdateWithoutProfileImageInput>
  }

  export type CategoryUncheckedUpdateManyWithoutIconImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutIconImageInput>, Enumerable<CategoryUncheckedCreateWithoutIconImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutIconImageInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutIconImageInput>
    createMany?: CategoryCreateManyIconImageInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutIconImageInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutIconImageInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type CategoryUncheckedUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutBannerImageInput>, Enumerable<CategoryUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: CategoryCreateManyBannerImageInputEnvelope
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type MarqueUncheckedUpdateManyWithoutImageInput = {
    create?: XOR<Enumerable<MarqueCreateWithoutImageInput>, Enumerable<MarqueUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<MarqueCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<MarqueUpsertWithWhereUniqueWithoutImageInput>
    createMany?: MarqueCreateManyImageInputEnvelope
    set?: Enumerable<MarqueWhereUniqueInput>
    disconnect?: Enumerable<MarqueWhereUniqueInput>
    delete?: Enumerable<MarqueWhereUniqueInput>
    connect?: Enumerable<MarqueWhereUniqueInput>
    update?: Enumerable<MarqueUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<MarqueUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<MarqueScalarWhereInput>
  }

  export type PubUncheckedUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<PubCreateWithoutBannerImageInput>, Enumerable<PubUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<PubCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<PubUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: PubCreateManyBannerImageInputEnvelope
    set?: Enumerable<PubWhereUniqueInput>
    disconnect?: Enumerable<PubWhereUniqueInput>
    delete?: Enumerable<PubWhereUniqueInput>
    connect?: Enumerable<PubWhereUniqueInput>
    update?: Enumerable<PubUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<PubUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<PubScalarWhereInput>
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutAudioFileInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutAudioFileInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutAudioFileInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutAudioFileInput>
    createMany?: UserShippingAdressCreateManyAudioFileInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutAudioFileInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutAudioFileInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type DiscountUncheckedUpdateManyWithoutBannerImageInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutBannerImageInput>, Enumerable<DiscountUncheckedCreateWithoutBannerImageInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutBannerImageInput>
    upsert?: Enumerable<DiscountUpsertWithWhereUniqueWithoutBannerImageInput>
    createMany?: DiscountCreateManyBannerImageInputEnvelope
    set?: Enumerable<DiscountWhereUniqueInput>
    disconnect?: Enumerable<DiscountWhereUniqueInput>
    delete?: Enumerable<DiscountWhereUniqueInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
    update?: Enumerable<DiscountUpdateWithWhereUniqueWithoutBannerImageInput>
    updateMany?: Enumerable<DiscountUpdateManyWithWhereWithoutBannerImageInput>
    deleteMany?: Enumerable<DiscountScalarWhereInput>
  }

  export type ReceiptUncheckedUpdateManyWithoutReceiptMediaInput = {
    create?: XOR<Enumerable<ReceiptCreateWithoutReceiptMediaInput>, Enumerable<ReceiptUncheckedCreateWithoutReceiptMediaInput>>
    connectOrCreate?: Enumerable<ReceiptCreateOrConnectWithoutReceiptMediaInput>
    upsert?: Enumerable<ReceiptUpsertWithWhereUniqueWithoutReceiptMediaInput>
    createMany?: ReceiptCreateManyReceiptMediaInputEnvelope
    set?: Enumerable<ReceiptWhereUniqueInput>
    disconnect?: Enumerable<ReceiptWhereUniqueInput>
    delete?: Enumerable<ReceiptWhereUniqueInput>
    connect?: Enumerable<ReceiptWhereUniqueInput>
    update?: Enumerable<ReceiptUpdateWithWhereUniqueWithoutReceiptMediaInput>
    updateMany?: Enumerable<ReceiptUpdateManyWithWhereWithoutReceiptMediaInput>
    deleteMany?: Enumerable<ReceiptScalarWhereInput>
  }

  export type MarqueCreateNestedOneWithoutProductsInput = {
    create?: XOR<MarqueCreateWithoutProductsInput, MarqueUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MarqueCreateOrConnectWithoutProductsInput
    connect?: MarqueWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutVariationsInput = {
    create?: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductAttributeCreateNestedManyWithoutOnlyForProductInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutOnlyForProductInput>, Enumerable<ProductAttributeUncheckedCreateWithoutOnlyForProductInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutOnlyForProductInput>
    createMany?: ProductAttributeCreateManyOnlyForProductInputEnvelope
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
  }

  export type ProductAttributeMetaCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutProductsInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutVariantParentInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariantParentInput>, Enumerable<ProductUncheckedCreateWithoutVariantParentInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariantParentInput>
    createMany?: ProductCreateManyVariantParentInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CategoryCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
  }

  export type ShippingZoneCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<ShippingZoneCreateWithoutProductsInput>, Enumerable<ShippingZoneUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ShippingZoneCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<ShippingZoneWhereUniqueInput>
  }

  export type TagCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<TagCreateWithoutProductsInput>, Enumerable<TagUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<TagWhereUniqueInput>
  }

  export type MediaCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<MediaCreateWithoutProductsInput>, Enumerable<MediaUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<MediaCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<MediaWhereUniqueInput>
  }

  export type CommandUnitProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutProductInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutProductInput>
    createMany?: CommandUnitProductCreateManyProductInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutProductInput>, Enumerable<CommandProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutProductInput>
    createMany?: CommandProductCreateManyProductInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type DiscountCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutProductInput>, Enumerable<DiscountUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutProductInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
  }

  export type ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutOnlyForProductInput>, Enumerable<ProductAttributeUncheckedCreateWithoutOnlyForProductInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutOnlyForProductInput>
    createMany?: ProductAttributeCreateManyOnlyForProductInputEnvelope
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutVariantParentInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariantParentInput>, Enumerable<ProductUncheckedCreateWithoutVariantParentInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariantParentInput>
    createMany?: ProductCreateManyVariantParentInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type CommandUnitProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutProductInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutProductInput>
    createMany?: CommandUnitProductCreateManyProductInputEnvelope
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
  }

  export type CommandProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutProductInput>, Enumerable<CommandProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutProductInput>
    createMany?: CommandProductCreateManyProductInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type MarqueUpdateOneWithoutProductsInput = {
    create?: XOR<MarqueCreateWithoutProductsInput, MarqueUncheckedCreateWithoutProductsInput>
    connectOrCreate?: MarqueCreateOrConnectWithoutProductsInput
    upsert?: MarqueUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MarqueWhereUniqueInput
    update?: XOR<MarqueUpdateWithoutProductsInput, MarqueUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneWithoutVariationsInput = {
    create?: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariationsInput
    upsert?: ProductUpsertWithoutVariationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutVariationsInput, ProductUncheckedUpdateWithoutVariationsInput>
  }

  export type ProductAttributeUpdateManyWithoutOnlyForProductInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutOnlyForProductInput>, Enumerable<ProductAttributeUncheckedCreateWithoutOnlyForProductInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutOnlyForProductInput>
    upsert?: Enumerable<ProductAttributeUpsertWithWhereUniqueWithoutOnlyForProductInput>
    createMany?: ProductAttributeCreateManyOnlyForProductInputEnvelope
    set?: Enumerable<ProductAttributeWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeWhereUniqueInput>
    delete?: Enumerable<ProductAttributeWhereUniqueInput>
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
    update?: Enumerable<ProductAttributeUpdateWithWhereUniqueWithoutOnlyForProductInput>
    updateMany?: Enumerable<ProductAttributeUpdateManyWithWhereWithoutOnlyForProductInput>
    deleteMany?: Enumerable<ProductAttributeScalarWhereInput>
  }

  export type ProductAttributeMetaUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ProductAttributeMetaCreateWithoutProductsInput>, Enumerable<ProductAttributeMetaUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ProductAttributeMetaCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ProductAttributeMetaUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    delete?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    connect?: Enumerable<ProductAttributeMetaWhereUniqueInput>
    update?: Enumerable<ProductAttributeMetaUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ProductAttributeMetaUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ProductAttributeMetaScalarWhereInput>
  }

  export type ProductUpdateManyWithoutVariantParentInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariantParentInput>, Enumerable<ProductUncheckedCreateWithoutVariantParentInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariantParentInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutVariantParentInput>
    createMany?: ProductCreateManyVariantParentInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutVariantParentInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutVariantParentInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CategoryUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<CategoryCreateWithoutProductsInput>, Enumerable<CategoryUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<CategoryCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<CategoryUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<CategoryWhereUniqueInput>
    disconnect?: Enumerable<CategoryWhereUniqueInput>
    delete?: Enumerable<CategoryWhereUniqueInput>
    connect?: Enumerable<CategoryWhereUniqueInput>
    update?: Enumerable<CategoryUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<CategoryUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<CategoryScalarWhereInput>
  }

  export type ShippingZoneUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<ShippingZoneCreateWithoutProductsInput>, Enumerable<ShippingZoneUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<ShippingZoneCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<ShippingZoneUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<ShippingZoneWhereUniqueInput>
    disconnect?: Enumerable<ShippingZoneWhereUniqueInput>
    delete?: Enumerable<ShippingZoneWhereUniqueInput>
    connect?: Enumerable<ShippingZoneWhereUniqueInput>
    update?: Enumerable<ShippingZoneUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<ShippingZoneUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<ShippingZoneScalarWhereInput>
  }

  export type TagUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<TagCreateWithoutProductsInput>, Enumerable<TagUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<TagCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<TagUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<TagWhereUniqueInput>
    disconnect?: Enumerable<TagWhereUniqueInput>
    delete?: Enumerable<TagWhereUniqueInput>
    connect?: Enumerable<TagWhereUniqueInput>
    update?: Enumerable<TagUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<TagUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<TagScalarWhereInput>
  }

  export type MediaUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<MediaCreateWithoutProductsInput>, Enumerable<MediaUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<MediaCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<MediaUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<MediaWhereUniqueInput>
    disconnect?: Enumerable<MediaWhereUniqueInput>
    delete?: Enumerable<MediaWhereUniqueInput>
    connect?: Enumerable<MediaWhereUniqueInput>
    update?: Enumerable<MediaUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<MediaUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<MediaScalarWhereInput>
  }

  export type CommandUnitProductUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutProductInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommandUnitProductCreateManyProductInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type CommandProductUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutProductInput>, Enumerable<CommandProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommandProductCreateManyProductInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type DiscountUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<DiscountCreateWithoutProductInput>, Enumerable<DiscountUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DiscountCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<DiscountUpsertWithWhereUniqueWithoutProductInput>
    set?: Enumerable<DiscountWhereUniqueInput>
    disconnect?: Enumerable<DiscountWhereUniqueInput>
    delete?: Enumerable<DiscountWhereUniqueInput>
    connect?: Enumerable<DiscountWhereUniqueInput>
    update?: Enumerable<DiscountUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<DiscountUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<DiscountScalarWhereInput>
  }

  export type ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput = {
    create?: XOR<Enumerable<ProductAttributeCreateWithoutOnlyForProductInput>, Enumerable<ProductAttributeUncheckedCreateWithoutOnlyForProductInput>>
    connectOrCreate?: Enumerable<ProductAttributeCreateOrConnectWithoutOnlyForProductInput>
    upsert?: Enumerable<ProductAttributeUpsertWithWhereUniqueWithoutOnlyForProductInput>
    createMany?: ProductAttributeCreateManyOnlyForProductInputEnvelope
    set?: Enumerable<ProductAttributeWhereUniqueInput>
    disconnect?: Enumerable<ProductAttributeWhereUniqueInput>
    delete?: Enumerable<ProductAttributeWhereUniqueInput>
    connect?: Enumerable<ProductAttributeWhereUniqueInput>
    update?: Enumerable<ProductAttributeUpdateWithWhereUniqueWithoutOnlyForProductInput>
    updateMany?: Enumerable<ProductAttributeUpdateManyWithWhereWithoutOnlyForProductInput>
    deleteMany?: Enumerable<ProductAttributeScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutVariantParentInput = {
    create?: XOR<Enumerable<ProductCreateWithoutVariantParentInput>, Enumerable<ProductUncheckedCreateWithoutVariantParentInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutVariantParentInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutVariantParentInput>
    createMany?: ProductCreateManyVariantParentInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutVariantParentInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutVariantParentInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type CommandUnitProductUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandUnitProductCreateWithoutProductInput>, Enumerable<CommandUnitProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandUnitProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommandUnitProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommandUnitProductCreateManyProductInputEnvelope
    set?: Enumerable<CommandUnitProductWhereUniqueInput>
    disconnect?: Enumerable<CommandUnitProductWhereUniqueInput>
    delete?: Enumerable<CommandUnitProductWhereUniqueInput>
    connect?: Enumerable<CommandUnitProductWhereUniqueInput>
    update?: Enumerable<CommandUnitProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommandUnitProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommandUnitProductScalarWhereInput>
  }

  export type CommandProductUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutProductInput>, Enumerable<CommandProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommandProductCreateManyProductInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type CommandCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CommandCreateWithoutNotificationsInput, CommandUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutNotificationsInput
    connect?: CommandWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type CommandUpdateOneWithoutNotificationsInput = {
    create?: XOR<CommandCreateWithoutNotificationsInput, CommandUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutNotificationsInput
    upsert?: CommandUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommandWhereUniqueInput
    update?: XOR<CommandUpdateWithoutNotificationsInput, CommandUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type MediaCreateNestedOneWithoutForUserInput = {
    create?: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutForUserInput
    connect?: MediaWhereUniqueInput
  }

  export type CommandCreateNestedManyWithoutOrderedByInput = {
    create?: XOR<Enumerable<CommandCreateWithoutOrderedByInput>, Enumerable<CommandUncheckedCreateWithoutOrderedByInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutOrderedByInput>
    createMany?: CommandCreateManyOrderedByInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type UserShippingAdressCreateNestedManyWithoutForUserInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutForUserInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutForUserInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutForUserInput>
    createMany?: UserShippingAdressCreateManyForUserInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type MediaUncheckedCreateNestedOneWithoutForUserInput = {
    create?: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutForUserInput
    connect?: MediaWhereUniqueInput
  }

  export type CommandUncheckedCreateNestedManyWithoutOrderedByInput = {
    create?: XOR<Enumerable<CommandCreateWithoutOrderedByInput>, Enumerable<CommandUncheckedCreateWithoutOrderedByInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutOrderedByInput>
    createMany?: CommandCreateManyOrderedByInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type UserShippingAdressUncheckedCreateNestedManyWithoutForUserInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutForUserInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutForUserInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutForUserInput>
    createMany?: UserShippingAdressCreateManyForUserInputEnvelope
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type MediaUpdateOneWithoutForUserInput = {
    create?: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutForUserInput
    upsert?: MediaUpsertWithoutForUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutForUserInput, MediaUncheckedUpdateWithoutForUserInput>
  }

  export type CommandUpdateManyWithoutOrderedByInput = {
    create?: XOR<Enumerable<CommandCreateWithoutOrderedByInput>, Enumerable<CommandUncheckedCreateWithoutOrderedByInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutOrderedByInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutOrderedByInput>
    createMany?: CommandCreateManyOrderedByInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutOrderedByInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutOrderedByInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type UserShippingAdressUpdateManyWithoutForUserInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutForUserInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutForUserInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutForUserInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutForUserInput>
    createMany?: UserShippingAdressCreateManyForUserInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutForUserInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutForUserInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type MediaUncheckedUpdateOneWithoutForUserInput = {
    create?: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
    connectOrCreate?: MediaCreateOrConnectWithoutForUserInput
    upsert?: MediaUpsertWithoutForUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutForUserInput, MediaUncheckedUpdateWithoutForUserInput>
  }

  export type CommandUncheckedUpdateManyWithoutOrderedByInput = {
    create?: XOR<Enumerable<CommandCreateWithoutOrderedByInput>, Enumerable<CommandUncheckedCreateWithoutOrderedByInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutOrderedByInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutOrderedByInput>
    createMany?: CommandCreateManyOrderedByInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutOrderedByInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutOrderedByInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutForUserInput = {
    create?: XOR<Enumerable<UserShippingAdressCreateWithoutForUserInput>, Enumerable<UserShippingAdressUncheckedCreateWithoutForUserInput>>
    connectOrCreate?: Enumerable<UserShippingAdressCreateOrConnectWithoutForUserInput>
    upsert?: Enumerable<UserShippingAdressUpsertWithWhereUniqueWithoutForUserInput>
    createMany?: UserShippingAdressCreateManyForUserInputEnvelope
    set?: Enumerable<UserShippingAdressWhereUniqueInput>
    disconnect?: Enumerable<UserShippingAdressWhereUniqueInput>
    delete?: Enumerable<UserShippingAdressWhereUniqueInput>
    connect?: Enumerable<UserShippingAdressWhereUniqueInput>
    update?: Enumerable<UserShippingAdressUpdateWithWhereUniqueWithoutForUserInput>
    updateMany?: Enumerable<UserShippingAdressUpdateManyWithWhereWithoutForUserInput>
    deleteMany?: Enumerable<UserShippingAdressScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ShippingZoneCreateNestedOneWithoutUserShippingAdressInput = {
    create?: XOR<ShippingZoneCreateWithoutUserShippingAdressInput, ShippingZoneUncheckedCreateWithoutUserShippingAdressInput>
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutUserShippingAdressInput
    connect?: ShippingZoneWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutUserShippingAdressesInput = {
    create?: XOR<MediaCreateWithoutUserShippingAdressesInput, MediaUncheckedCreateWithoutUserShippingAdressesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserShippingAdressesInput
    connect?: MediaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShippingAdressInput = {
    create?: XOR<UserCreateWithoutShippingAdressInput, UserUncheckedCreateWithoutShippingAdressInput>
    connectOrCreate?: UserCreateOrConnectWithoutShippingAdressInput
    connect?: UserWhereUniqueInput
  }

  export type CommandCreateNestedManyWithoutShippingAdressInput = {
    create?: XOR<Enumerable<CommandCreateWithoutShippingAdressInput>, Enumerable<CommandUncheckedCreateWithoutShippingAdressInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutShippingAdressInput>
    createMany?: CommandCreateManyShippingAdressInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type CommandUncheckedCreateNestedManyWithoutShippingAdressInput = {
    create?: XOR<Enumerable<CommandCreateWithoutShippingAdressInput>, Enumerable<CommandUncheckedCreateWithoutShippingAdressInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutShippingAdressInput>
    createMany?: CommandCreateManyShippingAdressInputEnvelope
    connect?: Enumerable<CommandWhereUniqueInput>
  }

  export type ShippingZoneUpdateOneRequiredWithoutUserShippingAdressInput = {
    create?: XOR<ShippingZoneCreateWithoutUserShippingAdressInput, ShippingZoneUncheckedCreateWithoutUserShippingAdressInput>
    connectOrCreate?: ShippingZoneCreateOrConnectWithoutUserShippingAdressInput
    upsert?: ShippingZoneUpsertWithoutUserShippingAdressInput
    connect?: ShippingZoneWhereUniqueInput
    update?: XOR<ShippingZoneUpdateWithoutUserShippingAdressInput, ShippingZoneUncheckedUpdateWithoutUserShippingAdressInput>
  }

  export type MediaUpdateOneWithoutUserShippingAdressesInput = {
    create?: XOR<MediaCreateWithoutUserShippingAdressesInput, MediaUncheckedCreateWithoutUserShippingAdressesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserShippingAdressesInput
    upsert?: MediaUpsertWithoutUserShippingAdressesInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutUserShippingAdressesInput, MediaUncheckedUpdateWithoutUserShippingAdressesInput>
  }

  export type UserUpdateOneRequiredWithoutShippingAdressInput = {
    create?: XOR<UserCreateWithoutShippingAdressInput, UserUncheckedCreateWithoutShippingAdressInput>
    connectOrCreate?: UserCreateOrConnectWithoutShippingAdressInput
    upsert?: UserUpsertWithoutShippingAdressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShippingAdressInput, UserUncheckedUpdateWithoutShippingAdressInput>
  }

  export type CommandUpdateManyWithoutShippingAdressInput = {
    create?: XOR<Enumerable<CommandCreateWithoutShippingAdressInput>, Enumerable<CommandUncheckedCreateWithoutShippingAdressInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutShippingAdressInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutShippingAdressInput>
    createMany?: CommandCreateManyShippingAdressInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutShippingAdressInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutShippingAdressInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type CommandUncheckedUpdateManyWithoutShippingAdressInput = {
    create?: XOR<Enumerable<CommandCreateWithoutShippingAdressInput>, Enumerable<CommandUncheckedCreateWithoutShippingAdressInput>>
    connectOrCreate?: Enumerable<CommandCreateOrConnectWithoutShippingAdressInput>
    upsert?: Enumerable<CommandUpsertWithWhereUniqueWithoutShippingAdressInput>
    createMany?: CommandCreateManyShippingAdressInputEnvelope
    set?: Enumerable<CommandWhereUniqueInput>
    disconnect?: Enumerable<CommandWhereUniqueInput>
    delete?: Enumerable<CommandWhereUniqueInput>
    connect?: Enumerable<CommandWhereUniqueInput>
    update?: Enumerable<CommandUpdateWithWhereUniqueWithoutShippingAdressInput>
    updateMany?: Enumerable<CommandUpdateManyWithWhereWithoutShippingAdressInput>
    deleteMany?: Enumerable<CommandScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCommandsInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    connect?: UserWhereUniqueInput
  }

  export type UserShippingAdressCreateNestedOneWithoutCommandsInput = {
    create?: XOR<UserShippingAdressCreateWithoutCommandsInput, UserShippingAdressUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserShippingAdressCreateOrConnectWithoutCommandsInput
    connect?: UserShippingAdressWhereUniqueInput
  }

  export type ReceiptCreateNestedOneWithoutCommandInput = {
    create?: XOR<ReceiptCreateWithoutCommandInput, ReceiptUncheckedCreateWithoutCommandInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutCommandInput
    connect?: ReceiptWhereUniqueInput
  }

  export type CommandProductCreateNestedManyWithoutCommandInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandInput>
    createMany?: CommandProductCreateManyCommandInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutCommandInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutCommandInput>, Enumerable<NotificationUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutCommandInput>
    createMany?: NotificationCreateManyCommandInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type DiscountCreateNestedOneWithoutCommandInput = {
    create?: XOR<DiscountCreateWithoutCommandInput, DiscountUncheckedCreateWithoutCommandInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutCommandInput
    connect?: DiscountWhereUniqueInput
  }

  export type CommandProductUncheckedCreateNestedManyWithoutCommandInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandInput>
    createMany?: CommandProductCreateManyCommandInputEnvelope
    connect?: Enumerable<CommandProductWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutCommandInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutCommandInput>, Enumerable<NotificationUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutCommandInput>
    createMany?: NotificationCreateManyCommandInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutCommandsInput = {
    create?: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommandsInput
    upsert?: UserUpsertWithoutCommandsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
  }

  export type UserShippingAdressUpdateOneWithoutCommandsInput = {
    create?: XOR<UserShippingAdressCreateWithoutCommandsInput, UserShippingAdressUncheckedCreateWithoutCommandsInput>
    connectOrCreate?: UserShippingAdressCreateOrConnectWithoutCommandsInput
    upsert?: UserShippingAdressUpsertWithoutCommandsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserShippingAdressWhereUniqueInput
    update?: XOR<UserShippingAdressUpdateWithoutCommandsInput, UserShippingAdressUncheckedUpdateWithoutCommandsInput>
  }

  export type ReceiptUpdateOneRequiredWithoutCommandInput = {
    create?: XOR<ReceiptCreateWithoutCommandInput, ReceiptUncheckedCreateWithoutCommandInput>
    connectOrCreate?: ReceiptCreateOrConnectWithoutCommandInput
    upsert?: ReceiptUpsertWithoutCommandInput
    connect?: ReceiptWhereUniqueInput
    update?: XOR<ReceiptUpdateWithoutCommandInput, ReceiptUncheckedUpdateWithoutCommandInput>
  }

  export type CommandProductUpdateManyWithoutCommandInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutCommandInput>
    createMany?: CommandProductCreateManyCommandInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutCommandInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutCommandInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutCommandInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutCommandInput>, Enumerable<NotificationUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutCommandInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutCommandInput>
    createMany?: NotificationCreateManyCommandInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutCommandInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutCommandInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type DiscountUpdateOneWithoutCommandInput = {
    create?: XOR<DiscountCreateWithoutCommandInput, DiscountUncheckedCreateWithoutCommandInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutCommandInput
    upsert?: DiscountUpsertWithoutCommandInput
    disconnect?: boolean
    delete?: boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<DiscountUpdateWithoutCommandInput, DiscountUncheckedUpdateWithoutCommandInput>
  }

  export type CommandProductUncheckedUpdateManyWithoutCommandInput = {
    create?: XOR<Enumerable<CommandProductCreateWithoutCommandInput>, Enumerable<CommandProductUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<CommandProductCreateOrConnectWithoutCommandInput>
    upsert?: Enumerable<CommandProductUpsertWithWhereUniqueWithoutCommandInput>
    createMany?: CommandProductCreateManyCommandInputEnvelope
    set?: Enumerable<CommandProductWhereUniqueInput>
    disconnect?: Enumerable<CommandProductWhereUniqueInput>
    delete?: Enumerable<CommandProductWhereUniqueInput>
    connect?: Enumerable<CommandProductWhereUniqueInput>
    update?: Enumerable<CommandProductUpdateWithWhereUniqueWithoutCommandInput>
    updateMany?: Enumerable<CommandProductUpdateManyWithWhereWithoutCommandInput>
    deleteMany?: Enumerable<CommandProductScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutCommandInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutCommandInput>, Enumerable<NotificationUncheckedCreateWithoutCommandInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutCommandInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutCommandInput>
    createMany?: NotificationCreateManyCommandInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutCommandInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutCommandInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutCommandProductsInput = {
    create?: XOR<ProductCreateWithoutCommandProductsInput, ProductUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommandProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type CommandUnitProductCreateNestedOneWithoutCommandProductsInput = {
    create?: XOR<CommandUnitProductCreateWithoutCommandProductsInput, CommandUnitProductUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: CommandUnitProductCreateOrConnectWithoutCommandProductsInput
    connect?: CommandUnitProductWhereUniqueInput
  }

  export type CommandCreateNestedOneWithoutCommandProductsInput = {
    create?: XOR<CommandCreateWithoutCommandProductsInput, CommandUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutCommandProductsInput
    connect?: CommandWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCommandProductsInput = {
    create?: XOR<ProductCreateWithoutCommandProductsInput, ProductUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommandProductsInput
    upsert?: ProductUpsertWithoutCommandProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCommandProductsInput, ProductUncheckedUpdateWithoutCommandProductsInput>
  }

  export type CommandUnitProductUpdateOneWithoutCommandProductsInput = {
    create?: XOR<CommandUnitProductCreateWithoutCommandProductsInput, CommandUnitProductUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: CommandUnitProductCreateOrConnectWithoutCommandProductsInput
    upsert?: CommandUnitProductUpsertWithoutCommandProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommandUnitProductWhereUniqueInput
    update?: XOR<CommandUnitProductUpdateWithoutCommandProductsInput, CommandUnitProductUncheckedUpdateWithoutCommandProductsInput>
  }

  export type CommandUpdateOneRequiredWithoutCommandProductsInput = {
    create?: XOR<CommandCreateWithoutCommandProductsInput, CommandUncheckedCreateWithoutCommandProductsInput>
    connectOrCreate?: CommandCreateOrConnectWithoutCommandProductsInput
    upsert?: CommandUpsertWithoutCommandProductsInput
    connect?: CommandWhereUniqueInput
    update?: XOR<CommandUpdateWithoutCommandProductsInput, CommandUncheckedUpdateWithoutCommandProductsInput>
  }

  export type MediaCreateNestedOneWithoutReceiptMediasInput = {
    create?: XOR<MediaCreateWithoutReceiptMediasInput, MediaUncheckedCreateWithoutReceiptMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutReceiptMediasInput
    connect?: MediaWhereUniqueInput
  }

  export type CommandCreateNestedOneWithoutReceiptInput = {
    create?: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: CommandCreateOrConnectWithoutReceiptInput
    connect?: CommandWhereUniqueInput
  }

  export type CommandUncheckedCreateNestedOneWithoutReceiptInput = {
    create?: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: CommandCreateOrConnectWithoutReceiptInput
    connect?: CommandWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MediaUpdateOneWithoutReceiptMediasInput = {
    create?: XOR<MediaCreateWithoutReceiptMediasInput, MediaUncheckedCreateWithoutReceiptMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutReceiptMediasInput
    upsert?: MediaUpsertWithoutReceiptMediasInput
    disconnect?: boolean
    delete?: boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<MediaUpdateWithoutReceiptMediasInput, MediaUncheckedUpdateWithoutReceiptMediasInput>
  }

  export type CommandUpdateOneWithoutReceiptInput = {
    create?: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: CommandCreateOrConnectWithoutReceiptInput
    upsert?: CommandUpsertWithoutReceiptInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommandWhereUniqueInput
    update?: XOR<CommandUpdateWithoutReceiptInput, CommandUncheckedUpdateWithoutReceiptInput>
  }

  export type CommandUncheckedUpdateOneWithoutReceiptInput = {
    create?: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: CommandCreateOrConnectWithoutReceiptInput
    upsert?: CommandUpsertWithoutReceiptInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommandWhereUniqueInput
    update?: XOR<CommandUpdateWithoutReceiptInput, CommandUncheckedUpdateWithoutReceiptInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type MediaCreateWithoutIconImagesCategoriesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutIconImagesCategoriesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutIconImagesCategoriesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutIconImagesCategoriesInput, MediaUncheckedCreateWithoutIconImagesCategoriesInput>
  }

  export type MediaCreateWithoutBannerImagesCategoriesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutBannerImagesCategoriesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutBannerImagesCategoriesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutBannerImagesCategoriesInput, MediaUncheckedCreateWithoutBannerImagesCategoriesInput>
  }

  export type MarqueCreateWithoutCategoryInput = {
    id?: string
    name: string
    categoryId: string
    image?: MediaCreateNestedOneWithoutMarqueInput
    products?: ProductCreateNestedManyWithoutMarqueInput
  }

  export type MarqueUncheckedCreateWithoutCategoryInput = {
    id?: string
    imageId?: string | null
    name: string
    categoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutMarqueInput
  }

  export type MarqueCreateOrConnectWithoutCategoryInput = {
    where: MarqueWhereUniqueInput
    create: XOR<MarqueCreateWithoutCategoryInput, MarqueUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    iconImageId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: Enumerable<CategoryCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type ProductAttributeCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    metas?: ProductAttributeMetaCreateNestedManyWithoutAttributeInput
    onlyForProduct?: ProductCreateNestedOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    onlyForProductId?: string | null
    metas?: ProductAttributeMetaUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type ProductAttributeCreateOrConnectWithoutCategoryInput = {
    where: ProductAttributeWhereUniqueInput
    create: XOR<ProductAttributeCreateWithoutCategoryInput, ProductAttributeUncheckedCreateWithoutCategoryInput>
  }

  export type ProductAttributeCreateManyCategoryInputEnvelope = {
    data: Enumerable<ProductAttributeCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type MediaUpsertWithoutIconImagesCategoriesInput = {
    update: XOR<MediaUpdateWithoutIconImagesCategoriesInput, MediaUncheckedUpdateWithoutIconImagesCategoriesInput>
    create: XOR<MediaCreateWithoutIconImagesCategoriesInput, MediaUncheckedCreateWithoutIconImagesCategoriesInput>
  }

  export type MediaUpdateWithoutIconImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutIconImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type MediaUpsertWithoutBannerImagesCategoriesInput = {
    update: XOR<MediaUpdateWithoutBannerImagesCategoriesInput, MediaUncheckedUpdateWithoutBannerImagesCategoriesInput>
    create: XOR<MediaCreateWithoutBannerImagesCategoriesInput, MediaUncheckedCreateWithoutBannerImagesCategoriesInput>
  }

  export type MediaUpdateWithoutBannerImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutBannerImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type MarqueUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MarqueWhereUniqueInput
    update: XOR<MarqueUpdateWithoutCategoryInput, MarqueUncheckedUpdateWithoutCategoryInput>
    create: XOR<MarqueCreateWithoutCategoryInput, MarqueUncheckedCreateWithoutCategoryInput>
  }

  export type MarqueUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MarqueWhereUniqueInput
    data: XOR<MarqueUpdateWithoutCategoryInput, MarqueUncheckedUpdateWithoutCategoryInput>
  }

  export type MarqueUpdateManyWithWhereWithoutCategoryInput = {
    where: MarqueScalarWhereInput
    data: XOR<MarqueUpdateManyMutationInput, MarqueUncheckedUpdateManyWithoutMarquesInput>
  }

  export type MarqueScalarWhereInput = {
    AND?: Enumerable<MarqueScalarWhereInput>
    OR?: Enumerable<MarqueScalarWhereInput>
    NOT?: Enumerable<MarqueScalarWhereInput>
    id?: StringFilter | string
    imageId?: StringNullableFilter | string | null
    name?: StringFilter | string
    categoryId?: StringFilter | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoriesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    shortDescription?: StringNullableFilter | string | null
    type?: StringFilter | string
    productWeight?: IntNullableFilter | number | null
    isPublished?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    sku?: StringNullableFilter | string | null
    marqueId?: StringNullableFilter | string | null
    variantParentId?: StringNullableFilter | string | null
    showProduct?: BoolFilter | boolean
    hasUserDeleted?: BoolFilter | boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutChildrenInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: Enumerable<CategoryScalarWhereInput>
    OR?: Enumerable<CategoryScalarWhereInput>
    NOT?: Enumerable<CategoryScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    slug?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    parentId?: StringNullableFilter | string | null
    iconImageId?: StringNullableFilter | string | null
    bannerImageId?: StringNullableFilter | string | null
  }

  export type ProductAttributeUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductAttributeWhereUniqueInput
    update: XOR<ProductAttributeUpdateWithoutCategoryInput, ProductAttributeUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductAttributeCreateWithoutCategoryInput, ProductAttributeUncheckedCreateWithoutCategoryInput>
  }

  export type ProductAttributeUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductAttributeWhereUniqueInput
    data: XOR<ProductAttributeUpdateWithoutCategoryInput, ProductAttributeUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductAttributeUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductAttributeScalarWhereInput
    data: XOR<ProductAttributeUpdateManyMutationInput, ProductAttributeUncheckedUpdateManyWithoutAttributesInput>
  }

  export type ProductAttributeScalarWhereInput = {
    AND?: Enumerable<ProductAttributeScalarWhereInput>
    OR?: Enumerable<ProductAttributeScalarWhereInput>
    NOT?: Enumerable<ProductAttributeScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: StringFilter | string
    description?: StringNullableFilter | string | null
    global?: BoolFilter | boolean
    categoryId?: StringNullableFilter | string | null
    onlyForProductId?: StringNullableFilter | string | null
  }

  export type MediaCreateWithoutMarqueInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutMarqueInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutMarqueInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMarqueInput, MediaUncheckedCreateWithoutMarqueInput>
  }

  export type CategoryCreateWithoutMarquesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutMarquesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutMarquesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutMarquesInput, CategoryUncheckedCreateWithoutMarquesInput>
  }

  export type ProductCreateWithoutMarqueInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMarqueInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMarqueInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMarqueInput, ProductUncheckedCreateWithoutMarqueInput>
  }

  export type ProductCreateManyMarqueInputEnvelope = {
    data: Enumerable<ProductCreateManyMarqueInput>
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutMarqueInput = {
    update: XOR<MediaUpdateWithoutMarqueInput, MediaUncheckedUpdateWithoutMarqueInput>
    create: XOR<MediaCreateWithoutMarqueInput, MediaUncheckedCreateWithoutMarqueInput>
  }

  export type MediaUpdateWithoutMarqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutMarqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutMarquesInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutMarquesInput, CategoryUncheckedUpdateWithoutMarquesInput>
    create: XOR<CategoryCreateWithoutMarquesInput, CategoryUncheckedCreateWithoutMarquesInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutMarquesInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutMarquesInput, CategoryUncheckedUpdateWithoutMarquesInput>
  }

  export type CategoryUpdateManyWithWhereWithoutMarquesInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutMarqueInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutMarqueInput, ProductUncheckedUpdateWithoutMarqueInput>
    create: XOR<ProductCreateWithoutMarqueInput, ProductUncheckedCreateWithoutMarqueInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutMarqueInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutMarqueInput, ProductUncheckedUpdateWithoutMarqueInput>
  }

  export type ProductUpdateManyWithWhereWithoutMarqueInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type MediaCreateWithoutDiscountsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutDiscountsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutDiscountsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutDiscountsInput, MediaUncheckedCreateWithoutDiscountsInput>
  }

  export type CommandCreateWithoutAppliedDiscountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutAppliedDiscountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutAppliedDiscountInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutAppliedDiscountInput, CommandUncheckedCreateWithoutAppliedDiscountInput>
  }

  export type CommandCreateManyAppliedDiscountInputEnvelope = {
    data: Enumerable<CommandCreateManyAppliedDiscountInput>
    skipDuplicates?: boolean
  }

  export type PubCreateWithoutForDiscountInput = {
    id?: string
    name: string
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    bannerImage?: MediaCreateNestedOneWithoutPubsInput
  }

  export type PubUncheckedCreateWithoutForDiscountInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
  }

  export type PubCreateOrConnectWithoutForDiscountInput = {
    where: PubWhereUniqueInput
    create: XOR<PubCreateWithoutForDiscountInput, PubUncheckedCreateWithoutForDiscountInput>
  }

  export type PubCreateManyForDiscountInputEnvelope = {
    data: Enumerable<PubCreateManyForDiscountInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutDiscountsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDiscountsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDiscountsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDiscountsInput, ProductUncheckedCreateWithoutDiscountsInput>
  }

  export type MediaUpsertWithoutDiscountsInput = {
    update: XOR<MediaUpdateWithoutDiscountsInput, MediaUncheckedUpdateWithoutDiscountsInput>
    create: XOR<MediaCreateWithoutDiscountsInput, MediaUncheckedCreateWithoutDiscountsInput>
  }

  export type MediaUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type CommandUpsertWithWhereUniqueWithoutAppliedDiscountInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutAppliedDiscountInput, CommandUncheckedUpdateWithoutAppliedDiscountInput>
    create: XOR<CommandCreateWithoutAppliedDiscountInput, CommandUncheckedCreateWithoutAppliedDiscountInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutAppliedDiscountInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutAppliedDiscountInput, CommandUncheckedUpdateWithoutAppliedDiscountInput>
  }

  export type CommandUpdateManyWithWhereWithoutAppliedDiscountInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutCommandInput>
  }

  export type CommandScalarWhereInput = {
    AND?: Enumerable<CommandScalarWhereInput>
    OR?: Enumerable<CommandScalarWhereInput>
    NOT?: Enumerable<CommandScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    totalPrice?: IntFilter | number
    orderId?: IntFilter | number
    archived?: BoolNullableFilter | boolean | null
    delivered?: BoolFilter | boolean
    status?: StringFilter | string
    orderedById?: StringFilter | string
    hasUserCanceled?: BoolFilter | boolean
    hasUserDeleted?: BoolFilter | boolean
    shippingAdressId?: StringNullableFilter | string | null
    receiptId?: StringFilter | string
    appliedDiscountId?: StringNullableFilter | string | null
  }

  export type PubUpsertWithWhereUniqueWithoutForDiscountInput = {
    where: PubWhereUniqueInput
    update: XOR<PubUpdateWithoutForDiscountInput, PubUncheckedUpdateWithoutForDiscountInput>
    create: XOR<PubCreateWithoutForDiscountInput, PubUncheckedCreateWithoutForDiscountInput>
  }

  export type PubUpdateWithWhereUniqueWithoutForDiscountInput = {
    where: PubWhereUniqueInput
    data: XOR<PubUpdateWithoutForDiscountInput, PubUncheckedUpdateWithoutForDiscountInput>
  }

  export type PubUpdateManyWithWhereWithoutForDiscountInput = {
    where: PubScalarWhereInput
    data: XOR<PubUpdateManyMutationInput, PubUncheckedUpdateManyWithoutPubsInput>
  }

  export type PubScalarWhereInput = {
    AND?: Enumerable<PubScalarWhereInput>
    OR?: Enumerable<PubScalarWhereInput>
    NOT?: Enumerable<PubScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    bannerImageId?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    startAt?: DateTimeFilter | Date | string
    endAt?: DateTimeFilter | Date | string
    forDiscountId?: StringNullableFilter | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutDiscountsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutDiscountsInput, ProductUncheckedUpdateWithoutDiscountsInput>
    create: XOR<ProductCreateWithoutDiscountsInput, ProductUncheckedCreateWithoutDiscountsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutDiscountsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutDiscountsInput, ProductUncheckedUpdateWithoutDiscountsInput>
  }

  export type ProductUpdateManyWithWhereWithoutDiscountsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type CommandUnitProductCreateWithoutPriceRuleInput = {
    id?: string
    isDefault?: boolean
    unitPrice: number
    commandUnit: CommandUnitCreateNestedOneWithoutCommandUnitProductsInput
    product?: ProductCreateNestedOneWithoutCommandUnitProductsInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedCreateWithoutPriceRuleInput = {
    id?: string
    commandUnitId: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductCreateOrConnectWithoutPriceRuleInput = {
    where: CommandUnitProductWhereUniqueInput
    create: XOR<CommandUnitProductCreateWithoutPriceRuleInput, CommandUnitProductUncheckedCreateWithoutPriceRuleInput>
  }

  export type CommandUnitProductCreateManyPriceRuleInputEnvelope = {
    data: Enumerable<CommandUnitProductCreateManyPriceRuleInput>
    skipDuplicates?: boolean
  }

  export type CommandUnitProductUpsertWithWhereUniqueWithoutPriceRuleInput = {
    where: CommandUnitProductWhereUniqueInput
    update: XOR<CommandUnitProductUpdateWithoutPriceRuleInput, CommandUnitProductUncheckedUpdateWithoutPriceRuleInput>
    create: XOR<CommandUnitProductCreateWithoutPriceRuleInput, CommandUnitProductUncheckedCreateWithoutPriceRuleInput>
  }

  export type CommandUnitProductUpdateWithWhereUniqueWithoutPriceRuleInput = {
    where: CommandUnitProductWhereUniqueInput
    data: XOR<CommandUnitProductUpdateWithoutPriceRuleInput, CommandUnitProductUncheckedUpdateWithoutPriceRuleInput>
  }

  export type CommandUnitProductUpdateManyWithWhereWithoutPriceRuleInput = {
    where: CommandUnitProductScalarWhereInput
    data: XOR<CommandUnitProductUpdateManyMutationInput, CommandUnitProductUncheckedUpdateManyWithoutCommandUnitProductsInput>
  }

  export type CommandUnitProductScalarWhereInput = {
    AND?: Enumerable<CommandUnitProductScalarWhereInput>
    OR?: Enumerable<CommandUnitProductScalarWhereInput>
    NOT?: Enumerable<CommandUnitProductScalarWhereInput>
    id?: StringFilter | string
    commandUnitId?: StringFilter | string
    productId?: StringFilter | string
    isDefault?: BoolFilter | boolean
    unitPrice?: IntFilter | number
    priceRuleId?: StringFilter | string
  }

  export type MediaCreateWithoutPubsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutPubsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutPubsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPubsInput, MediaUncheckedCreateWithoutPubsInput>
  }

  export type DiscountCreateWithoutPubsInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    bannerImage?: MediaCreateNestedOneWithoutDiscountsInput
    command?: CommandCreateNestedManyWithoutAppliedDiscountInput
    product?: ProductCreateNestedManyWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateWithoutPubsInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    command?: CommandUncheckedCreateNestedManyWithoutAppliedDiscountInput
  }

  export type DiscountCreateOrConnectWithoutPubsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutPubsInput, DiscountUncheckedCreateWithoutPubsInput>
  }

  export type MediaUpsertWithoutPubsInput = {
    update: XOR<MediaUpdateWithoutPubsInput, MediaUncheckedUpdateWithoutPubsInput>
    create: XOR<MediaCreateWithoutPubsInput, MediaUncheckedCreateWithoutPubsInput>
  }

  export type MediaUpdateWithoutPubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutPubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type DiscountUpsertWithoutPubsInput = {
    update: XOR<DiscountUpdateWithoutPubsInput, DiscountUncheckedUpdateWithoutPubsInput>
    create: XOR<DiscountCreateWithoutPubsInput, DiscountUncheckedCreateWithoutPubsInput>
  }

  export type DiscountUpdateWithoutPubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImage?: MediaUpdateOneWithoutDiscountsInput
    command?: CommandUpdateManyWithoutAppliedDiscountInput
    product?: ProductUpdateManyWithoutDiscountsInput
  }

  export type DiscountUncheckedUpdateWithoutPubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUncheckedUpdateManyWithoutAppliedDiscountInput
  }

  export type UserShippingAdressCreateWithoutShippingZoneInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFile?: MediaCreateNestedOneWithoutUserShippingAdressesInput
    forUser: UserCreateNestedOneWithoutShippingAdressInput
    commands?: CommandCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedCreateWithoutShippingZoneInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    forUserId: string
    commands?: CommandUncheckedCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressCreateOrConnectWithoutShippingZoneInput = {
    where: UserShippingAdressWhereUniqueInput
    create: XOR<UserShippingAdressCreateWithoutShippingZoneInput, UserShippingAdressUncheckedCreateWithoutShippingZoneInput>
  }

  export type UserShippingAdressCreateManyShippingZoneInputEnvelope = {
    data: Enumerable<UserShippingAdressCreateManyShippingZoneInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutShippingZonesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutShippingZonesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutShippingZonesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutShippingZonesInput, ProductUncheckedCreateWithoutShippingZonesInput>
  }

  export type UserShippingAdressUpsertWithWhereUniqueWithoutShippingZoneInput = {
    where: UserShippingAdressWhereUniqueInput
    update: XOR<UserShippingAdressUpdateWithoutShippingZoneInput, UserShippingAdressUncheckedUpdateWithoutShippingZoneInput>
    create: XOR<UserShippingAdressCreateWithoutShippingZoneInput, UserShippingAdressUncheckedCreateWithoutShippingZoneInput>
  }

  export type UserShippingAdressUpdateWithWhereUniqueWithoutShippingZoneInput = {
    where: UserShippingAdressWhereUniqueInput
    data: XOR<UserShippingAdressUpdateWithoutShippingZoneInput, UserShippingAdressUncheckedUpdateWithoutShippingZoneInput>
  }

  export type UserShippingAdressUpdateManyWithWhereWithoutShippingZoneInput = {
    where: UserShippingAdressScalarWhereInput
    data: XOR<UserShippingAdressUpdateManyMutationInput, UserShippingAdressUncheckedUpdateManyWithoutUserShippingAdressInput>
  }

  export type UserShippingAdressScalarWhereInput = {
    AND?: Enumerable<UserShippingAdressScalarWhereInput>
    OR?: Enumerable<UserShippingAdressScalarWhereInput>
    NOT?: Enumerable<UserShippingAdressScalarWhereInput>
    id?: StringFilter | string
    shippingZoneId?: StringFilter | string
    fullName?: StringFilter | string
    phone?: StringFilter | string
    alternatePhone?: StringFilter | string
    adressType?: StringFilter | string
    quatier?: StringFilter | string
    hasUserDeleted?: BoolFilter | boolean
    additionalDetails?: StringNullableFilter | string | null
    audioFileId?: StringNullableFilter | string | null
    forUserId?: StringFilter | string
  }

  export type ProductUpsertWithWhereUniqueWithoutShippingZonesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutShippingZonesInput, ProductUncheckedUpdateWithoutShippingZonesInput>
    create: XOR<ProductCreateWithoutShippingZonesInput, ProductUncheckedCreateWithoutShippingZonesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutShippingZonesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutShippingZonesInput, ProductUncheckedUpdateWithoutShippingZonesInput>
  }

  export type ProductUpdateManyWithWhereWithoutShippingZonesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductAttributeCreateWithoutMetasInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    category?: CategoryCreateNestedOneWithoutAttributesInput
    onlyForProduct?: ProductCreateNestedOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedCreateWithoutMetasInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    categoryId?: string | null
    onlyForProductId?: string | null
  }

  export type ProductAttributeCreateOrConnectWithoutMetasInput = {
    where: ProductAttributeWhereUniqueInput
    create: XOR<ProductAttributeCreateWithoutMetasInput, ProductAttributeUncheckedCreateWithoutMetasInput>
  }

  export type ProductCreateWithoutVariationMetasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariationMetasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariationMetasInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariationMetasInput, ProductUncheckedCreateWithoutVariationMetasInput>
  }

  export type ProductAttributeUpsertWithoutMetasInput = {
    update: XOR<ProductAttributeUpdateWithoutMetasInput, ProductAttributeUncheckedUpdateWithoutMetasInput>
    create: XOR<ProductAttributeCreateWithoutMetasInput, ProductAttributeUncheckedCreateWithoutMetasInput>
  }

  export type ProductAttributeUpdateWithoutMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutAttributesInput
    onlyForProduct?: ProductUpdateOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedUpdateWithoutMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onlyForProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutVariationMetasInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVariationMetasInput, ProductUncheckedUpdateWithoutVariationMetasInput>
    create: XOR<ProductCreateWithoutVariationMetasInput, ProductUncheckedCreateWithoutVariationMetasInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVariationMetasInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVariationMetasInput, ProductUncheckedUpdateWithoutVariationMetasInput>
  }

  export type ProductUpdateManyWithWhereWithoutVariationMetasInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductAttributeMetaCreateWithoutAttributeInput = {
    id?: string
    name: string
    value: JsonNullValueInput | InputJsonValue
    products?: ProductCreateNestedManyWithoutVariationMetasInput
  }

  export type ProductAttributeMetaUncheckedCreateWithoutAttributeInput = {
    id?: string
    name: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaCreateOrConnectWithoutAttributeInput = {
    where: ProductAttributeMetaWhereUniqueInput
    create: XOR<ProductAttributeMetaCreateWithoutAttributeInput, ProductAttributeMetaUncheckedCreateWithoutAttributeInput>
  }

  export type ProductAttributeMetaCreateManyAttributeInputEnvelope = {
    data: Enumerable<ProductAttributeMetaCreateManyAttributeInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutAttributesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutAttributesInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutAttributesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutAttributesInput, CategoryUncheckedCreateWithoutAttributesInput>
  }

  export type ProductCreateWithoutProductAttributesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductAttributesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductAttributesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductAttributesInput, ProductUncheckedCreateWithoutProductAttributesInput>
  }

  export type ProductAttributeMetaUpsertWithWhereUniqueWithoutAttributeInput = {
    where: ProductAttributeMetaWhereUniqueInput
    update: XOR<ProductAttributeMetaUpdateWithoutAttributeInput, ProductAttributeMetaUncheckedUpdateWithoutAttributeInput>
    create: XOR<ProductAttributeMetaCreateWithoutAttributeInput, ProductAttributeMetaUncheckedCreateWithoutAttributeInput>
  }

  export type ProductAttributeMetaUpdateWithWhereUniqueWithoutAttributeInput = {
    where: ProductAttributeMetaWhereUniqueInput
    data: XOR<ProductAttributeMetaUpdateWithoutAttributeInput, ProductAttributeMetaUncheckedUpdateWithoutAttributeInput>
  }

  export type ProductAttributeMetaUpdateManyWithWhereWithoutAttributeInput = {
    where: ProductAttributeMetaScalarWhereInput
    data: XOR<ProductAttributeMetaUpdateManyMutationInput, ProductAttributeMetaUncheckedUpdateManyWithoutMetasInput>
  }

  export type ProductAttributeMetaScalarWhereInput = {
    AND?: Enumerable<ProductAttributeMetaScalarWhereInput>
    OR?: Enumerable<ProductAttributeMetaScalarWhereInput>
    NOT?: Enumerable<ProductAttributeMetaScalarWhereInput>
    id?: StringFilter | string
    attributeId?: StringFilter | string
    name?: StringFilter | string
    value?: JsonFilter
  }

  export type CategoryUpsertWithoutAttributesInput = {
    update: XOR<CategoryUpdateWithoutAttributesInput, CategoryUncheckedUpdateWithoutAttributesInput>
    create: XOR<CategoryCreateWithoutAttributesInput, CategoryUncheckedCreateWithoutAttributesInput>
  }

  export type CategoryUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
  }

  export type CategoryUncheckedUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
  }

  export type ProductUpsertWithoutProductAttributesInput = {
    update: XOR<ProductUpdateWithoutProductAttributesInput, ProductUncheckedUpdateWithoutProductAttributesInput>
    create: XOR<ProductCreateWithoutProductAttributesInput, ProductUncheckedCreateWithoutProductAttributesInput>
  }

  export type ProductUpdateWithoutProductAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTagsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutTagsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTagsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
  }

  export type ProductUpdateManyWithWhereWithoutTagsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type CommandUnitProductCreateWithoutCommandUnitInput = {
    id?: string
    isDefault?: boolean
    unitPrice: number
    product?: ProductCreateNestedOneWithoutCommandUnitProductsInput
    priceRule: PriceRuleCreateNestedOneWithoutCommandUnitProductsInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedCreateWithoutCommandUnitInput = {
    id?: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductCreateOrConnectWithoutCommandUnitInput = {
    where: CommandUnitProductWhereUniqueInput
    create: XOR<CommandUnitProductCreateWithoutCommandUnitInput, CommandUnitProductUncheckedCreateWithoutCommandUnitInput>
  }

  export type CommandUnitProductCreateManyCommandUnitInputEnvelope = {
    data: Enumerable<CommandUnitProductCreateManyCommandUnitInput>
    skipDuplicates?: boolean
  }

  export type CommandUnitProductUpsertWithWhereUniqueWithoutCommandUnitInput = {
    where: CommandUnitProductWhereUniqueInput
    update: XOR<CommandUnitProductUpdateWithoutCommandUnitInput, CommandUnitProductUncheckedUpdateWithoutCommandUnitInput>
    create: XOR<CommandUnitProductCreateWithoutCommandUnitInput, CommandUnitProductUncheckedCreateWithoutCommandUnitInput>
  }

  export type CommandUnitProductUpdateWithWhereUniqueWithoutCommandUnitInput = {
    where: CommandUnitProductWhereUniqueInput
    data: XOR<CommandUnitProductUpdateWithoutCommandUnitInput, CommandUnitProductUncheckedUpdateWithoutCommandUnitInput>
  }

  export type CommandUnitProductUpdateManyWithWhereWithoutCommandUnitInput = {
    where: CommandUnitProductScalarWhereInput
    data: XOR<CommandUnitProductUpdateManyMutationInput, CommandUnitProductUncheckedUpdateManyWithoutCommandUnitProductsInput>
  }

  export type CommandUnitCreateWithoutCommandUnitProductsInput = {
    id?: string
    title: string
    shortCode: string
  }

  export type CommandUnitUncheckedCreateWithoutCommandUnitProductsInput = {
    id?: string
    title: string
    shortCode: string
  }

  export type CommandUnitCreateOrConnectWithoutCommandUnitProductsInput = {
    where: CommandUnitWhereUniqueInput
    create: XOR<CommandUnitCreateWithoutCommandUnitProductsInput, CommandUnitUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type ProductCreateWithoutCommandUnitProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCommandUnitProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCommandUnitProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCommandUnitProductsInput, ProductUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type PriceRuleCreateWithoutCommandUnitProductsInput = {
    id?: string
    minPrice: number
    maxPrice?: number | null
    amountPercent: number
  }

  export type PriceRuleUncheckedCreateWithoutCommandUnitProductsInput = {
    id?: string
    minPrice: number
    maxPrice?: number | null
    amountPercent: number
  }

  export type PriceRuleCreateOrConnectWithoutCommandUnitProductsInput = {
    where: PriceRuleWhereUniqueInput
    create: XOR<PriceRuleCreateWithoutCommandUnitProductsInput, PriceRuleUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type CommandProductCreateWithoutCommandUnitProductInput = {
    id?: string
    hasUserDeleted?: boolean
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
    product: ProductCreateNestedOneWithoutCommandProductsInput
    command: CommandCreateNestedOneWithoutCommandProductsInput
  }

  export type CommandProductUncheckedCreateWithoutCommandUnitProductInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductCreateOrConnectWithoutCommandUnitProductInput = {
    where: CommandProductWhereUniqueInput
    create: XOR<CommandProductCreateWithoutCommandUnitProductInput, CommandProductUncheckedCreateWithoutCommandUnitProductInput>
  }

  export type CommandProductCreateManyCommandUnitProductInputEnvelope = {
    data: Enumerable<CommandProductCreateManyCommandUnitProductInput>
    skipDuplicates?: boolean
  }

  export type CommandUnitUpsertWithoutCommandUnitProductsInput = {
    update: XOR<CommandUnitUpdateWithoutCommandUnitProductsInput, CommandUnitUncheckedUpdateWithoutCommandUnitProductsInput>
    create: XOR<CommandUnitCreateWithoutCommandUnitProductsInput, CommandUnitUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type CommandUnitUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUnitUncheckedUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpsertWithoutCommandUnitProductsInput = {
    update: XOR<ProductUpdateWithoutCommandUnitProductsInput, ProductUncheckedUpdateWithoutCommandUnitProductsInput>
    create: XOR<ProductCreateWithoutCommandUnitProductsInput, ProductUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type ProductUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type PriceRuleUpsertWithoutCommandUnitProductsInput = {
    update: XOR<PriceRuleUpdateWithoutCommandUnitProductsInput, PriceRuleUncheckedUpdateWithoutCommandUnitProductsInput>
    create: XOR<PriceRuleCreateWithoutCommandUnitProductsInput, PriceRuleUncheckedCreateWithoutCommandUnitProductsInput>
  }

  export type PriceRuleUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
  }

  export type PriceRuleUncheckedUpdateWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    minPrice?: IntFieldUpdateOperationsInput | number
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    amountPercent?: IntFieldUpdateOperationsInput | number
  }

  export type CommandProductUpsertWithWhereUniqueWithoutCommandUnitProductInput = {
    where: CommandProductWhereUniqueInput
    update: XOR<CommandProductUpdateWithoutCommandUnitProductInput, CommandProductUncheckedUpdateWithoutCommandUnitProductInput>
    create: XOR<CommandProductCreateWithoutCommandUnitProductInput, CommandProductUncheckedCreateWithoutCommandUnitProductInput>
  }

  export type CommandProductUpdateWithWhereUniqueWithoutCommandUnitProductInput = {
    where: CommandProductWhereUniqueInput
    data: XOR<CommandProductUpdateWithoutCommandUnitProductInput, CommandProductUncheckedUpdateWithoutCommandUnitProductInput>
  }

  export type CommandProductUpdateManyWithWhereWithoutCommandUnitProductInput = {
    where: CommandProductScalarWhereInput
    data: XOR<CommandProductUpdateManyMutationInput, CommandProductUncheckedUpdateManyWithoutCommandProductsInput>
  }

  export type CommandProductScalarWhereInput = {
    AND?: Enumerable<CommandProductScalarWhereInput>
    OR?: Enumerable<CommandProductScalarWhereInput>
    NOT?: Enumerable<CommandProductScalarWhereInput>
    id?: StringFilter | string
    productId?: StringFilter | string
    hasUserDeleted?: BoolFilter | boolean
    commandUnitProductId?: StringFilter | string
    quantite?: IntFilter | number
    commandId?: StringFilter | string
    hasCustomerConfirmShipping?: BoolFilter | boolean
    hasAgentConfirmShipping?: BoolFilter | boolean
  }

  export type ProductCreateWithoutMediasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMediasInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMediasInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
  }

  export type CategoryCreateWithoutIconImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutIconImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutIconImageInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutIconImageInput, CategoryUncheckedCreateWithoutIconImageInput>
  }

  export type CategoryCreateManyIconImageInputEnvelope = {
    data: Enumerable<CategoryCreateManyIconImageInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutBannerImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    products?: ProductCreateNestedManyWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBannerImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBannerImageInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBannerImageInput, CategoryUncheckedCreateWithoutBannerImageInput>
  }

  export type CategoryCreateManyBannerImageInputEnvelope = {
    data: Enumerable<CategoryCreateManyBannerImageInput>
    skipDuplicates?: boolean
  }

  export type MarqueCreateWithoutImageInput = {
    id?: string
    name: string
    categoryId: string
    category?: CategoryCreateNestedManyWithoutMarquesInput
    products?: ProductCreateNestedManyWithoutMarqueInput
  }

  export type MarqueUncheckedCreateWithoutImageInput = {
    id?: string
    name: string
    categoryId: string
    products?: ProductUncheckedCreateNestedManyWithoutMarqueInput
  }

  export type MarqueCreateOrConnectWithoutImageInput = {
    where: MarqueWhereUniqueInput
    create: XOR<MarqueCreateWithoutImageInput, MarqueUncheckedCreateWithoutImageInput>
  }

  export type MarqueCreateManyImageInputEnvelope = {
    data: Enumerable<MarqueCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type PubCreateWithoutBannerImageInput = {
    id?: string
    name: string
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    forDiscount?: DiscountCreateNestedOneWithoutPubsInput
  }

  export type PubUncheckedCreateWithoutBannerImageInput = {
    id?: string
    name: string
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    forDiscountId?: string | null
  }

  export type PubCreateOrConnectWithoutBannerImageInput = {
    where: PubWhereUniqueInput
    create: XOR<PubCreateWithoutBannerImageInput, PubUncheckedCreateWithoutBannerImageInput>
  }

  export type PubCreateManyBannerImageInputEnvelope = {
    data: Enumerable<PubCreateManyBannerImageInput>
    skipDuplicates?: boolean
  }

  export type UserShippingAdressCreateWithoutAudioFileInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    shippingZone: ShippingZoneCreateNestedOneWithoutUserShippingAdressInput
    forUser: UserCreateNestedOneWithoutShippingAdressInput
    commands?: CommandCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedCreateWithoutAudioFileInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    forUserId: string
    commands?: CommandUncheckedCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressCreateOrConnectWithoutAudioFileInput = {
    where: UserShippingAdressWhereUniqueInput
    create: XOR<UserShippingAdressCreateWithoutAudioFileInput, UserShippingAdressUncheckedCreateWithoutAudioFileInput>
  }

  export type UserShippingAdressCreateManyAudioFileInputEnvelope = {
    data: Enumerable<UserShippingAdressCreateManyAudioFileInput>
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutBannerImageInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    command?: CommandCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubCreateNestedManyWithoutForDiscountInput
    product?: ProductCreateNestedManyWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateWithoutBannerImageInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    command?: CommandUncheckedCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedCreateNestedManyWithoutForDiscountInput
  }

  export type DiscountCreateOrConnectWithoutBannerImageInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutBannerImageInput, DiscountUncheckedCreateWithoutBannerImageInput>
  }

  export type DiscountCreateManyBannerImageInputEnvelope = {
    data: Enumerable<DiscountCreateManyBannerImageInput>
    skipDuplicates?: boolean
  }

  export type ReceiptCreateWithoutReceiptMediaInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    command?: CommandCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateWithoutReceiptMediaInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    command?: CommandUncheckedCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptCreateOrConnectWithoutReceiptMediaInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutReceiptMediaInput, ReceiptUncheckedCreateWithoutReceiptMediaInput>
  }

  export type ReceiptCreateManyReceiptMediaInputEnvelope = {
    data: Enumerable<ReceiptCreateManyReceiptMediaInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProfileImageInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    commands?: CommandCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressCreateNestedManyWithoutForUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileImageInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    commands?: CommandUncheckedCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutForUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileImageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutMediasInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutMediasInput, ProductUncheckedUpdateWithoutMediasInput>
    create: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutMediasInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutMediasInput, ProductUncheckedUpdateWithoutMediasInput>
  }

  export type ProductUpdateManyWithWhereWithoutMediasInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutIconImageInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutIconImageInput, CategoryUncheckedUpdateWithoutIconImageInput>
    create: XOR<CategoryCreateWithoutIconImageInput, CategoryUncheckedCreateWithoutIconImageInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutIconImageInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutIconImageInput, CategoryUncheckedUpdateWithoutIconImageInput>
  }

  export type CategoryUpdateManyWithWhereWithoutIconImageInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutIconImagesCategoriesInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutBannerImageInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutBannerImageInput, CategoryUncheckedUpdateWithoutBannerImageInput>
    create: XOR<CategoryCreateWithoutBannerImageInput, CategoryUncheckedCreateWithoutBannerImageInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutBannerImageInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutBannerImageInput, CategoryUncheckedUpdateWithoutBannerImageInput>
  }

  export type CategoryUpdateManyWithWhereWithoutBannerImageInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutBannerImagesCategoriesInput>
  }

  export type MarqueUpsertWithWhereUniqueWithoutImageInput = {
    where: MarqueWhereUniqueInput
    update: XOR<MarqueUpdateWithoutImageInput, MarqueUncheckedUpdateWithoutImageInput>
    create: XOR<MarqueCreateWithoutImageInput, MarqueUncheckedCreateWithoutImageInput>
  }

  export type MarqueUpdateWithWhereUniqueWithoutImageInput = {
    where: MarqueWhereUniqueInput
    data: XOR<MarqueUpdateWithoutImageInput, MarqueUncheckedUpdateWithoutImageInput>
  }

  export type MarqueUpdateManyWithWhereWithoutImageInput = {
    where: MarqueScalarWhereInput
    data: XOR<MarqueUpdateManyMutationInput, MarqueUncheckedUpdateManyWithoutMarqueInput>
  }

  export type PubUpsertWithWhereUniqueWithoutBannerImageInput = {
    where: PubWhereUniqueInput
    update: XOR<PubUpdateWithoutBannerImageInput, PubUncheckedUpdateWithoutBannerImageInput>
    create: XOR<PubCreateWithoutBannerImageInput, PubUncheckedCreateWithoutBannerImageInput>
  }

  export type PubUpdateWithWhereUniqueWithoutBannerImageInput = {
    where: PubWhereUniqueInput
    data: XOR<PubUpdateWithoutBannerImageInput, PubUncheckedUpdateWithoutBannerImageInput>
  }

  export type PubUpdateManyWithWhereWithoutBannerImageInput = {
    where: PubScalarWhereInput
    data: XOR<PubUpdateManyMutationInput, PubUncheckedUpdateManyWithoutPubsInput>
  }

  export type UserShippingAdressUpsertWithWhereUniqueWithoutAudioFileInput = {
    where: UserShippingAdressWhereUniqueInput
    update: XOR<UserShippingAdressUpdateWithoutAudioFileInput, UserShippingAdressUncheckedUpdateWithoutAudioFileInput>
    create: XOR<UserShippingAdressCreateWithoutAudioFileInput, UserShippingAdressUncheckedCreateWithoutAudioFileInput>
  }

  export type UserShippingAdressUpdateWithWhereUniqueWithoutAudioFileInput = {
    where: UserShippingAdressWhereUniqueInput
    data: XOR<UserShippingAdressUpdateWithoutAudioFileInput, UserShippingAdressUncheckedUpdateWithoutAudioFileInput>
  }

  export type UserShippingAdressUpdateManyWithWhereWithoutAudioFileInput = {
    where: UserShippingAdressScalarWhereInput
    data: XOR<UserShippingAdressUpdateManyMutationInput, UserShippingAdressUncheckedUpdateManyWithoutUserShippingAdressesInput>
  }

  export type DiscountUpsertWithWhereUniqueWithoutBannerImageInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutBannerImageInput, DiscountUncheckedUpdateWithoutBannerImageInput>
    create: XOR<DiscountCreateWithoutBannerImageInput, DiscountUncheckedCreateWithoutBannerImageInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutBannerImageInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutBannerImageInput, DiscountUncheckedUpdateWithoutBannerImageInput>
  }

  export type DiscountUpdateManyWithWhereWithoutBannerImageInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: Enumerable<DiscountScalarWhereInput>
    OR?: Enumerable<DiscountScalarWhereInput>
    NOT?: Enumerable<DiscountScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    bannerImageId?: StringNullableFilter | string | null
    discountType?: StringFilter | string
    discountNature?: StringFilter | string
    discountCode?: StringFilter | string
    discount?: IntFilter | number
    startAt?: DateTimeFilter | Date | string
    endAt?: DateTimeFilter | Date | string
    inCartProductMin?: IntNullableFilter | number | null
    inCartProductMax?: IntNullableFilter | number | null
    commandAmountMin?: IntNullableFilter | number | null
    commandAmountMax?: IntNullableFilter | number | null
    description?: StringNullableFilter | string | null
  }

  export type ReceiptUpsertWithWhereUniqueWithoutReceiptMediaInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutReceiptMediaInput, ReceiptUncheckedUpdateWithoutReceiptMediaInput>
    create: XOR<ReceiptCreateWithoutReceiptMediaInput, ReceiptUncheckedCreateWithoutReceiptMediaInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutReceiptMediaInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutReceiptMediaInput, ReceiptUncheckedUpdateWithoutReceiptMediaInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutReceiptMediaInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutReceiptMediasInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: Enumerable<ReceiptScalarWhereInput>
    OR?: Enumerable<ReceiptScalarWhereInput>
    NOT?: Enumerable<ReceiptScalarWhereInput>
    id?: StringFilter | string
    amount?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    hasUserDeleted?: BoolFilter | boolean
    paidAt?: DateTimeNullableFilter | Date | string | null
    isPaid?: BoolFilter | boolean
    outPaymentId?: StringNullableFilter | string | null
    outPaymentDetails?: JsonNullableFilter
    receiptMetas?: JsonFilter
    receiptMediaId?: StringNullableFilter | string | null
  }

  export type UserUpsertWithoutProfileImageInput = {
    update: XOR<UserUpdateWithoutProfileImageInput, UserUncheckedUpdateWithoutProfileImageInput>
    create: XOR<UserCreateWithoutProfileImageInput, UserUncheckedCreateWithoutProfileImageInput>
  }

  export type UserUpdateWithoutProfileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    commands?: CommandUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUpdateManyWithoutForUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProfileImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    commands?: CommandUncheckedUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutForUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
  }

  export type MarqueCreateWithoutProductsInput = {
    id?: string
    name: string
    categoryId: string
    image?: MediaCreateNestedOneWithoutMarqueInput
    category?: CategoryCreateNestedManyWithoutMarquesInput
  }

  export type MarqueUncheckedCreateWithoutProductsInput = {
    id?: string
    imageId?: string | null
    name: string
    categoryId: string
  }

  export type MarqueCreateOrConnectWithoutProductsInput = {
    where: MarqueWhereUniqueInput
    create: XOR<MarqueCreateWithoutProductsInput, MarqueUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutVariationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
  }

  export type ProductAttributeCreateWithoutOnlyForProductInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    metas?: ProductAttributeMetaCreateNestedManyWithoutAttributeInput
    category?: CategoryCreateNestedOneWithoutAttributesInput
  }

  export type ProductAttributeUncheckedCreateWithoutOnlyForProductInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    categoryId?: string | null
    metas?: ProductAttributeMetaUncheckedCreateNestedManyWithoutAttributeInput
  }

  export type ProductAttributeCreateOrConnectWithoutOnlyForProductInput = {
    where: ProductAttributeWhereUniqueInput
    create: XOR<ProductAttributeCreateWithoutOnlyForProductInput, ProductAttributeUncheckedCreateWithoutOnlyForProductInput>
  }

  export type ProductAttributeCreateManyOnlyForProductInputEnvelope = {
    data: Enumerable<ProductAttributeCreateManyOnlyForProductInput>
    skipDuplicates?: boolean
  }

  export type ProductAttributeMetaCreateWithoutProductsInput = {
    id?: string
    name: string
    value: JsonNullValueInput | InputJsonValue
    attribute: ProductAttributeCreateNestedOneWithoutMetasInput
  }

  export type ProductAttributeMetaUncheckedCreateWithoutProductsInput = {
    id?: string
    attributeId: string
    name: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaCreateOrConnectWithoutProductsInput = {
    where: ProductAttributeMetaWhereUniqueInput
    create: XOR<ProductAttributeMetaCreateWithoutProductsInput, ProductAttributeMetaUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutVariantParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariantParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariantParentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantParentInput, ProductUncheckedCreateWithoutVariantParentInput>
  }

  export type ProductCreateManyVariantParentInputEnvelope = {
    data: Enumerable<ProductCreateManyVariantParentInput>
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    iconImage?: MediaCreateNestedOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaCreateNestedOneWithoutBannerImagesCategoriesInput
    marques?: MarqueCreateNestedManyWithoutCategoryInput
    children?: CategoryCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
    bannerImageId?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    attributes?: ProductAttributeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ShippingZoneCreateWithoutProductsInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
    userShippingAdress?: UserShippingAdressCreateNestedManyWithoutShippingZoneInput
  }

  export type ShippingZoneUncheckedCreateWithoutProductsInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
    userShippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutShippingZoneInput
  }

  export type ShippingZoneCreateOrConnectWithoutProductsInput = {
    where: ShippingZoneWhereUniqueInput
    create: XOR<ShippingZoneCreateWithoutProductsInput, ShippingZoneUncheckedCreateWithoutProductsInput>
  }

  export type TagCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
  }

  export type TagCreateOrConnectWithoutProductsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
  }

  export type MediaCreateWithoutProductsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutProductsInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutProductsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
  }

  export type CommandUnitProductCreateWithoutProductInput = {
    id?: string
    isDefault?: boolean
    unitPrice: number
    commandUnit: CommandUnitCreateNestedOneWithoutCommandUnitProductsInput
    priceRule: PriceRuleCreateNestedOneWithoutCommandUnitProductsInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedCreateWithoutProductInput = {
    id?: string
    commandUnitId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductCreateOrConnectWithoutProductInput = {
    where: CommandUnitProductWhereUniqueInput
    create: XOR<CommandUnitProductCreateWithoutProductInput, CommandUnitProductUncheckedCreateWithoutProductInput>
  }

  export type CommandUnitProductCreateManyProductInputEnvelope = {
    data: Enumerable<CommandUnitProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CommandProductCreateWithoutProductInput = {
    id?: string
    hasUserDeleted?: boolean
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
    commandUnitProduct?: CommandUnitProductCreateNestedOneWithoutCommandProductsInput
    command: CommandCreateNestedOneWithoutCommandProductsInput
  }

  export type CommandProductUncheckedCreateWithoutProductInput = {
    id?: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductCreateOrConnectWithoutProductInput = {
    where: CommandProductWhereUniqueInput
    create: XOR<CommandProductCreateWithoutProductInput, CommandProductUncheckedCreateWithoutProductInput>
  }

  export type CommandProductCreateManyProductInputEnvelope = {
    data: Enumerable<CommandProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutProductInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    bannerImage?: MediaCreateNestedOneWithoutDiscountsInput
    command?: CommandCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubCreateNestedManyWithoutForDiscountInput
  }

  export type DiscountUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    command?: CommandUncheckedCreateNestedManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedCreateNestedManyWithoutForDiscountInput
  }

  export type DiscountCreateOrConnectWithoutProductInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput>
  }

  export type MarqueUpsertWithoutProductsInput = {
    update: XOR<MarqueUpdateWithoutProductsInput, MarqueUncheckedUpdateWithoutProductsInput>
    create: XOR<MarqueCreateWithoutProductsInput, MarqueUncheckedCreateWithoutProductsInput>
  }

  export type MarqueUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    image?: MediaUpdateOneWithoutMarqueInput
    category?: CategoryUpdateManyWithoutMarquesInput
  }

  export type MarqueUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpsertWithoutVariationsInput = {
    update: XOR<ProductUpdateWithoutVariationsInput, ProductUncheckedUpdateWithoutVariationsInput>
    create: XOR<ProductCreateWithoutVariationsInput, ProductUncheckedCreateWithoutVariationsInput>
  }

  export type ProductUpdateWithoutVariationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutVariationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductAttributeUpsertWithWhereUniqueWithoutOnlyForProductInput = {
    where: ProductAttributeWhereUniqueInput
    update: XOR<ProductAttributeUpdateWithoutOnlyForProductInput, ProductAttributeUncheckedUpdateWithoutOnlyForProductInput>
    create: XOR<ProductAttributeCreateWithoutOnlyForProductInput, ProductAttributeUncheckedCreateWithoutOnlyForProductInput>
  }

  export type ProductAttributeUpdateWithWhereUniqueWithoutOnlyForProductInput = {
    where: ProductAttributeWhereUniqueInput
    data: XOR<ProductAttributeUpdateWithoutOnlyForProductInput, ProductAttributeUncheckedUpdateWithoutOnlyForProductInput>
  }

  export type ProductAttributeUpdateManyWithWhereWithoutOnlyForProductInput = {
    where: ProductAttributeScalarWhereInput
    data: XOR<ProductAttributeUpdateManyMutationInput, ProductAttributeUncheckedUpdateManyWithoutProductAttributesInput>
  }

  export type ProductAttributeMetaUpsertWithWhereUniqueWithoutProductsInput = {
    where: ProductAttributeMetaWhereUniqueInput
    update: XOR<ProductAttributeMetaUpdateWithoutProductsInput, ProductAttributeMetaUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductAttributeMetaCreateWithoutProductsInput, ProductAttributeMetaUncheckedCreateWithoutProductsInput>
  }

  export type ProductAttributeMetaUpdateWithWhereUniqueWithoutProductsInput = {
    where: ProductAttributeMetaWhereUniqueInput
    data: XOR<ProductAttributeMetaUpdateWithoutProductsInput, ProductAttributeMetaUncheckedUpdateWithoutProductsInput>
  }

  export type ProductAttributeMetaUpdateManyWithWhereWithoutProductsInput = {
    where: ProductAttributeMetaScalarWhereInput
    data: XOR<ProductAttributeMetaUpdateManyMutationInput, ProductAttributeMetaUncheckedUpdateManyWithoutVariationMetasInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutVariantParentInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVariantParentInput, ProductUncheckedUpdateWithoutVariantParentInput>
    create: XOR<ProductCreateWithoutVariantParentInput, ProductUncheckedCreateWithoutVariantParentInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVariantParentInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVariantParentInput, ProductUncheckedUpdateWithoutVariantParentInput>
  }

  export type ProductUpdateManyWithWhereWithoutVariantParentInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVariationsInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutProductsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ShippingZoneUpsertWithWhereUniqueWithoutProductsInput = {
    where: ShippingZoneWhereUniqueInput
    update: XOR<ShippingZoneUpdateWithoutProductsInput, ShippingZoneUncheckedUpdateWithoutProductsInput>
    create: XOR<ShippingZoneCreateWithoutProductsInput, ShippingZoneUncheckedCreateWithoutProductsInput>
  }

  export type ShippingZoneUpdateWithWhereUniqueWithoutProductsInput = {
    where: ShippingZoneWhereUniqueInput
    data: XOR<ShippingZoneUpdateWithoutProductsInput, ShippingZoneUncheckedUpdateWithoutProductsInput>
  }

  export type ShippingZoneUpdateManyWithWhereWithoutProductsInput = {
    where: ShippingZoneScalarWhereInput
    data: XOR<ShippingZoneUpdateManyMutationInput, ShippingZoneUncheckedUpdateManyWithoutShippingZonesInput>
  }

  export type ShippingZoneScalarWhereInput = {
    AND?: Enumerable<ShippingZoneScalarWhereInput>
    OR?: Enumerable<ShippingZoneScalarWhereInput>
    NOT?: Enumerable<ShippingZoneScalarWhereInput>
    id?: StringFilter | string
    townName?: StringFilter | string
    townCode?: StringFilter | string
    baseShippingPrice?: IntFilter | number
  }

  export type TagUpsertWithWhereUniqueWithoutProductsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutProductsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
  }

  export type TagUpdateManyWithWhereWithoutProductsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagsInput>
  }

  export type TagScalarWhereInput = {
    AND?: Enumerable<TagScalarWhereInput>
    OR?: Enumerable<TagScalarWhereInput>
    NOT?: Enumerable<TagScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    slug?: StringFilter | string
  }

  export type MediaUpsertWithWhereUniqueWithoutProductsInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProductsInput, MediaUncheckedUpdateWithoutProductsInput>
    create: XOR<MediaCreateWithoutProductsInput, MediaUncheckedCreateWithoutProductsInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProductsInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProductsInput, MediaUncheckedUpdateWithoutProductsInput>
  }

  export type MediaUpdateManyWithWhereWithoutProductsInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutMediasInput>
  }

  export type MediaScalarWhereInput = {
    AND?: Enumerable<MediaScalarWhereInput>
    OR?: Enumerable<MediaScalarWhereInput>
    NOT?: Enumerable<MediaScalarWhereInput>
    id?: StringFilter | string
    filename?: StringFilter | string
    fileType?: StringFilter | string
    path?: StringFilter | string
    fileDuration?: FloatNullableFilter | number | null
    source?: StringFilter | string
    userId?: StringNullableFilter | string | null
  }

  export type CommandUnitProductUpsertWithWhereUniqueWithoutProductInput = {
    where: CommandUnitProductWhereUniqueInput
    update: XOR<CommandUnitProductUpdateWithoutProductInput, CommandUnitProductUncheckedUpdateWithoutProductInput>
    create: XOR<CommandUnitProductCreateWithoutProductInput, CommandUnitProductUncheckedCreateWithoutProductInput>
  }

  export type CommandUnitProductUpdateWithWhereUniqueWithoutProductInput = {
    where: CommandUnitProductWhereUniqueInput
    data: XOR<CommandUnitProductUpdateWithoutProductInput, CommandUnitProductUncheckedUpdateWithoutProductInput>
  }

  export type CommandUnitProductUpdateManyWithWhereWithoutProductInput = {
    where: CommandUnitProductScalarWhereInput
    data: XOR<CommandUnitProductUpdateManyMutationInput, CommandUnitProductUncheckedUpdateManyWithoutCommandUnitProductsInput>
  }

  export type CommandProductUpsertWithWhereUniqueWithoutProductInput = {
    where: CommandProductWhereUniqueInput
    update: XOR<CommandProductUpdateWithoutProductInput, CommandProductUncheckedUpdateWithoutProductInput>
    create: XOR<CommandProductCreateWithoutProductInput, CommandProductUncheckedCreateWithoutProductInput>
  }

  export type CommandProductUpdateWithWhereUniqueWithoutProductInput = {
    where: CommandProductWhereUniqueInput
    data: XOR<CommandProductUpdateWithoutProductInput, CommandProductUncheckedUpdateWithoutProductInput>
  }

  export type CommandProductUpdateManyWithWhereWithoutProductInput = {
    where: CommandProductScalarWhereInput
    data: XOR<CommandProductUpdateManyMutationInput, CommandProductUncheckedUpdateManyWithoutCommandProductsInput>
  }

  export type DiscountUpsertWithWhereUniqueWithoutProductInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutProductInput, DiscountUncheckedUpdateWithoutProductInput>
    create: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutProductInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutProductInput, DiscountUncheckedUpdateWithoutProductInput>
  }

  export type DiscountUpdateManyWithWhereWithoutProductInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutDiscountsInput>
  }

  export type CommandCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutNotificationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutNotificationsInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutNotificationsInput, CommandUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaCreateNestedOneWithoutForUserInput
    commands?: CommandCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressCreateNestedManyWithoutForUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaUncheckedCreateNestedOneWithoutForUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutForUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type CommandUpsertWithoutNotificationsInput = {
    update: XOR<CommandUpdateWithoutNotificationsInput, CommandUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CommandCreateWithoutNotificationsInput, CommandUncheckedCreateWithoutNotificationsInput>
  }

  export type CommandUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUpdateOneWithoutForUserInput
    commands?: CommandUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUpdateManyWithoutForUserInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUncheckedUpdateOneWithoutForUserInput
    commands?: CommandUncheckedUpdateManyWithoutOrderedByInput
    shippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutForUserInput
  }

  export type MediaCreateWithoutForUserInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaUncheckedCreateWithoutForUserInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutForUserInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
  }

  export type CommandCreateWithoutOrderedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutOrderedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutOrderedByInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutOrderedByInput, CommandUncheckedCreateWithoutOrderedByInput>
  }

  export type CommandCreateManyOrderedByInputEnvelope = {
    data: Enumerable<CommandCreateManyOrderedByInput>
    skipDuplicates?: boolean
  }

  export type UserShippingAdressCreateWithoutForUserInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    shippingZone: ShippingZoneCreateNestedOneWithoutUserShippingAdressInput
    audioFile?: MediaCreateNestedOneWithoutUserShippingAdressesInput
    commands?: CommandCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedCreateWithoutForUserInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    commands?: CommandUncheckedCreateNestedManyWithoutShippingAdressInput
  }

  export type UserShippingAdressCreateOrConnectWithoutForUserInput = {
    where: UserShippingAdressWhereUniqueInput
    create: XOR<UserShippingAdressCreateWithoutForUserInput, UserShippingAdressUncheckedCreateWithoutForUserInput>
  }

  export type UserShippingAdressCreateManyForUserInputEnvelope = {
    data: Enumerable<UserShippingAdressCreateManyForUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    hasUserRead?: boolean
    command?: CommandCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    commandId?: string | null
    hasUserRead?: boolean
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutForUserInput = {
    update: XOR<MediaUpdateWithoutForUserInput, MediaUncheckedUpdateWithoutForUserInput>
    create: XOR<MediaCreateWithoutForUserInput, MediaUncheckedCreateWithoutForUserInput>
  }

  export type MediaUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
  }

  export type MediaUncheckedUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type CommandUpsertWithWhereUniqueWithoutOrderedByInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutOrderedByInput, CommandUncheckedUpdateWithoutOrderedByInput>
    create: XOR<CommandCreateWithoutOrderedByInput, CommandUncheckedCreateWithoutOrderedByInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutOrderedByInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutOrderedByInput, CommandUncheckedUpdateWithoutOrderedByInput>
  }

  export type CommandUpdateManyWithWhereWithoutOrderedByInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutCommandsInput>
  }

  export type UserShippingAdressUpsertWithWhereUniqueWithoutForUserInput = {
    where: UserShippingAdressWhereUniqueInput
    update: XOR<UserShippingAdressUpdateWithoutForUserInput, UserShippingAdressUncheckedUpdateWithoutForUserInput>
    create: XOR<UserShippingAdressCreateWithoutForUserInput, UserShippingAdressUncheckedCreateWithoutForUserInput>
  }

  export type UserShippingAdressUpdateWithWhereUniqueWithoutForUserInput = {
    where: UserShippingAdressWhereUniqueInput
    data: XOR<UserShippingAdressUpdateWithoutForUserInput, UserShippingAdressUncheckedUpdateWithoutForUserInput>
  }

  export type UserShippingAdressUpdateManyWithWhereWithoutForUserInput = {
    where: UserShippingAdressScalarWhereInput
    data: XOR<UserShippingAdressUpdateManyMutationInput, UserShippingAdressUncheckedUpdateManyWithoutShippingAdressInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    title?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    context?: StringFilter | string
    priority?: IntFilter | number
    canLockScreen?: BoolFilter | boolean
    theme?: StringFilter | string
    commandId?: StringNullableFilter | string | null
    hasUserRead?: BoolFilter | boolean
    userId?: StringNullableFilter | string | null
  }

  export type ShippingZoneCreateWithoutUserShippingAdressInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
    products?: ProductCreateNestedManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedCreateWithoutUserShippingAdressInput = {
    id?: string
    townName: string
    townCode: string
    baseShippingPrice: number
  }

  export type ShippingZoneCreateOrConnectWithoutUserShippingAdressInput = {
    where: ShippingZoneWhereUniqueInput
    create: XOR<ShippingZoneCreateWithoutUserShippingAdressInput, ShippingZoneUncheckedCreateWithoutUserShippingAdressInput>
  }

  export type MediaCreateWithoutUserShippingAdressesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptCreateNestedManyWithoutReceiptMediaInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutUserShippingAdressesInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedCreateNestedManyWithoutReceiptMediaInput
  }

  export type MediaCreateOrConnectWithoutUserShippingAdressesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUserShippingAdressesInput, MediaUncheckedCreateWithoutUserShippingAdressesInput>
  }

  export type UserCreateWithoutShippingAdressInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaCreateNestedOneWithoutForUserInput
    commands?: CommandCreateNestedManyWithoutOrderedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShippingAdressInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaUncheckedCreateNestedOneWithoutForUserInput
    commands?: CommandUncheckedCreateNestedManyWithoutOrderedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShippingAdressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShippingAdressInput, UserUncheckedCreateWithoutShippingAdressInput>
  }

  export type CommandCreateWithoutShippingAdressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutShippingAdressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    receiptId: string
    appliedDiscountId?: string | null
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutShippingAdressInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutShippingAdressInput, CommandUncheckedCreateWithoutShippingAdressInput>
  }

  export type CommandCreateManyShippingAdressInputEnvelope = {
    data: Enumerable<CommandCreateManyShippingAdressInput>
    skipDuplicates?: boolean
  }

  export type ShippingZoneUpsertWithoutUserShippingAdressInput = {
    update: XOR<ShippingZoneUpdateWithoutUserShippingAdressInput, ShippingZoneUncheckedUpdateWithoutUserShippingAdressInput>
    create: XOR<ShippingZoneCreateWithoutUserShippingAdressInput, ShippingZoneUncheckedCreateWithoutUserShippingAdressInput>
  }

  export type ShippingZoneUpdateWithoutUserShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
    products?: ProductUpdateManyWithoutShippingZonesInput
  }

  export type ShippingZoneUncheckedUpdateWithoutUserShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
  }

  export type MediaUpsertWithoutUserShippingAdressesInput = {
    update: XOR<MediaUpdateWithoutUserShippingAdressesInput, MediaUncheckedUpdateWithoutUserShippingAdressesInput>
    create: XOR<MediaCreateWithoutUserShippingAdressesInput, MediaUncheckedCreateWithoutUserShippingAdressesInput>
  }

  export type MediaUpdateWithoutUserShippingAdressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutUserShippingAdressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type UserUpsertWithoutShippingAdressInput = {
    update: XOR<UserUpdateWithoutShippingAdressInput, UserUncheckedUpdateWithoutShippingAdressInput>
    create: XOR<UserCreateWithoutShippingAdressInput, UserUncheckedCreateWithoutShippingAdressInput>
  }

  export type UserUpdateWithoutShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUpdateOneWithoutForUserInput
    commands?: CommandUpdateManyWithoutOrderedByInput
    notifications?: NotificationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUncheckedUpdateOneWithoutForUserInput
    commands?: CommandUncheckedUpdateManyWithoutOrderedByInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
  }

  export type CommandUpsertWithWhereUniqueWithoutShippingAdressInput = {
    where: CommandWhereUniqueInput
    update: XOR<CommandUpdateWithoutShippingAdressInput, CommandUncheckedUpdateWithoutShippingAdressInput>
    create: XOR<CommandCreateWithoutShippingAdressInput, CommandUncheckedCreateWithoutShippingAdressInput>
  }

  export type CommandUpdateWithWhereUniqueWithoutShippingAdressInput = {
    where: CommandWhereUniqueInput
    data: XOR<CommandUpdateWithoutShippingAdressInput, CommandUncheckedUpdateWithoutShippingAdressInput>
  }

  export type CommandUpdateManyWithWhereWithoutShippingAdressInput = {
    where: CommandScalarWhereInput
    data: XOR<CommandUpdateManyMutationInput, CommandUncheckedUpdateManyWithoutCommandsInput>
  }

  export type UserCreateWithoutCommandsInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaCreateNestedOneWithoutForUserInput
    shippingAdress?: UserShippingAdressCreateNestedManyWithoutForUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommandsInput = {
    id?: string
    firstName: string
    lastName: string
    passwordHash: string
    email: string
    phone: string
    accoundActivated?: boolean
    role: string
    currentRole: string
    profileImage?: MediaUncheckedCreateNestedOneWithoutForUserInput
    shippingAdress?: UserShippingAdressUncheckedCreateNestedManyWithoutForUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommandsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
  }

  export type UserShippingAdressCreateWithoutCommandsInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    shippingZone: ShippingZoneCreateNestedOneWithoutUserShippingAdressInput
    audioFile?: MediaCreateNestedOneWithoutUserShippingAdressesInput
    forUser: UserCreateNestedOneWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedCreateWithoutCommandsInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    forUserId: string
  }

  export type UserShippingAdressCreateOrConnectWithoutCommandsInput = {
    where: UserShippingAdressWhereUniqueInput
    create: XOR<UserShippingAdressCreateWithoutCommandsInput, UserShippingAdressUncheckedCreateWithoutCommandsInput>
  }

  export type ReceiptCreateWithoutCommandInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    receiptMedia?: MediaCreateNestedOneWithoutReceiptMediasInput
  }

  export type ReceiptUncheckedCreateWithoutCommandInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
    receiptMediaId?: string | null
  }

  export type ReceiptCreateOrConnectWithoutCommandInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutCommandInput, ReceiptUncheckedCreateWithoutCommandInput>
  }

  export type CommandProductCreateWithoutCommandInput = {
    id?: string
    hasUserDeleted?: boolean
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
    product: ProductCreateNestedOneWithoutCommandProductsInput
    commandUnitProduct?: CommandUnitProductCreateNestedOneWithoutCommandProductsInput
  }

  export type CommandProductUncheckedCreateWithoutCommandInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductCreateOrConnectWithoutCommandInput = {
    where: CommandProductWhereUniqueInput
    create: XOR<CommandProductCreateWithoutCommandInput, CommandProductUncheckedCreateWithoutCommandInput>
  }

  export type CommandProductCreateManyCommandInputEnvelope = {
    data: Enumerable<CommandProductCreateManyCommandInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCommandInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    hasUserRead?: boolean
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCommandInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    hasUserRead?: boolean
    userId?: string | null
  }

  export type NotificationCreateOrConnectWithoutCommandInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCommandInput, NotificationUncheckedCreateWithoutCommandInput>
  }

  export type NotificationCreateManyCommandInputEnvelope = {
    data: Enumerable<NotificationCreateManyCommandInput>
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutCommandInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    bannerImage?: MediaCreateNestedOneWithoutDiscountsInput
    pubs?: PubCreateNestedManyWithoutForDiscountInput
    product?: ProductCreateNestedManyWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateWithoutCommandInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
    pubs?: PubUncheckedCreateNestedManyWithoutForDiscountInput
  }

  export type DiscountCreateOrConnectWithoutCommandInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutCommandInput, DiscountUncheckedCreateWithoutCommandInput>
  }

  export type UserUpsertWithoutCommandsInput = {
    update: XOR<UserUpdateWithoutCommandsInput, UserUncheckedUpdateWithoutCommandsInput>
    create: XOR<UserCreateWithoutCommandsInput, UserUncheckedCreateWithoutCommandsInput>
  }

  export type UserUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUpdateOneWithoutForUserInput
    shippingAdress?: UserShippingAdressUpdateManyWithoutForUserInput
    notifications?: NotificationUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    accoundActivated?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    currentRole?: StringFieldUpdateOperationsInput | string
    profileImage?: MediaUncheckedUpdateOneWithoutForUserInput
    shippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutForUserInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserInput
  }

  export type UserShippingAdressUpsertWithoutCommandsInput = {
    update: XOR<UserShippingAdressUpdateWithoutCommandsInput, UserShippingAdressUncheckedUpdateWithoutCommandsInput>
    create: XOR<UserShippingAdressCreateWithoutCommandsInput, UserShippingAdressUncheckedCreateWithoutCommandsInput>
  }

  export type UserShippingAdressUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    shippingZone?: ShippingZoneUpdateOneRequiredWithoutUserShippingAdressInput
    audioFile?: MediaUpdateOneWithoutUserShippingAdressesInput
    forUser?: UserUpdateOneRequiredWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
  }

  export type ReceiptUpsertWithoutCommandInput = {
    update: XOR<ReceiptUpdateWithoutCommandInput, ReceiptUncheckedUpdateWithoutCommandInput>
    create: XOR<ReceiptCreateWithoutCommandInput, ReceiptUncheckedCreateWithoutCommandInput>
  }

  export type ReceiptUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    receiptMedia?: MediaUpdateOneWithoutReceiptMediasInput
  }

  export type ReceiptUncheckedUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    receiptMediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandProductUpsertWithWhereUniqueWithoutCommandInput = {
    where: CommandProductWhereUniqueInput
    update: XOR<CommandProductUpdateWithoutCommandInput, CommandProductUncheckedUpdateWithoutCommandInput>
    create: XOR<CommandProductCreateWithoutCommandInput, CommandProductUncheckedCreateWithoutCommandInput>
  }

  export type CommandProductUpdateWithWhereUniqueWithoutCommandInput = {
    where: CommandProductWhereUniqueInput
    data: XOR<CommandProductUpdateWithoutCommandInput, CommandProductUncheckedUpdateWithoutCommandInput>
  }

  export type CommandProductUpdateManyWithWhereWithoutCommandInput = {
    where: CommandProductScalarWhereInput
    data: XOR<CommandProductUpdateManyMutationInput, CommandProductUncheckedUpdateManyWithoutCommandProductsInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCommandInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCommandInput, NotificationUncheckedUpdateWithoutCommandInput>
    create: XOR<NotificationCreateWithoutCommandInput, NotificationUncheckedCreateWithoutCommandInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCommandInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCommandInput, NotificationUncheckedUpdateWithoutCommandInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCommandInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type DiscountUpsertWithoutCommandInput = {
    update: XOR<DiscountUpdateWithoutCommandInput, DiscountUncheckedUpdateWithoutCommandInput>
    create: XOR<DiscountCreateWithoutCommandInput, DiscountUncheckedCreateWithoutCommandInput>
  }

  export type DiscountUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImage?: MediaUpdateOneWithoutDiscountsInput
    pubs?: PubUpdateManyWithoutForDiscountInput
    product?: ProductUpdateManyWithoutDiscountsInput
  }

  export type DiscountUncheckedUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pubs?: PubUncheckedUpdateManyWithoutForDiscountInput
  }

  export type ProductCreateWithoutCommandProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    marque?: MarqueCreateNestedOneWithoutProductsInput
    variantParent?: ProductCreateNestedOneWithoutVariationsInput
    productAttributes?: ProductAttributeCreateNestedManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaCreateNestedManyWithoutProductsInput
    variations?: ProductCreateNestedManyWithoutVariantParentInput
    categories?: CategoryCreateNestedManyWithoutProductsInput
    shippingZones?: ShippingZoneCreateNestedManyWithoutProductsInput
    tags?: TagCreateNestedManyWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductCreateNestedManyWithoutProductInput
    discounts?: DiscountCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCommandProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
    productAttributes?: ProductAttributeUncheckedCreateNestedManyWithoutOnlyForProductInput
    variations?: ProductUncheckedCreateNestedManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCommandProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCommandProductsInput, ProductUncheckedCreateWithoutCommandProductsInput>
  }

  export type CommandUnitProductCreateWithoutCommandProductsInput = {
    id?: string
    isDefault?: boolean
    unitPrice: number
    commandUnit: CommandUnitCreateNestedOneWithoutCommandUnitProductsInput
    product?: ProductCreateNestedOneWithoutCommandUnitProductsInput
    priceRule: PriceRuleCreateNestedOneWithoutCommandUnitProductsInput
  }

  export type CommandUnitProductUncheckedCreateWithoutCommandProductsInput = {
    id?: string
    commandUnitId: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
  }

  export type CommandUnitProductCreateOrConnectWithoutCommandProductsInput = {
    where: CommandUnitProductWhereUniqueInput
    create: XOR<CommandUnitProductCreateWithoutCommandProductsInput, CommandUnitProductUncheckedCreateWithoutCommandProductsInput>
  }

  export type CommandCreateWithoutCommandProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    receipt: ReceiptCreateNestedOneWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutCommandProductsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutCommandProductsInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutCommandProductsInput, CommandUncheckedCreateWithoutCommandProductsInput>
  }

  export type ProductUpsertWithoutCommandProductsInput = {
    update: XOR<ProductUpdateWithoutCommandProductsInput, ProductUncheckedUpdateWithoutCommandProductsInput>
    create: XOR<ProductCreateWithoutCommandProductsInput, ProductUncheckedCreateWithoutCommandProductsInput>
  }

  export type ProductUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
  }

  export type CommandUnitProductUpsertWithoutCommandProductsInput = {
    update: XOR<CommandUnitProductUpdateWithoutCommandProductsInput, CommandUnitProductUncheckedUpdateWithoutCommandProductsInput>
    create: XOR<CommandUnitProductCreateWithoutCommandProductsInput, CommandUnitProductUncheckedCreateWithoutCommandProductsInput>
  }

  export type CommandUnitProductUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    commandUnit?: CommandUnitUpdateOneRequiredWithoutCommandUnitProductsInput
    product?: ProductUpdateOneWithoutCommandUnitProductsInput
    priceRule?: PriceRuleUpdateOneRequiredWithoutCommandUnitProductsInput
  }

  export type CommandUnitProductUncheckedUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    priceRuleId?: StringFieldUpdateOperationsInput | string
  }

  export type CommandUpsertWithoutCommandProductsInput = {
    update: XOR<CommandUpdateWithoutCommandProductsInput, CommandUncheckedUpdateWithoutCommandProductsInput>
    create: XOR<CommandCreateWithoutCommandProductsInput, CommandUncheckedCreateWithoutCommandProductsInput>
  }

  export type CommandUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type MediaCreateWithoutReceiptMediasInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    products?: ProductCreateNestedManyWithoutMediasInput
    iconImagesCategories?: CategoryCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryCreateNestedManyWithoutBannerImageInput
    marque?: MarqueCreateNestedManyWithoutImageInput
    pubs?: PubCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountCreateNestedManyWithoutBannerImageInput
    forUser?: UserCreateNestedOneWithoutProfileImageInput
  }

  export type MediaUncheckedCreateWithoutReceiptMediasInput = {
    id?: string
    filename: string
    fileType: string
    path: string
    fileDuration?: number | null
    source?: string
    userId?: string | null
    iconImagesCategories?: CategoryUncheckedCreateNestedManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedCreateNestedManyWithoutBannerImageInput
    marque?: MarqueUncheckedCreateNestedManyWithoutImageInput
    pubs?: PubUncheckedCreateNestedManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedCreateNestedManyWithoutAudioFileInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutBannerImageInput
  }

  export type MediaCreateOrConnectWithoutReceiptMediasInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutReceiptMediasInput, MediaUncheckedCreateWithoutReceiptMediasInput>
  }

  export type CommandCreateWithoutReceiptInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    orderedBy: UserCreateNestedOneWithoutCommandsInput
    shippingAdress?: UserShippingAdressCreateNestedOneWithoutCommandsInput
    commandProducts?: CommandProductCreateNestedManyWithoutCommandInput
    notifications?: NotificationCreateNestedManyWithoutCommandInput
    appliedDiscount?: DiscountCreateNestedOneWithoutCommandInput
  }

  export type CommandUncheckedCreateWithoutReceiptInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    appliedDiscountId?: string | null
    commandProducts?: CommandProductUncheckedCreateNestedManyWithoutCommandInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommandInput
  }

  export type CommandCreateOrConnectWithoutReceiptInput = {
    where: CommandWhereUniqueInput
    create: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
  }

  export type MediaUpsertWithoutReceiptMediasInput = {
    update: XOR<MediaUpdateWithoutReceiptMediasInput, MediaUncheckedUpdateWithoutReceiptMediasInput>
    create: XOR<MediaCreateWithoutReceiptMediasInput, MediaUncheckedCreateWithoutReceiptMediasInput>
  }

  export type MediaUpdateWithoutReceiptMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutMediasInput
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutReceiptMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
  }

  export type CommandUpsertWithoutReceiptInput = {
    update: XOR<CommandUpdateWithoutReceiptInput, CommandUncheckedUpdateWithoutReceiptInput>
    create: XOR<CommandCreateWithoutReceiptInput, CommandUncheckedCreateWithoutReceiptInput>
  }

  export type CommandUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    iconImageId?: string | null
    bannerImageId?: string | null
  }

  export type ProductAttributeCreateManyCategoryInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    onlyForProductId?: string | null
  }

  export type MarqueUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    image?: MediaUpdateOneWithoutMarqueInput
    products?: ProductUpdateManyWithoutMarqueInput
  }

  export type MarqueUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutMarqueInput
  }

  export type MarqueUncheckedUpdateManyWithoutMarquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductAttributeUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    metas?: ProductAttributeMetaUpdateManyWithoutAttributeInput
    onlyForProduct?: ProductUpdateOneWithoutProductAttributesInput
  }

  export type ProductAttributeUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    onlyForProductId?: NullableStringFieldUpdateOperationsInput | string | null
    metas?: ProductAttributeMetaUncheckedUpdateManyWithoutAttributeInput
  }

  export type ProductAttributeUncheckedUpdateManyWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    onlyForProductId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyMarqueInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    variantParentId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
  }

  export type CategoryUpdateWithoutMarquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutMarquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutMarqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutMarqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type CommandCreateManyAppliedDiscountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
  }

  export type PubCreateManyForDiscountInput = {
    id?: string
    name: string
    bannerImageId?: string | null
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
  }

  export type CommandUpdateWithoutAppliedDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutAppliedDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type CommandUncheckedUpdateManyWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
  }

  export type PubUpdateWithoutForDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bannerImage?: MediaUpdateOneWithoutPubsInput
  }

  export type PubUncheckedUpdateWithoutForDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PubUncheckedUpdateManyWithoutPubsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandUnitProductCreateManyPriceRuleInput = {
    id?: string
    commandUnitId: string
    productId: string
    isDefault?: boolean
    unitPrice: number
  }

  export type CommandUnitProductUpdateWithoutPriceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    commandUnit?: CommandUnitUpdateOneRequiredWithoutCommandUnitProductsInput
    product?: ProductUpdateOneWithoutCommandUnitProductsInput
    commandProducts?: CommandProductUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedUpdateWithoutPriceRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedUpdateManyWithoutCommandUnitProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
  }

  export type UserShippingAdressCreateManyShippingZoneInput = {
    id?: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
    forUserId: string
  }

  export type UserShippingAdressUpdateWithoutShippingZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFile?: MediaUpdateOneWithoutUserShippingAdressesInput
    forUser?: UserUpdateOneRequiredWithoutShippingAdressInput
    commands?: CommandUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateWithoutShippingZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
    commands?: CommandUncheckedUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutUserShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUpdateWithoutVariationMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutVariationMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductAttributeMetaCreateManyAttributeInput = {
    id?: string
    name: string
    value: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUpdateWithoutAttributeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    products?: ProductUpdateManyWithoutVariationMetasInput
  }

  export type ProductAttributeMetaUncheckedUpdateWithoutAttributeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUncheckedUpdateManyWithoutMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type CommandUnitProductCreateManyCommandUnitInput = {
    id?: string
    productId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
  }

  export type CommandUnitProductUpdateWithoutCommandUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneWithoutCommandUnitProductsInput
    priceRule?: PriceRuleUpdateOneRequiredWithoutCommandUnitProductsInput
    commandProducts?: CommandProductUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedUpdateWithoutCommandUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    priceRuleId?: StringFieldUpdateOperationsInput | string
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandProductCreateManyCommandUnitProductInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type CommandProductUpdateWithoutCommandUnitProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCommandProductsInput
    command?: CommandUpdateOneRequiredWithoutCommandProductsInput
  }

  export type CommandProductUncheckedUpdateWithoutCommandUnitProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    commandId?: StringFieldUpdateOperationsInput | string
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandProductUncheckedUpdateManyWithoutCommandProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    commandId?: StringFieldUpdateOperationsInput | string
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryCreateManyIconImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    bannerImageId?: string | null
  }

  export type CategoryCreateManyBannerImageInput = {
    id?: string
    title: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    iconImageId?: string | null
  }

  export type MarqueCreateManyImageInput = {
    id?: string
    name: string
    categoryId: string
  }

  export type PubCreateManyBannerImageInput = {
    id?: string
    name: string
    link?: string | null
    description?: string | null
    startAt: Date | string
    endAt: Date | string
    forDiscountId?: string | null
  }

  export type UserShippingAdressCreateManyAudioFileInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    forUserId: string
  }

  export type DiscountCreateManyBannerImageInput = {
    id?: string
    name: string
    discountType: string
    discountNature: string
    discountCode: string
    discount: number
    startAt: Date | string
    endAt: Date | string
    inCartProductMin?: number | null
    inCartProductMax?: number | null
    commandAmountMin?: number | null
    commandAmountMax?: number | null
    description?: string | null
  }

  export type ReceiptCreateManyReceiptMediaInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    hasUserDeleted?: boolean
    paidAt?: Date | string | null
    isPaid?: boolean
    outPaymentId?: string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas: JsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    variantParent?: ProductUpdateOneWithoutVariationsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    variantParentId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type CategoryUpdateWithoutIconImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutIconImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutIconImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    products?: ProductUpdateManyWithoutCategoriesInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutBannerImagesCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarqueUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateManyWithoutMarquesInput
    products?: ProductUpdateManyWithoutMarqueInput
  }

  export type MarqueUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutMarqueInput
  }

  export type MarqueUncheckedUpdateManyWithoutMarqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PubUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forDiscount?: DiscountUpdateOneWithoutPubsInput
  }

  export type PubUncheckedUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserShippingAdressUpdateWithoutAudioFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    shippingZone?: ShippingZoneUpdateOneRequiredWithoutUserShippingAdressInput
    forUser?: UserUpdateOneRequiredWithoutShippingAdressInput
    commands?: CommandUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateWithoutAudioFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
    commands?: CommandUncheckedUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutUserShippingAdressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    forUserId?: StringFieldUpdateOperationsInput | string
  }

  export type DiscountUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUpdateManyWithoutForDiscountInput
    product?: ProductUpdateManyWithoutDiscountsInput
  }

  export type DiscountUncheckedUpdateWithoutBannerImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUncheckedUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedUpdateManyWithoutForDiscountInput
  }

  export type DiscountUncheckedUpdateManyWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceiptUpdateWithoutReceiptMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    command?: CommandUpdateOneWithoutReceiptInput
  }

  export type ReceiptUncheckedUpdateWithoutReceiptMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
    command?: CommandUncheckedUpdateOneWithoutReceiptInput
  }

  export type ReceiptUncheckedUpdateManyWithoutReceiptMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    outPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    outPaymentDetails?: NullableJsonNullValueInput | InputJsonValue
    receiptMetas?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeCreateManyOnlyForProductInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    global?: boolean
    categoryId?: string | null
  }

  export type ProductCreateManyVariantParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: string
    productWeight?: number | null
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sku?: string | null
    marqueId?: string | null
    showProduct?: boolean
    hasUserDeleted?: boolean
  }

  export type CommandUnitProductCreateManyProductInput = {
    id?: string
    commandUnitId: string
    isDefault?: boolean
    unitPrice: number
    priceRuleId: string
  }

  export type CommandProductCreateManyProductInput = {
    id?: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    commandId: string
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type ProductAttributeUpdateWithoutOnlyForProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    metas?: ProductAttributeMetaUpdateManyWithoutAttributeInput
    category?: CategoryUpdateOneWithoutAttributesInput
  }

  export type ProductAttributeUncheckedUpdateWithoutOnlyForProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    metas?: ProductAttributeMetaUncheckedUpdateManyWithoutAttributeInput
  }

  export type ProductAttributeUncheckedUpdateManyWithoutProductAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    global?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductAttributeMetaUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    attribute?: ProductAttributeUpdateOneRequiredWithoutMetasInput
  }

  export type ProductAttributeMetaUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductAttributeMetaUncheckedUpdateManyWithoutVariationMetasInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutVariantParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    marque?: MarqueUpdateOneWithoutProductsInput
    productAttributes?: ProductAttributeUpdateManyWithoutOnlyForProductInput
    variationMetas?: ProductAttributeMetaUpdateManyWithoutProductsInput
    variations?: ProductUpdateManyWithoutVariantParentInput
    categories?: CategoryUpdateManyWithoutProductsInput
    shippingZones?: ShippingZoneUpdateManyWithoutProductsInput
    tags?: TagUpdateManyWithoutProductsInput
    medias?: MediaUpdateManyWithoutProductsInput
    commandUnitProducts?: CommandUnitProductUpdateManyWithoutProductInput
    commandProducts?: CommandProductUpdateManyWithoutProductInput
    discounts?: DiscountUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutVariantParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    productAttributes?: ProductAttributeUncheckedUpdateManyWithoutOnlyForProductInput
    variations?: ProductUncheckedUpdateManyWithoutVariantParentInput
    commandUnitProducts?: CommandUnitProductUncheckedUpdateManyWithoutProductInput
    commandProducts?: CommandProductUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutVariationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    productWeight?: NullableIntFieldUpdateOperationsInput | number | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    marqueId?: NullableStringFieldUpdateOperationsInput | string | null
    showProduct?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenInput
    iconImage?: MediaUpdateOneWithoutIconImagesCategoriesInput
    bannerImage?: MediaUpdateOneWithoutBannerImagesCategoriesInput
    marques?: MarqueUpdateManyWithoutCategoryInput
    children?: CategoryUpdateManyWithoutParentInput
    attributes?: ProductAttributeUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentInput
    attributes?: ProductAttributeUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImageId?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShippingZoneUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
    userShippingAdress?: UserShippingAdressUpdateManyWithoutShippingZoneInput
  }

  export type ShippingZoneUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
    userShippingAdress?: UserShippingAdressUncheckedUpdateManyWithoutShippingZoneInput
  }

  export type ShippingZoneUncheckedUpdateManyWithoutShippingZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    townName?: StringFieldUpdateOperationsInput | string
    townCode?: StringFieldUpdateOperationsInput | string
    baseShippingPrice?: IntFieldUpdateOperationsInput | number
  }

  export type TagUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    iconImagesCategories?: CategoryUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUpdateManyWithoutBannerImageInput
    marque?: MarqueUpdateManyWithoutImageInput
    pubs?: PubUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUpdateManyWithoutAudioFileInput
    discounts?: DiscountUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUpdateManyWithoutReceiptMediaInput
    forUser?: UserUpdateOneWithoutProfileImageInput
  }

  export type MediaUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    iconImagesCategories?: CategoryUncheckedUpdateManyWithoutIconImageInput
    bannerImagesCategories?: CategoryUncheckedUpdateManyWithoutBannerImageInput
    marque?: MarqueUncheckedUpdateManyWithoutImageInput
    pubs?: PubUncheckedUpdateManyWithoutBannerImageInput
    userShippingAdresses?: UserShippingAdressUncheckedUpdateManyWithoutAudioFileInput
    discounts?: DiscountUncheckedUpdateManyWithoutBannerImageInput
    receiptMedias?: ReceiptUncheckedUpdateManyWithoutReceiptMediaInput
  }

  export type MediaUncheckedUpdateManyWithoutMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    fileDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommandUnitProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    commandUnit?: CommandUnitUpdateOneRequiredWithoutCommandUnitProductsInput
    priceRule?: PriceRuleUpdateOneRequiredWithoutCommandUnitProductsInput
    commandProducts?: CommandProductUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandUnitProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandUnitId?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    unitPrice?: IntFieldUpdateOperationsInput | number
    priceRuleId?: StringFieldUpdateOperationsInput | string
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandUnitProductInput
  }

  export type CommandProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    commandUnitProduct?: CommandUnitProductUpdateOneWithoutCommandProductsInput
    command?: CommandUpdateOneRequiredWithoutCommandProductsInput
  }

  export type CommandProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    commandUnitProductId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    commandId?: StringFieldUpdateOperationsInput | string
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiscountUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bannerImage?: MediaUpdateOneWithoutDiscountsInput
    command?: CommandUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUpdateManyWithoutForDiscountInput
  }

  export type DiscountUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bannerImageId?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: StringFieldUpdateOperationsInput | string
    discountNature?: StringFieldUpdateOperationsInput | string
    discountCode?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inCartProductMin?: NullableIntFieldUpdateOperationsInput | number | null
    inCartProductMax?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMin?: NullableIntFieldUpdateOperationsInput | number | null
    commandAmountMax?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    command?: CommandUncheckedUpdateManyWithoutAppliedDiscountInput
    pubs?: PubUncheckedUpdateManyWithoutForDiscountInput
  }

  export type CommandCreateManyOrderedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    shippingAdressId?: string | null
    receiptId: string
    appliedDiscountId?: string | null
  }

  export type UserShippingAdressCreateManyForUserInput = {
    id?: string
    shippingZoneId: string
    fullName: string
    phone: string
    alternatePhone: string
    adressType: string
    quatier: string
    hasUserDeleted?: boolean
    additionalDetails?: string | null
    audioFileId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    commandId?: string | null
    hasUserRead?: boolean
  }

  export type CommandUpdateWithoutOrderedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdress?: UserShippingAdressUpdateOneWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutOrderedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type CommandUncheckedUpdateManyWithoutCommandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    shippingAdressId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserShippingAdressUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    shippingZone?: ShippingZoneUpdateOneRequiredWithoutUserShippingAdressInput
    audioFile?: MediaUpdateOneWithoutUserShippingAdressesInput
    commands?: CommandUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateWithoutForUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
    commands?: CommandUncheckedUpdateManyWithoutShippingAdressInput
  }

  export type UserShippingAdressUncheckedUpdateManyWithoutShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    shippingZoneId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    alternatePhone?: StringFieldUpdateOperationsInput | string
    adressType?: StringFieldUpdateOperationsInput | string
    quatier?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    additionalDetails?: NullableStringFieldUpdateOperationsInput | string | null
    audioFileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    command?: CommandUpdateOneWithoutNotificationsInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    commandId?: NullableStringFieldUpdateOperationsInput | string | null
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    commandId?: NullableStringFieldUpdateOperationsInput | string | null
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommandCreateManyShippingAdressInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalPrice: number
    orderId: number
    archived?: boolean | null
    delivered?: boolean
    status?: string
    orderedById: string
    hasUserCanceled?: boolean
    hasUserDeleted?: boolean
    receiptId: string
    appliedDiscountId?: string | null
  }

  export type CommandUpdateWithoutShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    orderedBy?: UserUpdateOneRequiredWithoutCommandsInput
    receipt?: ReceiptUpdateOneRequiredWithoutCommandInput
    commandProducts?: CommandProductUpdateManyWithoutCommandInput
    notifications?: NotificationUpdateManyWithoutCommandInput
    appliedDiscount?: DiscountUpdateOneWithoutCommandInput
  }

  export type CommandUncheckedUpdateWithoutShippingAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    archived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    delivered?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    orderedById?: StringFieldUpdateOperationsInput | string
    hasUserCanceled?: BoolFieldUpdateOperationsInput | boolean
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    receiptId?: StringFieldUpdateOperationsInput | string
    appliedDiscountId?: NullableStringFieldUpdateOperationsInput | string | null
    commandProducts?: CommandProductUncheckedUpdateManyWithoutCommandInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommandInput
  }

  export type CommandProductCreateManyCommandInput = {
    id?: string
    productId: string
    hasUserDeleted?: boolean
    commandUnitProductId: string
    quantite: number
    hasCustomerConfirmShipping?: boolean
    hasAgentConfirmShipping?: boolean
  }

  export type NotificationCreateManyCommandInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    context: string
    priority?: number
    canLockScreen?: boolean
    theme?: string
    hasUserRead?: boolean
    userId?: string | null
  }

  export type CommandProductUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCommandProductsInput
    commandUnitProduct?: CommandUnitProductUpdateOneWithoutCommandProductsInput
  }

  export type CommandProductUncheckedUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    hasUserDeleted?: BoolFieldUpdateOperationsInput | boolean
    commandUnitProductId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    hasCustomerConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
    hasAgentConfirmShipping?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutNotificationsInput
  }

  export type NotificationUncheckedUpdateWithoutCommandInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    canLockScreen?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    hasUserRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}